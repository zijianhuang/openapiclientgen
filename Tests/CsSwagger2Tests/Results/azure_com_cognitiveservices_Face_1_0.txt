//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Error information returned by the API
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class APIError
	{
		
		/// <summary>
		/// Error body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Error Error { get; set; }
	}
	
	/// <summary>
	/// Error body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Error
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Accessory item and corresponding confidence level.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Accessory
	{
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidence")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Confidence { get; set; }
		
		/// <summary>
		/// Type of an accessory
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<AccessoryType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum AccessoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		headWear = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		glasses = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mask = 2,
	}
	
	/// <summary>
	/// Request body for applying snapshot operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class ApplySnapshotRequest
	{
		
		/// <summary>
		/// Snapshot applying mode. Currently only CreateNew is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<ApplySnapshotRequestMode> Mode { get; set; }
		
		/// <summary>
		/// User specified target object id to be created from the snapshot.
		/// Required
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string ObjectId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ApplySnapshotRequestMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CreateNew = 0,
	}
	
	/// <summary>
	/// Properties describing any presence of blur within the image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Blur
	{
		
		/// <summary>
		/// An enum value indicating level of blurriness.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blurLevel")]
		public System.Nullable<BlurBlurLevel> BlurLevel { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating the intensity level associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum BlurBlurLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Low = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Medium = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		High = 2,
	}
	
	/// <summary>
	/// Coordinates within an image
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Coordinate
	{
		
		/// <summary>
		/// The horizontal component, in pixels.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="x")]
		public double X { get; set; }
		
		/// <summary>
		/// The vertical component, in pixels.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="y")]
		public double Y { get; set; }
	}
	
	/// <summary>
	/// Detected Face object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class DetectedFace
	{
		
		/// <summary>
		/// Face Attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="faceAttributes")]
		public FaceAttributes FaceAttributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="faceId")]
		public string FaceId { get; set; }
		
		/// <summary>
		/// A collection of 27-point face landmarks pointing to the important positions of face components.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="faceLandmarks")]
		public FaceLandmarks FaceLandmarks { get; set; }
		
		/// <summary>
		/// A rectangle within which a face can be found
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceRectangle")]
		public FaceRectangle FaceRectangle { get; set; }
		
		/// <summary>
		/// Name of recognition model. Recognition model is used when the face features are extracted and associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A recognition model name can be provided when performing Face - Detect or (Large)FaceList - Create or (Large)PersonGroup - Create. The default value is 'recognition_01', if latest model needed, please explicitly specify the model you need.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recognitionModel")]
		public System.Nullable<DetectedFaceRecognitionModel> RecognitionModel { get; set; }
	}
	
	/// <summary>
	/// Face Attributes
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class FaceAttributes
	{
		
		/// <summary>
		/// Properties describing any accessories on a given face.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessories")]
		public Accessory[] Accessories { get; set; }
		
		/// <summary>
		/// Age in years
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="age")]
		public System.Nullable<System.Double> Age { get; set; }
		
		/// <summary>
		/// Properties describing any presence of blur within the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blur")]
		public Blur Blur { get; set; }
		
		/// <summary>
		/// Properties describing facial emotion in form of confidence ranging from 0 to 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emotion")]
		public Emotion Emotion { get; set; }
		
		/// <summary>
		/// Properties describing exposure level of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exposure")]
		public Exposure Exposure { get; set; }
		
		/// <summary>
		/// Properties describing facial hair attributes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facialHair")]
		public FacialHair FacialHair { get; set; }
		
		/// <summary>
		/// Possible gender of the face.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gender")]
		public System.Nullable<FaceAttributesGender> Gender { get; set; }
		
		/// <summary>
		/// Glasses type if any of the face.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="glasses")]
		public System.Nullable<FaceAttributesGlasses> Glasses { get; set; }
		
		/// <summary>
		/// Properties describing hair attributes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hair")]
		public Hair Hair { get; set; }
		
		/// <summary>
		/// Properties indicating head pose of the face.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headPose")]
		public HeadPose HeadPose { get; set; }
		
		/// <summary>
		/// Properties describing present makeups on a given face.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="makeup")]
		public Makeup Makeup { get; set; }
		
		/// <summary>
		/// Properties describing noise level of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noise")]
		public Noise Noise { get; set; }
		
		/// <summary>
		/// Properties describing occlusions on a given face.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="occlusion")]
		public Occlusion Occlusion { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating the intensity level associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smile")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Smile { get; set; }
	}
	
	/// <summary>
	/// Properties describing facial emotion in form of confidence ranging from 0 to 1.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Emotion
	{
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="anger")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Anger { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contempt")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Contempt { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disgust")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Disgust { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fear")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Fear { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="happiness")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Happiness { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="neutral")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Neutral { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sadness")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Sadness { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="surprise")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Surprise { get; set; }
	}
	
	/// <summary>
	/// Properties describing exposure level of the image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Exposure
	{
		
		/// <summary>
		/// An enum value indicating level of exposure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exposureLevel")]
		public System.Nullable<ExposureExposureLevel> ExposureLevel { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating the intensity level associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum ExposureExposureLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UnderExposure = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GoodExposure = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OverExposure = 2,
	}
	
	/// <summary>
	/// Properties describing facial hair attributes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class FacialHair
	{
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="beard")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Beard { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="moustache")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Moustache { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sideburns")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Sideburns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum FaceAttributesGender
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		male = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		female = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum FaceAttributesGlasses
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		noGlasses = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		readingGlasses = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sunglasses = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		swimmingGoggles = 3,
	}
	
	/// <summary>
	/// Properties describing hair attributes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Hair
	{
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bald")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Bald { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hairColor")]
		public HairColor[] HairColor { get; set; }
		
		/// <summary>
		/// A boolean value describing whether the hair is visible in the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invisible")]
		public System.Nullable<System.Boolean> Invisible { get; set; }
	}
	
	/// <summary>
	/// Hair color and associated confidence
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class HairColor
	{
		
		/// <summary>
		/// Name of the hair color.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="color")]
		public System.Nullable<HairColorColor> Color { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidence")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Confidence { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum HairColorColor
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		white = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		gray = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		blond = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		brown = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		red = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		black = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		other = 7,
	}
	
	/// <summary>
	/// Properties indicating head pose of the face.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class HeadPose
	{
		
		[System.Runtime.Serialization.DataMember(Name="pitch")]
		public System.Nullable<System.Double> Pitch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="roll")]
		public System.Nullable<System.Double> Roll { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="yaw")]
		public System.Nullable<System.Double> Yaw { get; set; }
	}
	
	/// <summary>
	/// Properties describing present makeups on a given face.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Makeup
	{
		
		/// <summary>
		/// A boolean value describing whether eye makeup is present on a face.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeMakeup")]
		public System.Nullable<System.Boolean> EyeMakeup { get; set; }
		
		/// <summary>
		/// A boolean value describing whether lip makeup is present on a face.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lipMakeup")]
		public System.Nullable<System.Boolean> LipMakeup { get; set; }
	}
	
	/// <summary>
	/// Properties describing noise level of the image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Noise
	{
		
		/// <summary>
		/// An enum value indicating level of noise.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noiseLevel")]
		public BlurBlurLevel NoiseLevel { get; set; }
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating the intensity level associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> Value { get; set; }
	}
	
	/// <summary>
	/// Properties describing occlusions on a given face.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Occlusion
	{
		
		/// <summary>
		/// A boolean value indicating whether eyes are occluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeOccluded")]
		public System.Nullable<System.Boolean> EyeOccluded { get; set; }
		
		/// <summary>
		/// A boolean value indicating whether forehead is occluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="foreheadOccluded")]
		public System.Nullable<System.Boolean> ForeheadOccluded { get; set; }
		
		/// <summary>
		/// A boolean value indicating whether the mouth is occluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mouthOccluded")]
		public System.Nullable<System.Boolean> MouthOccluded { get; set; }
	}
	
	/// <summary>
	/// A collection of 27-point face landmarks pointing to the important positions of face components.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class FaceLandmarks
	{
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeLeftBottom")]
		public Coordinate EyeLeftBottom { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeLeftInner")]
		public Coordinate EyeLeftInner { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeLeftOuter")]
		public Coordinate EyeLeftOuter { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeLeftTop")]
		public Coordinate EyeLeftTop { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeRightBottom")]
		public Coordinate EyeRightBottom { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeRightInner")]
		public Coordinate EyeRightInner { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeRightOuter")]
		public Coordinate EyeRightOuter { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyeRightTop")]
		public Coordinate EyeRightTop { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyebrowLeftInner")]
		public Coordinate EyebrowLeftInner { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyebrowLeftOuter")]
		public Coordinate EyebrowLeftOuter { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyebrowRightInner")]
		public Coordinate EyebrowRightInner { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eyebrowRightOuter")]
		public Coordinate EyebrowRightOuter { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mouthLeft")]
		public Coordinate MouthLeft { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mouthRight")]
		public Coordinate MouthRight { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noseLeftAlarOutTip")]
		public Coordinate NoseLeftAlarOutTip { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noseLeftAlarTop")]
		public Coordinate NoseLeftAlarTop { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noseRightAlarOutTip")]
		public Coordinate NoseRightAlarOutTip { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noseRightAlarTop")]
		public Coordinate NoseRightAlarTop { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noseRootLeft")]
		public Coordinate NoseRootLeft { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noseRootRight")]
		public Coordinate NoseRootRight { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noseTip")]
		public Coordinate NoseTip { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pupilLeft")]
		public Coordinate PupilLeft { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pupilRight")]
		public Coordinate PupilRight { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="underLipBottom")]
		public Coordinate UnderLipBottom { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="underLipTop")]
		public Coordinate UnderLipTop { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upperLipBottom")]
		public Coordinate UpperLipBottom { get; set; }
		
		/// <summary>
		/// Coordinates within an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upperLipTop")]
		public Coordinate UpperLipTop { get; set; }
	}
	
	/// <summary>
	/// A rectangle within which a face can be found
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class FaceRectangle
	{
		
		/// <summary>
		/// The height of the rectangle, in pixels.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="height")]
		public int Height { get; set; }
		
		/// <summary>
		/// The distance from the left edge if the image to the left edge of the rectangle, in pixels.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="left")]
		public int Left { get; set; }
		
		/// <summary>
		/// The distance from the top edge if the image to the top edge of the rectangle, in pixels.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="top")]
		public int Top { get; set; }
		
		/// <summary>
		/// The width of the rectangle, in pixels.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="width")]
		public int Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum DetectedFaceRecognitionModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recognition_01 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recognition_02 = 1,
	}
	
	/// <summary>
	/// Face list object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class FaceList
	{
		
		/// <summary>
		/// FaceListId of the target face list.
		/// Required
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceListId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string FaceListId { get; set; }
		
		/// <summary>
		/// An array of persisted faces within the face list or large face list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistedFaces")]
		public PersistedFace[] PersistedFaces { get; set; }
	}
	
	/// <summary>
	/// PersonFace object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PersistedFace
	{
		
		/// <summary>
		/// The persistedFaceId of the target face, which is persisted and will not expire. Different from faceId created by Face - Detect and will expire in 24 hours after the detection call.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="persistedFaceId")]
		public string PersistedFaceId { get; set; }
		
		/// <summary>
		/// User-provided data attached to the face. The size limit is 1KB.
		/// Max length: 1024
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		public string UserData { get; set; }
	}
	
	/// <summary>
	/// Request body for find similar operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class FindSimilarRequest
	{
		
		/// <summary>
		/// FaceId of the query face. User needs to call Face - Detect first to get a valid faceId. Note that this faceId is not persisted and will expire 24 hours after the detection call
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceId")]
		public string FaceId { get; set; }
		
		/// <summary>
		/// An array of candidate faceIds. All of them are created by Face - Detect and the faceIds will expire 24 hours after the detection call. The number of faceIds is limited to 1000. Parameter faceListId, largeFaceListId and faceIds should not be provided at the same time.
		/// Maximum items: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="faceIds")]
		[System.ComponentModel.DataAnnotations.MaxLength(1000)]
		public string[] FaceIds { get; set; }
		
		/// <summary>
		/// An existing user-specified unique candidate face list, created in Face List - Create a Face List. Face list contains a set of persistedFaceIds which are persisted and will never expire. Parameter faceListId, largeFaceListId and faceIds should not be provided at the same time.
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="faceListId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string FaceListId { get; set; }
		
		/// <summary>
		/// An existing user-specified unique candidate large face list, created in LargeFaceList - Create. Large face list contains a set of persistedFaceIds which are persisted and will never expire. Parameter faceListId, largeFaceListId and faceIds should not be provided at the same time.
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="largeFaceListId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string LargeFaceListId { get; set; }
		
		/// <summary>
		/// The number of top similar faces returned. The valid range is [1, 1000].
		/// Minimum: 1
		/// Maximum: 1000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxNumOfCandidatesReturned")]
		[System.ComponentModel.DataAnnotations.Range(1, 1000)]
		public System.Nullable<System.Int32> MaxNumOfCandidatesReturned { get; set; }
		
		/// <summary>
		/// Similar face searching mode. It can be "matchPerson" or "matchFace".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<FindSimilarRequestMode> Mode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum FindSimilarRequestMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		matchPerson = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		matchFace = 1,
	}
	
	/// <summary>
	/// Request body for group request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class GroupRequest
	{
		
		/// <summary>
		/// Array of candidate faceId created by Face - Detect. The maximum is 1000 faces
		/// Required
		/// Maximum items: 1000
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceIds")]
		[System.ComponentModel.DataAnnotations.MaxLength(1000)]
		public string[] FaceIds { get; set; }
	}
	
	/// <summary>
	/// An array of face groups based on face similarity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class GroupResult
	{
		
		/// <summary>
		/// A partition of the original faces based on face similarity. Groups are ranked by number of faces
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public string[] Groups { get; set; }
		
		/// <summary>
		/// Face ids array of faces that cannot find any similar faces from original faces.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messyGroup")]
		public string[] MessyGroup { get; set; }
	}
	
	/// <summary>
	/// All possible faces that may qualify.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class IdentifyCandidate
	{
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Required
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="confidence")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public double Confidence { get; set; }
		
		/// <summary>
		/// Id of candidate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="personId")]
		public string PersonId { get; set; }
	}
	
	/// <summary>
	/// Request body for identify face operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class IdentifyRequest
	{
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceThreshold")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceThreshold { get; set; }
		
		/// <summary>
		/// Array of query faces faceIds, created by the Face - Detect. Each of the faces are identified independently. The valid number of faceIds is between [1, 10].
		/// Required
		/// Maximum items: 10
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceIds")]
		[System.ComponentModel.DataAnnotations.MaxLength(10)]
		public string[] FaceIds { get; set; }
		
		/// <summary>
		/// LargePersonGroupId of the target large person group, created by LargePersonGroup - Create. Parameter personGroupId and largePersonGroupId should not be provided at the same time.
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="largePersonGroupId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string LargePersonGroupId { get; set; }
		
		/// <summary>
		/// The range of maxNumOfCandidatesReturned is between 1 and 5 (default is 1).
		/// Minimum: 1
		/// Maximum: 5
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxNumOfCandidatesReturned")]
		[System.ComponentModel.DataAnnotations.Range(1, 5)]
		public System.Nullable<System.Int32> MaxNumOfCandidatesReturned { get; set; }
		
		/// <summary>
		/// PersonGroupId of the target person group, created by PersonGroup - Create. Parameter personGroupId and largePersonGroupId should not be provided at the same time.
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="personGroupId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string PersonGroupId { get; set; }
	}
	
	/// <summary>
	/// Response body for identify face operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class IdentifyResult
	{
		
		/// <summary>
		/// Identified person candidates for that face (ranked by confidence). Array size should be no larger than input maxNumOfCandidatesReturned. If no person is identified, will return an empty array.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="candidates")]
		public IdentifyCandidate[] Candidates { get; set; }
		
		/// <summary>
		/// FaceId of the query face
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceId")]
		public string FaceId { get; set; }
	}
	
	/// <summary>
	/// Large face list object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class LargeFaceList
	{
		
		/// <summary>
		/// LargeFaceListId of the target large face list.
		/// Required
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="largeFaceListId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string LargeFaceListId { get; set; }
	}
	
	/// <summary>
	/// Large person group object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class LargePersonGroup
	{
		
		/// <summary>
		/// LargePersonGroupId of the target large person groups
		/// Required
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="largePersonGroupId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string LargePersonGroupId { get; set; }
	}
	
	/// <summary>
	/// A combination of user defined name and user specified data and recognition model name for largePersonGroup/personGroup, and largeFaceList/faceList.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class MetaDataContract
	{
		
		/// <summary>
		/// Name of recognition model. Recognition model is used when the face features are extracted and associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A recognition model name can be provided when performing Face - Detect or (Large)FaceList - Create or (Large)PersonGroup - Create. The default value is 'recognition_01', if latest model needed, please explicitly specify the model you need.
		/// </summary>
		[System.ComponentModel.DefaultValue(DetectedFaceRecognitionModel.recognition_01)]
		[System.Runtime.Serialization.DataMember(Name="recognitionModel")]
		public DetectedFaceRecognitionModel RecognitionModel { get; set; } = DetectedFaceRecognitionModel.recognition_01;
	}
	
	/// <summary>
	/// A combination of user defined name and user specified data for the person, largePersonGroup/personGroup, and largeFaceList/faceList.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class NameAndUserDataContract
	{
		
		/// <summary>
		/// User defined name, maximum length is 128.
		/// Max length: 128
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		public string Name { get; set; }
		
		/// <summary>
		/// User specified data. Length should not exceed 16KB.
		/// Max length: 16384
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		[System.ComponentModel.DataAnnotations.MaxLength(16384)]
		public string UserData { get; set; }
	}
	
	/// <summary>
	/// Operation status object. Operation refers to the asynchronous backend task including taking a snapshot and applying a snapshot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class OperationStatus
	{
		
		/// <summary>
		/// A combined UTC date and time string that describes the time when the operation (take or apply a snapshot) is requested. E.g. 2018-12-25T11:41:02.2331413Z.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdTime")]
		public System.DateTimeOffset CreatedTime { get; set; }
		
		/// <summary>
		/// A combined UTC date and time string that describes the last time the operation (take or apply a snapshot) is actively migrating data. The lastActionTime will keep increasing until the operation finishes. E.g. 2018-12-25T11:51:27.8705696Z.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastActionTime")]
		public System.Nullable<System.DateTimeOffset> LastActionTime { get; set; }
		
		/// <summary>
		/// Show failure message when operation fails (omitted when operation succeeds).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// When the operation succeeds successfully, for snapshot taking operation the snapshot id will be included in this field, and for snapshot applying operation, the path to get the target object will be returned in this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceLocation")]
		public string ResourceLocation { get; set; }
		
		/// <summary>
		/// Operation status: notstarted, running, succeeded, failed. If the operation is requested and waiting to perform, the status is notstarted. If the operation is ongoing in backend, the status is running. Status succeeded means the operation is completed successfully, specifically for snapshot taking operation, it illustrates the snapshot is well taken and ready to apply, and for snapshot applying operation, it presents the target object has finished creating by the snapshot and ready to be used. Status failed is often caused by editing the source object while taking the snapshot or editing the target object while applying the snapshot before completion, see the field "message" to check the failure reason.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public OperationStatusStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum OperationStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		notstarted = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		succeeded = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
	}
	
	/// <summary>
	/// Person object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Person
	{
		
		/// <summary>
		/// PersistedFaceIds of registered faces in the person. These persistedFaceIds are returned from Person - Add a Person Face, and will not expire.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistedFaceIds")]
		public string[] PersistedFaceIds { get; set; }
		
		/// <summary>
		/// PersonId of the target face list.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="personId")]
		public string PersonId { get; set; }
	}
	
	/// <summary>
	/// Person group object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class PersonGroup
	{
		
		/// <summary>
		/// PersonGroupId of the target person group.
		/// Required
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="personGroupId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string PersonGroupId { get; set; }
	}
	
	/// <summary>
	/// Name of recognition model. Recognition model is used when the face features are extracted and associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A recognition model name can be provided when performing Face - Detect or (Large)FaceList - Create or (Large)PersonGroup - Create. The default value is 'recognition_01', if latest model needed, please explicitly specify the model you need.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum RecognitionModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recognition_01 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recognition_02 = 1,
	}
	
	/// <summary>
	/// Response body for find similar face operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class SimilarFace
	{
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Required
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="confidence")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public double Confidence { get; set; }
		
		/// <summary>
		/// FaceId of candidate face when find by faceIds. faceId is created by Face - Detect and will expire 24 hours after the detection call
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="faceId")]
		public string FaceId { get; set; }
		
		/// <summary>
		/// PersistedFaceId of candidate face when find by faceListId. persistedFaceId in face list is persisted and will not expire. As showed in below response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistedFaceId")]
		public string PersistedFaceId { get; set; }
	}
	
	/// <summary>
	/// Snapshot object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class Snapshot
	{
		
		/// <summary>
		/// Azure Cognitive Service Face account id of the subscriber who created the snapshot by Snapshot - Take.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="account")]
		public string Account { get; set; }
		
		/// <summary>
		/// Array of the target Face subscription ids for the snapshot, specified by the user who created the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="applyScope")]
		public String[] ApplyScope { get; set; }
		
		/// <summary>
		/// A combined UTC date and time string that describes the created time of the snapshot. E.g. 2018-12-25T11:41:02.2331413Z.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdTime")]
		public System.DateTimeOffset CreatedTime { get; set; }
		
		/// <summary>
		/// Snapshot id.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A combined UTC date and time string that describes the last time when the snapshot was created or updated by Snapshot - Update. E.g. 2018-12-25T11:51:27.8705696Z.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdateTime")]
		public System.DateTimeOffset LastUpdateTime { get; set; }
		
		/// <summary>
		/// Type of the source object in the snapshot, specified by the subscriber who created the snapshot when calling Snapshot - Take. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public SnapshotType Type { get; set; }
		
		/// <summary>
		/// User specified data about the snapshot for any purpose. Length should not exceed 16KB.
		/// Max length: 16384
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		[System.ComponentModel.DataAnnotations.MaxLength(16384)]
		public string UserData { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum SnapshotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FaceList = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LargeFaceList = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LargePersonGroup = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PersonGroup = 3,
	}
	
	/// <summary>
	/// Request body for taking snapshot operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class TakeSnapshotRequest
	{
		
		/// <summary>
		/// Array of the target Face subscription ids for the snapshot, specified by the user who created the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="applyScope")]
		public String[] ApplyScope { get; set; }
		
		/// <summary>
		/// User specified source object id to take snapshot from.
		/// Required
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="objectId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string ObjectId { get; set; }
		
		/// <summary>
		/// User specified type for the source object to take snapshot from. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public SnapshotType Type { get; set; }
		
		/// <summary>
		/// User specified data about the snapshot for any purpose. Length should not exceed 16KB.
		/// Max length: 16384
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		[System.ComponentModel.DataAnnotations.MaxLength(16384)]
		public string UserData { get; set; }
	}
	
	/// <summary>
	/// Training status object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class TrainingStatus
	{
		
		/// <summary>
		/// A combined UTC date and time string that describes the created time of the person group, large person group or large face list.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdDateTime")]
		public System.DateTimeOffset CreatedDateTime { get; set; }
		
		/// <summary>
		/// A combined UTC date and time string that describes the last modify time of the person group, large person group or large face list, could be null value when the group is not successfully trained.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastActionDateTime")]
		public System.Nullable<System.DateTimeOffset> LastActionDateTime { get; set; }
		
		/// <summary>
		/// A combined UTC date and time string that describes the last successful training time of the person group, large person group or large face list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSuccessfulTrainingDateTime")]
		public System.Nullable<System.DateTimeOffset> LastSuccessfulTrainingDateTime { get; set; }
		
		/// <summary>
		/// Show failure message when training failed (omitted when training succeed).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Training status: notstarted, running, succeeded, failed. If the training process is waiting to perform, the status is notstarted. If the training is ongoing, the status is running. Status succeed means this person group or large person group is ready for Face - Identify, or this large face list is ready for Face - Find Similar. Status failed is often caused by no person or no persisted face exist in the person group or large person group, or no persisted face exist in the large face list.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public TrainingStatusStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public enum TrainingStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		nonstarted = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		succeeded = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
	}
	
	/// <summary>
	/// Request to update face data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UpdateFaceRequest
	{
		
		/// <summary>
		/// User-provided data attached to the face. The size limit is 1KB.
		/// Max length: 1024
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		public string UserData { get; set; }
	}
	
	/// <summary>
	/// Request body for updating a snapshot, with a combination of user defined apply scope and user specified data.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class UpdateSnapshotRequest
	{
		
		/// <summary>
		/// Array of the target Face subscription ids for the snapshot, specified by the user who created the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applyScope")]
		public String[] ApplyScope { get; set; }
		
		/// <summary>
		/// User specified data about the snapshot for any purpose. Length should not exceed 16KB.
		/// Max length: 16384
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userData")]
		[System.ComponentModel.DataAnnotations.MaxLength(16384)]
		public string UserData { get; set; }
	}
	
	/// <summary>
	/// Request body for face to face verification.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VerifyFaceToFaceRequest
	{
		
		/// <summary>
		/// FaceId of the first face, comes from Face - Detect
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceId1")]
		public string FaceId1 { get; set; }
		
		/// <summary>
		/// FaceId of the second face, comes from Face - Detect
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceId2")]
		public string FaceId2 { get; set; }
	}
	
	/// <summary>
	/// Request body for face to person verification.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VerifyFaceToPersonRequest
	{
		
		/// <summary>
		/// FaceId of the face, comes from Face - Detect
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="faceId")]
		public string FaceId { get; set; }
		
		/// <summary>
		/// Using existing largePersonGroupId and personId for fast loading a specified person. largePersonGroupId is created in LargePersonGroup - Create. Parameter personGroupId and largePersonGroupId should not be provided at the same time.
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="largePersonGroupId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string LargePersonGroupId { get; set; }
		
		/// <summary>
		/// Using existing personGroupId and personId for fast loading a specified person. personGroupId is created in PersonGroup - Create. Parameter personGroupId and largePersonGroupId should not be provided at the same time.
		/// Max length: 64
		/// Pattern: ^[a-z0-9-_]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="personGroupId")]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-z0-9-_]+$")]
		public string PersonGroupId { get; set; }
		
		/// <summary>
		/// Specify a certain person in a person group or a large person group. personId is created in PersonGroup Person - Create or LargePersonGroup Person - Create.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="personId")]
		public string PersonId { get; set; }
	}
	
	/// <summary>
	/// Result of the verify operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/01")]
	public class VerifyResult
	{
		
		/// <summary>
		/// A number ranging from 0 to 1 indicating a level of confidence associated with a property.
		/// Required
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="confidence")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public double Confidence { get; set; }
		
		/// <summary>
		/// True if the two faces belong to the same person or the face belongs to the person, otherwise false.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isIdentical")]
		public bool IsIdentical { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks, and attributes.<br />
		/// * No image will be stored. Only the extracted face feature will be stored on server. The faceId is an identifier of the face feature and will be used in [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239), [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a), and [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). The stored face feature(s) will expire and be deleted 24 hours after the original detection call.
		/// * Optional parameters include faceId, landmarks, and attributes. Attributes include age, gender, headPose, smile, facialHair, glasses, emotion, hair, makeup, occlusion, accessories, blur, exposure and noise. Some of the results returned for specific attributes may not be highly accurate.
		/// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
		/// * Up to 100 faces can be returned for an image. Faces are ranked by face rectangle size from large to small.
		/// * For optimal results when querying [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239), [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a), and [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237) ('returnFaceId' is true), please use faces that are: frontal, clear, and with a minimum size of 200x200 pixels (100 pixels between eyes).
		/// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
		/// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
		/// | Model | Recommended use-case(s) |
		/// | ---------- | -------- |
		/// | 'detection_01': | The default detection model for [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
		/// | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
		/// 
		/// * Different 'recognitionModel' values are provided. If follow-up operations like Verify, Identify, Find Similar are needed, please specify the recognition model with 'recognitionModel' parameter. The default value for 'recognitionModel' is 'recognition_01', if latest model needed, please explicitly specify the model you need in this parameter. Once specified, the detected faceIds will be associated with the specified recognition model. More details, please refer to [How to specify a recognition model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-recognition-model)
		/// | Model | Recommended use-case(s) |
		/// | ---------- | -------- |
		/// | 'recognition_01': | The default recognition model for [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236). All those faceIds created before 2019 March are bonded with this recognition model. |
		/// | 'recognition_02': | Recognition model released in 2019 March. 'recognition_02' is recommended since its overall accuracy is improved compared with 'recognition_01'. |
		/// Face_DetectWithUrl detect
		/// </summary>
		/// <param name="returnFaceId">A value indicating whether the operation should return faceIds of detected faces.</param>
		/// <param name="returnFaceLandmarks">A value indicating whether the operation should return landmarks of the detected faces.</param>
		/// <param name="returnFaceAttributes">Analyze and return the one or more specified face attributes in the comma-separated string like "returnFaceAttributes=age,gender". Supported face attributes include age, gender, headPose, smile, facialHair, glasses and emotion. Note that each face attribute analysis has additional computational and time cost.</param>
		/// <param name="recognitionModel">Name of recognition model. Recognition model is used when the face features are extracted and associated with detected faceIds, (Large)FaceList or (Large)PersonGroup. A recognition model name can be provided when performing Face - Detect or (Large)FaceList - Create or (Large)PersonGroup - Create. The default value is 'recognition_01', if latest model needed, please explicitly specify the model you need.</param>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <param name="detectionModel">Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it.</param>
		/// <param name="requestBody">A JSON document with a URL pointing to the image that is to be analyzed.</param>
		/// <returns>A successful call returns an array of face entries ranked by face rectangle size in descending order. An empty response indicates no faces detected.</returns>
		public async Task<DetectedFace[]> Face_DetectWithUrlAsync(bool returnFaceId, bool returnFaceLandmarks, string[] returnFaceAttributes, DetectedFaceRecognitionModel recognitionModel, bool returnRecognitionModel, Face_DetectWithUrlDetectionModel detectionModel, Face_DetectWithUrlPostBody requestBody)
		{
			var requestUri = "detect?returnFaceId="+returnFaceId+"&returnFaceLandmarks="+returnFaceLandmarks+"&"+string.Join("&", returnFaceAttributes.Select(z => $"returnFaceAttributes={System.Uri.EscapeDataString(z.ToString())}"))+"&recognitionModel=" + recognitionModel+"&returnRecognitionModel="+returnRecognitionModel+"&detectionModel=" + detectionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DetectedFace[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List face lists faceListId, name, userData and recognitionModel. <br />
		/// To get face information inside faceList use [FaceList - Get](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524c)
		/// 
		/// FaceList_List facelists
		/// </summary>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <returns>A successful call returns an array of faceList.</returns>
		public async Task<FaceList[]> FaceList_ListAsync(bool returnRecognitionModel)
		{
			var requestUri = "facelists?returnRecognitionModel="+returnRecognitionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FaceList[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a face lists faceListId, name, userData, recognitionModel and faces in the face list.
		/// 
		/// FaceList_Get facelists/{faceListId}
		/// </summary>
		/// <param name="faceListId">Id referencing a particular face list.</param>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <returns>A successful call returns the face list's information.</returns>
		public async Task<FaceList> FaceList_GetAsync(string faceListId, bool returnRecognitionModel)
		{
			var requestUri = "facelists/"+ (faceListId==null? "" : System.Uri.EscapeDataString(faceListId))+"&returnRecognitionModel="+returnRecognitionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FaceList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an empty face list with user-specified faceListId, name, an optional userData and recognitionModel. Up to 64 face lists are allowed in one subscription.
		/// <br /> Face list is a list of faces, up to 1,000 faces, and used by [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
		/// <br /> After creation, user should use [FaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250) to import the faces. No image will be stored. Only the extracted face features are stored on server until [FaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f) is called.
		/// <br /> Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244) / [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d) and [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
		/// <br /> Please consider [LargeFaceList](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc) when the face number is large. It can support up to 1,000,000 faces.
		/// <br />'recognitionModel' should be specified to associate with this face list. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing face list will use the recognition model that's already associated with the collection. Existing face features in a face list can't be updated to features extracted by another version of recognition model.
		/// * 'recognition_01': The default recognition model for [FaceList- Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b). All those face lists created before 2019 March are bonded with this recognition model.
		/// * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since itsoverall accuracy is improved compared with 'recognition_01'.
		/// FaceList_Create facelists/{faceListId}
		/// </summary>
		/// <param name="faceListId">Id referencing a particular face list.</param>
		/// <param name="requestBody">Request body for creating a face list.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task FaceList_CreateAsync(string faceListId, MetaDataContract requestBody)
		{
			var requestUri = "facelists/"+ (faceListId==null? "" : System.Uri.EscapeDataString(faceListId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a specified face list.
		/// FaceList_Delete facelists/{faceListId}
		/// </summary>
		/// <param name="faceListId">Id referencing a particular face list.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task FaceList_DeleteAsync(string faceListId)
		{
			var requestUri = "facelists/"+ (faceListId==null? "" : System.Uri.EscapeDataString(faceListId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update information of a face list.
		/// FaceList_Update facelists/{faceListId}
		/// </summary>
		/// <param name="faceListId">Id referencing a particular face list.</param>
		/// <param name="requestBody">Request body for updating a face list.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task FaceList_UpdateAsync(string faceListId, NameAndUserDataContract requestBody)
		{
			var requestUri = "facelists/"+ (faceListId==null? "" : System.Uri.EscapeDataString(faceListId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add a face to a specified face list, up to 1,000 faces.
		/// <br /> To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [FaceList - Delete Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395251) or [FaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f) is called.
		/// <br /> Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
		/// * Higher face image quality means better detection and recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
		/// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
		/// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), theres no guarantee to detect and add the face successfully.
		/// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
		/// * Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel.
		/// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
		/// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
		/// | Model | Recommended use-case(s) |
		/// | ---------- | -------- |
		/// | 'detection_01': | The default detection model for [FaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
		/// | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
		/// FaceList_AddFaceFromUrl facelists/{faceListId}/persistedfaces
		/// </summary>
		/// <param name="faceListId">Id referencing a particular face list.</param>
		/// <param name="userData">User-specified data about the face for any purpose. The maximum length is 1KB.</param>
		/// <param name="targetFace">A face rectangle to specify the target face to be added to a person in the format of "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.</param>
		/// <param name="detectionModel">Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it.</param>
		/// <param name="requestBody">A JSON document with a URL pointing to the image that is to be analyzed.</param>
		/// <returns>A successful call returns a new persistedFaceId.</returns>
		public async Task<PersistedFace> FaceList_AddFaceFromUrlAsync(string faceListId, string userData, int[] targetFace, Face_DetectWithUrlDetectionModel detectionModel, FaceList_AddFaceFromUrlPostBody requestBody)
		{
			var requestUri = "facelists/"+ (faceListId==null? "" : System.Uri.EscapeDataString(faceListId))+"/persistedfaces&userData=" + (userData==null? "" : System.Uri.EscapeDataString(userData))+"&"+string.Join("&", targetFace.Select(z => $"targetFace={z}"))+"&detectionModel=" + detectionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersistedFace>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a face from a face list by specified faceListId and persistedFaceId.
		/// <br /> Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel.
		/// FaceList_DeleteFace facelists/{faceListId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="faceListId">Id referencing a particular face list.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task FaceList_DeleteFaceAsync(string faceListId, string persistedFaceId)
		{
			var requestUri = "facelists/"+ (faceListId==null? "" : System.Uri.EscapeDataString(faceListId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given query face's faceId, to search the similar-looking faces from a faceId array, a face list or a large face list. faceId array contains the faces created by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), which will expire 24 hours after creation. A "faceListId" is created by [FaceList - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b) containing persistedFaceIds that will not expire. And a "largeFaceListId" is created by [LargeFaceList - Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc) containing persistedFaceIds that will also not expire. Depending on the input the returned similar faces list contains faceIds or persistedFaceIds ranked by similarity.
		/// <br/>Find similar has two working modes, "matchPerson" and "matchFace". "matchPerson" is the default mode that it tries to find faces of the same person as possible by using internal same-person thresholds. It is useful to find a known person's other photos. Note that an empty list will be returned if no faces pass the internal thresholds. "matchFace" mode ignores same-person thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used in the cases like searching celebrity-looking faces.
		/// <br/>The 'recognitionModel' associated with the query face's faceId should be the same as the 'recognitionModel' used by the target faceId array, face list or large face list.
		/// 
		/// Face_FindSimilar findsimilars
		/// </summary>
		/// <param name="requestBody">Request body for Find Similar.</param>
		/// <returns>A successful call returns an array of the most similar faces represented in faceId if the input parameter is faceIds or persistedFaceId if the input parameter is faceListId.</returns>
		public async Task<SimilarFace[]> Face_FindSimilarAsync(FindSimilarRequest requestBody)
		{
			var requestUri = "findsimilars";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SimilarFace[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Divide candidate faces into groups based on face similarity.<br />
		/// * The output is one or more disjointed face groups and a messyGroup. A face group contains faces that have similar looking, often of the same person. Face groups are ranked by group size, i.e. number of faces. Notice that faces belonging to a same person might be split into several groups in the result.
		/// * MessyGroup is a special face group containing faces that cannot find any similar counterpart face from original faces. The messyGroup will not appear in the result if all faces found their counterparts.
		/// * Group API needs at least 2 candidate faces and 1000 at most. We suggest to try [Face - Verify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a) when you only have 2 candidate faces.
		/// * The 'recognitionModel' associated with the query faces' faceIds should be the same.
		/// 
		/// Face_Group group
		/// </summary>
		/// <param name="requestBody">Request body for grouping.</param>
		/// <returns>A successful call returns one or more groups of similar faces (rank by group size) and a messyGroup.</returns>
		public async Task<GroupResult> Face_GroupAsync(GroupRequest requestBody)
		{
			var requestUri = "group";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GroupResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 1-to-many identification to find the closest matches of the specific query person face from a person group or large person group.
		/// <br/> For each face in the faceIds array, Face Identify will compute similarities between the query face and all the faces in the person group (given by personGroupId) or large person group (given by largePersonGroupId), and return candidate person(s) for that face ranked by similarity confidence. The person group/large person group should be trained to make it ready for identification. See more in [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) and [LargePersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4).
		/// <br/>
		/// 
		/// Remarks:<br />
		/// * The algorithm allows more than one face to be identified independently at the same request, but no more than 10 faces.
		/// * Each person in the person group/large person group could have more than one face, but no more than 248 faces.
		/// * Higher face image quality means better identification precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
		/// * Number of candidates returned is restricted by maxNumOfCandidatesReturned and confidenceThreshold. If no person is identified, the returned candidates will be an empty array.
		/// * Try [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237) when you need to find similar faces from a face list/large face list instead of a person group/large person group.
		/// * The 'recognitionModel' associated with the query faces' faceIds should be the same as the 'recognitionModel' used by the target person group or large person group.
		/// 
		/// Face_Identify identify
		/// </summary>
		/// <param name="requestBody">Request body for identify operation.</param>
		/// <returns>A successful call returns the identified candidate person(s) for each query face.</returns>
		public async Task<IdentifyResult[]> Face_IdentifyAsync(IdentifyRequest requestBody)
		{
			var requestUri = "identify";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentifyResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List large face lists information of largeFaceListId, name, userData and recognitionModel. <br />
		/// To get face information inside largeFaceList use [LargeFaceList Face - Get](/docs/services/563879b61984550e40cbbe8d/operations/5a158cf2d2de3616c086f2d5)<br />
		/// * Large face lists are stored in alphabetical order of largeFaceListId.
		/// * "start" parameter (string, optional) is a user-provided largeFaceListId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
		/// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
		/// <br />
		/// For example, total 5 large person lists: "list1", ..., "list5".
		/// <br /> "start=&top=" will return all 5 lists.
		/// <br /> "start=&top=2" will return "list1", "list2".
		/// <br /> "start=list2&top=3" will return "list3", "list4", "list5".
		/// 
		/// LargeFaceList_List largefacelists
		/// </summary>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <returns>A successful call returns an array of largeFaceList.</returns>
		public async Task<LargeFaceList[]> LargeFaceList_ListAsync(bool returnRecognitionModel)
		{
			var requestUri = "largefacelists?returnRecognitionModel="+returnRecognitionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LargeFaceList[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a large face lists largeFaceListId, name, userData and recognitionModel.
		/// LargeFaceList_Get largefacelists/{largeFaceListId}
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <returns>A successful call returns the large face list's information.</returns>
		public async Task<LargeFaceList> LargeFaceList_GetAsync(string largeFaceListId, bool returnRecognitionModel)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId))+"&returnRecognitionModel="+returnRecognitionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LargeFaceList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an empty large face list with user-specified largeFaceListId, name, an optional userData and recognitionModel.
		/// <br /> Large face list is a list of faces, up to 1,000,000 faces, and used by [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237).
		/// <br /> After creation, user should use [LargeFaceList Face - Add](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3) to import the faces and [LargeFaceList - Train](/docs/services/563879b61984550e40cbbe8d/operations/5a158422d2de3616c086f2d1) to make it ready for [Face - Find Similar](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237). No image will be stored. Only the extracted face features are stored on server until [LargeFaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd) is called.
		/// <br /> Find Similar is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use [PersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244) / [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d) and [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
		/// <br/>'recognitionModel' should be specified to associate with this large face list. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large face list will use the recognition model that's already associated with the collection. Existing face features in a large face list can't be updated to features extracted by another version of recognition model.
		/// * 'recognition_01': The default recognition model for [LargeFaceList- Create](/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc). All those large face lists created before 2019 March are bonded with this recognition model.
		/// * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since itsoverall accuracy is improved compared with 'recognition_01'.
		/// 
		/// Large face list quota:
		/// * Free-tier subscription quota: 64 large face lists.
		/// * S0-tier subscription quota: 1,000,000 large face lists.
		/// LargeFaceList_Create largefacelists/{largeFaceListId}
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <param name="requestBody">Request body for creating a large face list.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargeFaceList_CreateAsync(string largeFaceListId, MetaDataContract requestBody)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a specified large face list.
		/// LargeFaceList_Delete largefacelists/{largeFaceListId}
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargeFaceList_DeleteAsync(string largeFaceListId)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update information of a large face list.
		/// LargeFaceList_Update largefacelists/{largeFaceListId}
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <param name="requestBody">Request body for updating a large face list.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargeFaceList_UpdateAsync(string largeFaceListId, NameAndUserDataContract requestBody)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List all faces in a large face list, and retrieve face information (including userData and persistedFaceIds of registered faces of the face).
		/// LargeFaceList_ListFaces largefacelists/{largeFaceListId}/persistedfaces
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <param name="start">Starting face id to return (used to list a range of faces).</param>
		/// <param name="top">Number of faces to return starting with the face id indicated by the 'start' parameter.</param>
		/// <returns>A successful call returns an array of face information that belong to the large face list.</returns>
		public async Task<PersistedFace[]> LargeFaceList_ListFacesAsync(string largeFaceListId, string start, int top)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId))+"/persistedfaces&start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&top="+top;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersistedFace[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a face to a specified large face list, up to 1,000,000 faces.
		/// <br /> To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargeFaceList Face - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a158c8ad2de3616c086f2d4) or [LargeFaceList - Delete](/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd) is called.
		/// <br /> Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
		/// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
		/// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
		/// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), theres no guarantee to detect and add the face successfully.
		/// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
		/// * Adding/deleting faces to/from a same face list are processed sequentially and to/from different face lists are in parallel.
		/// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
		/// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
		/// | Model | Recommended use-case(s) |
		/// | ---------- | -------- |
		/// | 'detection_01': | The default detection model for [LargeFaceList - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
		/// | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
		/// 
		/// Quota:
		/// * Free-tier subscription quota: 1,000 faces per large face list.
		/// * S0-tier subscription quota: 1,000,000 faces per large face list.
		/// LargeFaceList_AddFaceFromUrl largefacelists/{largeFaceListId}/persistedfaces
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <param name="userData">User-specified data about the face for any purpose. The maximum length is 1KB.</param>
		/// <param name="targetFace">A face rectangle to specify the target face to be added to a person in the format of "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.</param>
		/// <param name="detectionModel">Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it.</param>
		/// <param name="requestBody">A JSON document with a URL pointing to the image that is to be analyzed.</param>
		/// <returns>A successful call returns a new persistedFaceId.</returns>
		public async Task<PersistedFace> LargeFaceList_AddFaceFromUrlAsync(string largeFaceListId, string userData, int[] targetFace, Face_DetectWithUrlDetectionModel detectionModel, LargeFaceList_AddFaceFromUrlPostBody requestBody)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId))+"/persistedfaces&userData=" + (userData==null? "" : System.Uri.EscapeDataString(userData))+"&"+string.Join("&", targetFace.Select(z => $"targetFace={z}"))+"&detectionModel=" + detectionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersistedFace>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a persisted face (specified by persistedFaceId and its belonging largeFaceListId).
		/// LargeFaceList_GetFace largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <returns>A successful call returns target persisted face's information (persistedFaceId and userData).</returns>
		public async Task<PersistedFace> LargeFaceList_GetFaceAsync(string largeFaceListId, string persistedFaceId)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersistedFace>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a face from a large face list by specified largeFaceListId and persistedFaceId.
		/// <br /> Adding/deleting faces to/from a same large face list are processed sequentially and to/from different large face lists are in parallel.
		/// LargeFaceList_DeleteFace largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargeFaceList_DeleteFaceAsync(string largeFaceListId, string persistedFaceId)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a persisted face's userData field.
		/// LargeFaceList_UpdateFace largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <param name="requestBody">Request body for updating persisted face.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargeFaceList_UpdateFaceAsync(string largeFaceListId, string persistedFaceId, UpdateFaceRequest requestBody)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Queue a large face list training task, the training task may not be started immediately.
		/// LargeFaceList_Train largefacelists/{largeFaceListId}/train
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		public async Task LargeFaceList_TrainAsync(string largeFaceListId)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId))+"/train";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the training status of a large face list (completed or ongoing).
		/// LargeFaceList_GetTrainingStatus largefacelists/{largeFaceListId}/training
		/// </summary>
		/// <param name="largeFaceListId">Id referencing a particular large face list.</param>
		/// <returns>A successful call returns the large face list's training status.</returns>
		public async Task<TrainingStatus> LargeFaceList_GetTrainingStatusAsync(string largeFaceListId)
		{
			var requestUri = "largefacelists/"+ (largeFaceListId==null? "" : System.Uri.EscapeDataString(largeFaceListId))+"/training";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrainingStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all existing large person groups largePersonGroupId, name, userData and recognitionModel.<br />
		/// * Large person groups are stored in alphabetical order of largePersonGroupId.
		/// * "start" parameter (string, optional) is a user-provided largePersonGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
		/// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
		/// <br />
		/// For example, total 5 large person groups: "group1", ..., "group5".
		/// <br /> "start=&top=" will return all 5 groups.
		/// <br /> "start=&top=2" will return "group1", "group2".
		/// <br /> "start=group2&top=3" will return "group3", "group4", "group5".
		/// 
		/// LargePersonGroup_List largepersongroups
		/// </summary>
		/// <param name="start">List large person groups from the least largePersonGroupId greater than the "start".</param>
		/// <param name="top">The number of large person groups to list.</param>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <returns>A successful call returns an array of large person groups and their information.</returns>
		public async Task<LargePersonGroup[]> LargePersonGroup_ListAsync(string start, int top, bool returnRecognitionModel)
		{
			var requestUri = "largepersongroups?start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&top="+top+"&returnRecognitionModel="+returnRecognitionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LargePersonGroup[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the information of a large person group, including its name, userData and recognitionModel. This API returns large person group information only, use [LargePersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/599adda06ac60f11b48b5aa1) instead to retrieve person information under the large person group.
		/// 
		/// LargePersonGroup_Get largepersongroups/{largePersonGroupId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <returns>A successful call returns the large person group's information.</returns>
		public async Task<LargePersonGroup> LargePersonGroup_GetAsync(string largePersonGroupId, bool returnRecognitionModel)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"&returnRecognitionModel="+returnRecognitionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LargePersonGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new large person group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
		/// <br /> A large person group is the container of the uploaded person data, including face recognition feature, and up to 1,000,000
		/// people.
		/// <br /> After creation, use [LargePersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40) to add person into the group, and call [LargePersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
		/// <br /> No image will be stored. Only the person's extracted face features and userData will be stored on server until [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
		/// <br/>'recognitionModel' should be specified to associate with this large person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing large person group will use the recognition model that's already associated with the collection. Existing face features in a large person group can't be updated to features extracted by another version of recognition model.
		/// * 'recognition_01': The default recognition model for [LargePersonGroup - Create](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d). All those large person groups created before 2019 March are bonded with this recognition model.
		/// * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since itsoverall accuracy is improved compared with 'recognition_01'.
		/// 
		/// Large person group quota:
		/// * Free-tier subscription quota: 1,000 large person groups.
		/// * S0-tier subscription quota: 1,000,000 large person groups.
		/// LargePersonGroup_Create largepersongroups/{largePersonGroupId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="requestBody">Request body for creating new large person group.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargePersonGroup_CreateAsync(string largePersonGroupId, MetaDataContract requestBody)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an existing large person group. Persisted face features of all people in the large person group will also be deleted.
		/// LargePersonGroup_Delete largepersongroups/{largePersonGroupId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargePersonGroup_DeleteAsync(string largePersonGroupId)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing large person group's display name and userData. The properties which does not appear in request body will not be updated.
		/// LargePersonGroup_Update largepersongroups/{largePersonGroupId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="requestBody">Request body for updating large person group.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargePersonGroup_UpdateAsync(string largePersonGroupId, NameAndUserDataContract requestBody)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List all persons in a large person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
		/// LargePersonGroupPerson_List largepersongroups/{largePersonGroupId}/persons
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="start">Starting person id to return (used to list a range of persons).</param>
		/// <param name="top">Number of persons to return starting with the person id indicated by the 'start' parameter.</param>
		/// <returns>A successful call returns an array of person information that belong to the large person group.</returns>
		public async Task<Person[]> LargePersonGroupPerson_ListAsync(string largePersonGroupId, string start, int top)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons&start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&top="+top;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Person[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new person in a specified large person group.
		/// LargePersonGroupPerson_Create largepersongroups/{largePersonGroupId}/persons
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="requestBody">Request body for creating new person.</param>
		/// <returns>A successful call returns a new personId created.</returns>
		public async Task<Person> LargePersonGroupPerson_CreateAsync(string largePersonGroupId, NameAndUserDataContract requestBody)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Person>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature.
		/// LargePersonGroupPerson_Get largepersongroups/{largePersonGroupId}/persons/{personId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <returns>A successful call returns the person's information.</returns>
		public async Task<Person> LargePersonGroupPerson_GetAsync(string largePersonGroupId, string personId)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Person>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an existing person from a large person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
		/// LargePersonGroupPerson_Delete largepersongroups/{largePersonGroupId}/persons/{personId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargePersonGroupPerson_DeleteAsync(string largePersonGroupId, string personId)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update name or userData of a person.
		/// LargePersonGroupPerson_Update largepersongroups/{largePersonGroupId}/persons/{personId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="requestBody">Request body for person update operation.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargePersonGroupPerson_UpdateAsync(string largePersonGroupId, string personId, NameAndUserDataContract requestBody)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
		/// <br /> Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
		/// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
		/// * Each person entry can hold up to 248 faces.
		/// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
		/// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), theres no guarantee to detect and add the face successfully.
		/// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
		/// * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
		/// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
		/// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
		/// | Model | Recommended use-case(s) |
		/// | ---------- | -------- |
		/// | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
		/// | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
		/// LargePersonGroupPerson_AddFaceFromUrl largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="userData">User-specified data about the face for any purpose. The maximum length is 1KB.</param>
		/// <param name="targetFace">A face rectangle to specify the target face to be added to a person in the format of "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.</param>
		/// <param name="detectionModel">Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it.</param>
		/// <param name="requestBody">A JSON document with a URL pointing to the image that is to be analyzed.</param>
		/// <returns>A successful call returns the new persistedFaceId.</returns>
		public async Task<PersistedFace> LargePersonGroupPerson_AddFaceFromUrlAsync(string largePersonGroupId, string personId, string userData, int[] targetFace, Face_DetectWithUrlDetectionModel detectionModel, LargePersonGroupPerson_AddFaceFromUrlPostBody requestBody)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId))+"/persistedfaces&userData=" + (userData==null? "" : System.Uri.EscapeDataString(userData))+"&"+string.Join("&", targetFace.Select(z => $"targetFace={z}"))+"&detectionModel=" + detectionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersistedFace>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging largePersonGroupId).
		/// LargePersonGroupPerson_GetFace largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <returns>A successful call returns target persisted face's information (persistedFaceId and userData).</returns>
		public async Task<PersistedFace> LargePersonGroupPerson_GetFaceAsync(string largePersonGroupId, string personId, string persistedFaceId)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersistedFace>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a face from a person in a large person group by specified largePersonGroupId, personId and persistedFaceId.
		/// <br /> Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
		/// LargePersonGroupPerson_DeleteFace largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargePersonGroupPerson_DeleteFaceAsync(string largePersonGroupId, string personId, string persistedFaceId)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a person persisted face's userData field.
		/// LargePersonGroupPerson_UpdateFace largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <param name="requestBody">Request body for updating persisted face.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task LargePersonGroupPerson_UpdateFaceAsync(string largePersonGroupId, string personId, string persistedFaceId, UpdateFaceRequest requestBody)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Queue a large person group training task, the training task may not be started immediately.
		/// LargePersonGroup_Train largepersongroups/{largePersonGroupId}/train
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		public async Task LargePersonGroup_TrainAsync(string largePersonGroupId)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/train";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the training status of a large person group (completed or ongoing).
		/// LargePersonGroup_GetTrainingStatus largepersongroups/{largePersonGroupId}/training
		/// </summary>
		/// <param name="largePersonGroupId">Id referencing a particular large person group.</param>
		/// <returns>A successful call returns the large person group's training status.</returns>
		public async Task<TrainingStatus> LargePersonGroup_GetTrainingStatusAsync(string largePersonGroupId)
		{
			var requestUri = "largepersongroups/"+ (largePersonGroupId==null? "" : System.Uri.EscapeDataString(largePersonGroupId))+"/training";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrainingStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the status of a take/apply snapshot operation.
		/// Snapshot_GetOperationStatus operations/{operationId}
		/// </summary>
		/// <param name="operationId">Id referencing a particular take/apply snapshot operation.</param>
		/// <returns>A successful call returns the snapshot operation's status.</returns>
		public async Task<OperationStatus> Snapshot_GetOperationStatusAsync(string operationId)
		{
			var requestUri = "operations/"+ (operationId==null? "" : System.Uri.EscapeDataString(operationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OperationStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List person groups personGroupId, name, userData and recognitionModel.<br />
		/// * Person groups are stored in alphabetical order of personGroupId.
		/// * "start" parameter (string, optional) is a user-provided personGroupId value that returned entries have larger ids by string comparison. "start" set to empty to indicate return from the first item.
		/// * "top" parameter (int, optional) specifies the number of entries to return. A maximal of 1000 entries can be returned in one call. To fetch more, you can specify "start" with the last returned entrys Id of the current call.
		/// <br />
		/// For example, total 5 person groups: "group1", ..., "group5".
		/// <br /> "start=&top=" will return all 5 groups.
		/// <br /> "start=&top=2" will return "group1", "group2".
		/// <br /> "start=group2&top=3" will return "group3", "group4", "group5".
		/// 
		/// PersonGroup_List persongroups
		/// </summary>
		/// <param name="start">List person groups from the least personGroupId greater than the "start".</param>
		/// <param name="top">The number of person groups to list.</param>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <returns>A successful call returns an array of person groups and their information.</returns>
		public async Task<PersonGroup[]> PersonGroup_ListAsync(string start, int top, bool returnRecognitionModel)
		{
			var requestUri = "persongroups?start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&top="+top+"&returnRecognitionModel="+returnRecognitionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersonGroup[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve person group name, userData and recognitionModel. To get person information under this personGroup, use [PersonGroup Person - List](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241).
		/// PersonGroup_Get persongroups/{personGroupId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="returnRecognitionModel">A value indicating whether the operation should return 'recognitionModel' in response.</param>
		/// <returns>A successful call returns the person group's information.</returns>
		public async Task<PersonGroup> PersonGroup_GetAsync(string personGroupId, bool returnRecognitionModel)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"&returnRecognitionModel="+returnRecognitionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersonGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new person group with specified personGroupId, name, user-provided userData and recognitionModel.
		/// <br /> A person group is the container of the uploaded person data, including face recognition features.
		/// <br /> After creation, use [PersonGroup Person - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c) to add persons into the group, and then call [PersonGroup - Train](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249) to get this group ready for [Face - Identify](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239).
		/// <br /> No image will be stored. Only the person's extracted face features and userData will be stored on server until [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
		/// <br/>'recognitionModel' should be specified to associate with this person group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing person group will use the recognition model that's already associated with the collection. Existing face features in a person group can't be updated to features extracted by another version of recognition model.
		/// * 'recognition_01': The default recognition model for [PersonGroup - Create](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244). All those person groups created before 2019 March are bonded with this recognition model.
		/// * 'recognition_02': Recognition model released in 2019 March. 'recognition_02' is recommended since itsoverall accuracy is improved compared with 'recognition_01'.
		/// 
		/// Person group quota:
		/// * Free-tier subscription quota: 1,000 person groups. Each holds up to 1,000 persons.
		/// * S0-tier subscription quota: 1,000,000 person groups. Each holds up to 10,000 persons.
		/// * to handle larger scale face identification problem, please consider using [LargePersonGroup](/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d).
		/// PersonGroup_Create persongroups/{personGroupId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="requestBody">Request body for creating new person group.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task PersonGroup_CreateAsync(string personGroupId, MetaDataContract requestBody)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an existing person group. Persisted face features of all people in the person group will also be deleted.
		/// PersonGroup_Delete persongroups/{personGroupId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task PersonGroup_DeleteAsync(string personGroupId)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing person group's display name and userData. The properties which does not appear in request body will not be updated.
		/// PersonGroup_Update persongroups/{personGroupId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="requestBody">Request body for updating person group.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task PersonGroup_UpdateAsync(string personGroupId, NameAndUserDataContract requestBody)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List all persons in a person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
		/// PersonGroupPerson_List persongroups/{personGroupId}/persons
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="start">Starting person id to return (used to list a range of persons).</param>
		/// <param name="top">Number of persons to return starting with the person id indicated by the 'start' parameter.</param>
		/// <returns>A successful call returns an array of person information that belong to the person group.</returns>
		public async Task<Person[]> PersonGroupPerson_ListAsync(string personGroupId, string start, int top)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons&start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&top="+top;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Person[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new person in a specified person group.
		/// PersonGroupPerson_Create persongroups/{personGroupId}/persons
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="requestBody">Request body for creating new person.</param>
		/// <returns>A successful call returns a new personId created.</returns>
		public async Task<Person> PersonGroupPerson_CreateAsync(string personGroupId, NameAndUserDataContract requestBody)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Person>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve a person's information, including registered persisted faces, name and userData.
		/// PersonGroupPerson_Get persongroups/{personGroupId}/persons/{personId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <returns>A successful call returns the person's information.</returns>
		public async Task<Person> PersonGroupPerson_GetAsync(string personGroupId, string personId)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Person>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an existing person from a person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
		/// PersonGroupPerson_Delete persongroups/{personGroupId}/persons/{personId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task PersonGroupPerson_DeleteAsync(string personGroupId, string personId)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update name or userData of a person.
		/// PersonGroupPerson_Update persongroups/{personGroupId}/persons/{personId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="requestBody">Request body for person update operation.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task PersonGroupPerson_UpdateAsync(string personGroupId, string personId, NameAndUserDataContract requestBody)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add a face to a person into a person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [PersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e), [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
		/// <br /> Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
		/// *   Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
		/// *   Each person entry can hold up to 248 faces.
		/// *   JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
		/// *   "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), theres no guarantee to detect and add the face successfully.
		/// *   Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
		/// *   Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
		/// * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
		/// * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
		/// | Model | Recommended use-case(s) |
		/// | ---------- | -------- |
		/// | 'detection_01': | The default detection model for [PersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523b). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
		/// | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |
		/// PersonGroupPerson_AddFaceFromUrl persongroups/{personGroupId}/persons/{personId}/persistedfaces
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="userData">User-specified data about the face for any purpose. The maximum length is 1KB.</param>
		/// <param name="targetFace">A face rectangle to specify the target face to be added to a person in the format of "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.</param>
		/// <param name="detectionModel">Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it.</param>
		/// <param name="requestBody">A JSON document with a URL pointing to the image that is to be analyzed.</param>
		/// <returns>A successful call returns the new persistedFaceId.</returns>
		public async Task<PersistedFace> PersonGroupPerson_AddFaceFromUrlAsync(string personGroupId, string personId, string userData, int[] targetFace, Face_DetectWithUrlDetectionModel detectionModel, PersonGroupPerson_AddFaceFromUrlPostBody requestBody)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId))+"/persistedfaces&userData=" + (userData==null? "" : System.Uri.EscapeDataString(userData))+"&"+string.Join("&", targetFace.Select(z => $"targetFace={z}"))+"&detectionModel=" + detectionModel;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersistedFace>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging personGroupId).
		/// PersonGroupPerson_GetFace persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <returns>A successful call returns target persisted face's information (persistedFaceId and userData).</returns>
		public async Task<PersistedFace> PersonGroupPerson_GetFaceAsync(string personGroupId, string personId, string persistedFaceId)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PersistedFace>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a face from a person in a person group by specified personGroupId, personId and persistedFaceId.
		/// <br /> Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
		/// PersonGroupPerson_DeleteFace persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task PersonGroupPerson_DeleteFaceAsync(string personGroupId, string personId, string persistedFaceId)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a face to a person into a person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [PersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e), [PersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d) or [PersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245) is called.
		/// <br /> Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
		/// * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
		/// * Each person entry can hold up to 248 faces.
		/// * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
		/// * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), theres no guarantee to detect and add the face successfully.
		/// * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
		/// * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
		/// PersonGroupPerson_UpdateFace persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <param name="personId">Id referencing a particular person.</param>
		/// <param name="persistedFaceId">Id referencing a particular persistedFaceId of an existing face.</param>
		/// <param name="requestBody">Request body for updating persisted face.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task PersonGroupPerson_UpdateFaceAsync(string personGroupId, string personId, string persistedFaceId, UpdateFaceRequest requestBody)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/persons/"+ (personId==null? "" : System.Uri.EscapeDataString(personId))+"/persistedfaces/"+ (persistedFaceId==null? "" : System.Uri.EscapeDataString(persistedFaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Queue a person group training task, the training task may not be started immediately.
		/// PersonGroup_Train persongroups/{personGroupId}/train
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		public async Task PersonGroup_TrainAsync(string personGroupId)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/train";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the training status of a person group (completed or ongoing).
		/// PersonGroup_GetTrainingStatus persongroups/{personGroupId}/training
		/// </summary>
		/// <param name="personGroupId">Id referencing a particular person group.</param>
		/// <returns>A successful call returns the person group's training status.</returns>
		public async Task<TrainingStatus> PersonGroup_GetTrainingStatusAsync(string personGroupId)
		{
			var requestUri = "persongroups/"+ (personGroupId==null? "" : System.Uri.EscapeDataString(personGroupId))+"/training";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrainingStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all accessible snapshots with related information, including snapshots that were taken by the user, or snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
		/// Snapshot_List snapshots
		/// </summary>
		/// <param name="type">User specified object type as a search filter.</param>
		/// <param name="applyScope">User specified snapshot apply scopes as a search filter. ApplyScope is an array of the target Azure subscription ids for the snapshot, specified by the user who created the snapshot by Snapshot - Take.</param>
		/// <returns>A successful call returns an array of snapshots with snapshot information.</returns>
		public async Task<Snapshot[]> Snapshot_ListAsync(SnapshotType type, string[] applyScope)
		{
			var requestUri = "snapshots?type=" + type+"&"+string.Join("&", applyScope.Select(z => $"applyScope={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Snapshot[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Submit an operation to take a snapshot of face list, large face list, person group or large person group, with user-specified snapshot type, source object id, apply scope and an optional user data.<br />
		/// The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.<br />
		/// Taking snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".<br />
		/// Snapshot taking time depends on the number of person and face entries in the source object. It could be in seconds, or up to several hours for 1,000,000 persons with multiple faces.<br />
		/// Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before expiration.<br />
		/// Taking snapshot for a certain object will not block any other operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual. For all writable operations, including Add/Update/Delete the source object or its persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can work as normal. Snapshot will also include the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.<br />
		/// * Free-tier subscription quota: 100 take operations per month.
		/// * S0-tier subscription quota: 100 take operations per day.
		/// Snapshot_Take snapshots
		/// </summary>
		/// <param name="requestBody">Request body for taking a snapshot.</param>
		public async Task Snapshot_TakeAsync(TakeSnapshotRequest requestBody)
		{
			var requestUri = "snapshots";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and target subscriptions included in the applyScope in Snapshot - Take.
		/// Snapshot_Get snapshots/{snapshotId}
		/// </summary>
		/// <param name="snapshotId">Id referencing a particular snapshot.</param>
		/// <returns>A successful call returns the snapshot's information.</returns>
		public async Task<Snapshot> Snapshot_GetAsync(string snapshotId)
		{
			var requestUri = "snapshots/"+ (snapshotId==null? "" : System.Uri.EscapeDataString(snapshotId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Snapshot>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
		/// Snapshot_Delete snapshots/{snapshotId}
		/// </summary>
		/// <param name="snapshotId">Id referencing a particular snapshot.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task Snapshot_DeleteAsync(string snapshotId)
		{
			var requestUri = "snapshots/"+ (snapshotId==null? "" : System.Uri.EscapeDataString(snapshotId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
		/// Snapshot_Update snapshots/{snapshotId}
		/// </summary>
		/// <param name="snapshotId">Id referencing a particular snapshot.</param>
		/// <param name="requestBody">Request body for updating a snapshot.</param>
		/// <returns>A successful call returns an empty response body.</returns>
		public async Task Snapshot_UpdateAsync(string snapshotId, UpdateSnapshotRequest requestBody)
		{
			var requestUri = "snapshots/"+ (snapshotId==null? "" : System.Uri.EscapeDataString(snapshotId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.<br />
		/// The snapshot interfaces are for users to backup and restore their face data from one face subscription to another, inside same region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.<br />
		/// Applying snapshot is an asynchronous operation. An operation id can be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus - Get response when the operation status is "succeeded".<br />
		/// Snapshot applying time depends on the number of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.<br />
		/// Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its creation.<br />
		/// Applying a snapshot will not block any other operations against the target object, however it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot applying is completed, all operations towards the target object can work as normal. Snapshot also includes the training results of the source object, which means target subscription the snapshot applied to does not need re-train the target object before calling Identify/FindSimilar.<br />
		/// One snapshot can be applied multiple times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will fail if target subscription already contains an object of same type and using the same objectId. Users can specify the "objectId" in request body to avoid such conflicts.<br />
		/// * Free-tier subscription quota: 100 apply operations per month.
		/// * S0-tier subscription quota: 100 apply operations per day.
		/// Snapshot_Apply snapshots/{snapshotId}/apply
		/// </summary>
		/// <param name="snapshotId">Id referencing a particular snapshot.</param>
		/// <param name="requestBody">Request body for applying a snapshot.</param>
		public async Task Snapshot_ApplyAsync(string snapshotId, ApplySnapshotRequest requestBody)
		{
			var requestUri = "snapshots/"+ (snapshotId==null? "" : System.Uri.EscapeDataString(snapshotId))+"/apply";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Verify whether two faces belong to a same person or whether one face belongs to a person.
		/// <br/>
		/// Remarks:<br />
		/// * Higher face image quality means better identification precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
		/// * For the scenarios that are sensitive to accuracy please make your own judgment.
		/// * The 'recognitionModel' associated with the query faces' faceIds should be the same as the 'recognitionModel' used by the target face, person group or large person group.
		/// 
		/// Face_VerifyFaceToFace verify
		/// </summary>
		/// <param name="requestBody">Request body for face to face verification.</param>
		/// <returns>A successful call returns the verification result.</returns>
		public async Task<VerifyResult> Face_VerifyFaceToFaceAsync(VerifyFaceToFaceRequest requestBody)
		{
			var requestUri = "verify";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VerifyResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum Face_DetectWithUrlDetectionModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		detection_01 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		detection_02 = 1,
	}
	
	public class Face_DetectWithUrlPostBody
	{
		
		/// <summary>
		/// Publicly reachable URL of an image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class FaceList_AddFaceFromUrlPostBody
	{
		
		/// <summary>
		/// Publicly reachable URL of an image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class LargeFaceList_AddFaceFromUrlPostBody
	{
		
		/// <summary>
		/// Publicly reachable URL of an image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class LargePersonGroupPerson_AddFaceFromUrlPostBody
	{
		
		/// <summary>
		/// Publicly reachable URL of an image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class PersonGroupPerson_AddFaceFromUrlPostBody
	{
		
		/// <summary>
		/// Publicly reachable URL of an image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
