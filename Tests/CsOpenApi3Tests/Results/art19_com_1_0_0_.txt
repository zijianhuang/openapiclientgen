//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A classification, in general, is something that can describe other resources, such as countries, genres or
	///languages. How they're described (included or excluded, and whether they're the primary classification
	///of this type) is handled using other resources. Different functions of ART19 rely on classifications differently,
	///and could have an effect only on directory information, or may have an effect on ad decisioning.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Classification
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public ClassificationAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `classifications`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class ClassificationAttributes
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Human readable representation of the classification
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display_name")]
		public string Display_name { get; set; }
		
		/// <summary>
		/// An object with more detailed information about the classification.
		///The possible members are different per type of classification.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `parent` in a future update.<br/>
		///For hierarchical classifications, this is the ID of the parent classification
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent_id")]
		public string Parent_id { get; set; }
		
		/// <summary>
		/// For hierarchical classifications this is the list of IDs reflecting the hierarchy starting
		///with the root level node.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tree_path")]
		public string[] Tree_path { get; set; }
		
		/// <summary>
		/// The type of classification. The type of retrievable classifications depends on the privileges
		///of the credential being used.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ClassificationAttributesType> Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The value the classification represents. The meaning of this attribute depends on the type of classification.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		/// <summary>
		/// For hierarchical classifications this is a concatenated string of all the classification
		///values from the root to this classification using a `: ` as separator.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value_path")]
		public string Value_path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ClassificationAttributesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AlternateFeedType")]
		AlternateFeedType = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Genre")]
		Genre = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Industry")]
		Industry = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Language")]
		Language = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MediaRating")]
		MediaRating = 4,
	}
	
	/// <summary>
	/// Connects a Classification with a classified item like a Series, Season or Episode.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClassificationInclusion
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public ClassificationInclusionAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public ClassificationInclusionRelationships Relationships { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `classification_inclusion`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class ClassificationInclusionAttributes
	{
		
		/// <summary>
		/// This will be replaced by the relationship `classification` in a future update.<br/>
		///The ID of the classification linked to the entity
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classification_id")]
		public string Classification_id { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `classification` in a future update.<br/>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classification_type")]
		public ClassificationAttributesType Classification_type { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `classified` in a future update.<br/>
		///The ID of the entity linked to the classification
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classified_id")]
		public string Classified_id { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `classified` in a future update.<br/>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="classified_type")]
		public System.Nullable<ClassificationInclusionAttributesClassified_type> Classified_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The position or order of the linked classification within the classified resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="position")]
		public System.Nullable<System.Int32> Position { get; set; }
		
		/// <summary>
		/// When `true` it describes the best classification of a specific type for a given
		///classified item
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public System.Nullable<System.Boolean> Primary { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ClassificationInclusionAttributesClassified_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Series")]
		Series = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Season")]
		Season = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Episode")]
		Episode = 2,
	}
	
	public class ClassificationInclusionRelationships
	{
		
		[System.Runtime.Serialization.DataMember(Name="classification")]
		public ClassificationInclusionRelationshipsClassification Classification { get; set; }
	}
	
	public class ClassificationInclusionRelationshipsClassification
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceIdentifier
	{
		
		/// <summary>
		/// The ID of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The type of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A credit links a specific person to a series, season, or episode in a specific role.
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Credit
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public CreditAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public CreditRelationships Relationships { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `credits`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class CreditAttributes
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The order of this credit within all credits of the referenced creditable entity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="position")]
		public System.Nullable<System.Int32> Position { get; set; }
		
		/// <summary>
		/// The type of credit the linked person has on the referenced entity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<CreditAttributesType> Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CreditAttributesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AnchorCredit")]
		AnchorCredit = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AssociateProducerCredit")]
		AssociateProducerCredit = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AuthorCredit")]
		AuthorCredit = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CastCredit")]
		CastCredit = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CoHostCredit")]
		CoHostCredit = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ComposerCredit")]
		ComposerCredit = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CreatorCredit")]
		CreatorCredit = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Credit")]
		Credit = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DirectorCredit")]
		DirectorCredit = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EditorCredit")]
		EditorCredit = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EngineerCredit")]
		EngineerCredit = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ExecutiveProducerCredit")]
		ExecutiveProducerCredit = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GuestCoHostCredit")]
		GuestCoHostCredit = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GuestCredit")]
		GuestCredit = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GuestHostCredit")]
		GuestHostCredit = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HeadWriterCredit")]
		HeadWriterCredit = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HostCredit")]
		HostCredit = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ProducerCredit")]
		ProducerCredit = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ReporterCredit")]
		ReporterCredit = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SeniorProducerCredit")]
		SeniorProducerCredit = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SidekickCredit")]
		SidekickCredit = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VideoProducerCredit")]
		VideoProducerCredit = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WriterCredit")]
		WriterCredit = 22,
	}
	
	public class CreditRelationships
	{
		
		[System.Runtime.Serialization.DataMember(Name="creditable")]
		public CreditRelationshipsCreditable Creditable { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="person")]
		public CreditRelationshipsPerson Person { get; set; }
	}
	
	public class CreditRelationshipsCreditable
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class CreditRelationshipsPerson
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Episode
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public EpisodeAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public EpisodeRelationships Relationships { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `episodes`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class EpisodeAttributes
	{
		
		/// <summary>
		/// Only visible to credentials having write privileges for the series.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allow_user_comments")]
		public System.Nullable<System.Boolean> Allow_user_comments { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `cascaded_cover_image` in a future update.<br/>
		///The image ID of the cover art for this episode. This is the preferred image ID to use.
		///If there is no specific cover for the episode, the image ID of the season or the
		///series will be returned, whichever has one defined.
		///The `/images` endpoint provides details to the image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cascaded_cover_image_id")]
		public string Cascaded_cover_image_id { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `cover_image` in a future update.<br/>
		///The image ID of the cover art for this episode, if an episode-specific image has been provided.
		///The `/images` endpoint provideds details to the image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cover_image_id")]
		public string Cover_image_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The description of the episode, possibly in HTML format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Determines whether `description` is in HTML format or plain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description_is_html")]
		public System.Nullable<System.Boolean> Description_is_html { get; set; }
		
		/// <summary>
		/// The description with all HTML markup removed. If the description does not contain markup,
		///this is identical to `description`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description_plain")]
		public string Description_plain { get; set; }
		
		/// <summary>
		/// The file name, without extension, to present users when downloading the episode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file_name")]
		public string File_name { get; set; }
		
		/// <summary>
		/// The type of the episode according to Apple's type categorization
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="itunes_type")]
		public System.Nullable<EpisodeAttributesItunes_type> Itunes_type { get; set; }
		
		/// <summary>
		/// The number of total downloads all time for this episode.
		///Only visible if the credential has the right privilege on the series.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listen_count")]
		public System.Nullable<System.Int32> Listen_count { get; set; }
		
		/// <summary>
		/// The current premium status of the episode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="premium_status")]
		public System.Nullable<EpisodeAttributesPremium_status> Premium_status { get; set; }
		
		/// <summary>
		/// If `true`, the episode will be available for download and included in the feed as soon as its
		///release time is reached, provided it has a valid media file, and `release_end_at` is in the future (if applicable).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="published")]
		public System.Nullable<System.Boolean> Published { get; set; }
		
		/// <summary>
		/// The date and time when an episode will no longer be included in the feed, or available for download.
		///`Published` will remain `true` unless the episode is manually unpublished.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_end_at")]
		public System.Nullable<System.DateTimeOffset> Release_end_at { get; set; }
		
		/// <summary>
		/// If `true`, the episode's release time is set in a way it is considered released right away.
		///Only visible if the credential has write privileges on the series.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="release_immediately")]
		public System.Nullable<System.Boolean> Release_immediately { get; set; }
		
		/// <summary>
		/// The date and time when an episode will be released. It will be available for download and included
		///in the feed if this time is reached, `published` is set to `true`, and the episode has a media file.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="released_at")]
		public System.Nullable<System.DateTimeOffset> Released_at { get; set; }
		
		/// <summary>
		/// A globally unique identifier describing the episode. This ID is commonly used by podcast applications
		///to determine whether an episode has already been downloaded or not.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rss_guid")]
		public string Rss_guid { get; set; }
		
		/// <summary>
		/// Use the relationship `season` instead.<br />
		///The ID of the season an episode belongs to. This can be `null`. A series can have episodes with and
		///without seasons at the same time.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="season_id")]
		public string Season_id { get; set; }
		
		/// <summary>
		/// Use the relationship `series` instead.<br />
		///The ID of the series an episode belongs to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="series_id")]
		public string Series_id { get; set; }
		
		/// <summary>
		/// The title of the episode modified for sorting. This converts all characters to
		///lower case, removes an eventually leading `The` as well as leading and trailling whitespace characters.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sort_title")]
		public string Sort_title { get; set; }
		
		/// <summary>
		/// The status of an episode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<EpisodeAttributesStatus> Status { get; set; }
		
		/// <summary>
		/// The title of the episode
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum EpisodeAttributesItunes_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="full")]
		full = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bonus")]
		bonus = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="trailer")]
		trailer = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum EpisodeAttributesPremium_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="active")]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="inactive")]
		inactive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="force-active")]
		forceMinusactive = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="force-inactive")]
		forceMinusinactive = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum EpisodeAttributesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="active")]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="inactive")]
		inactive = 1,
	}
	
	public class EpisodeRelationships
	{
		
		/// <summary>
		/// The cover art for this episode. This is the preferred image to use.
		///If there is no specific cover image for the episode, the cover of the season or the
		///series will be returned, whichever has one defined.
		///The `/images` endpoint provides details to the image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cascaded_cover_image")]
		public EpisodeRelationshipsCascaded_cover_image Cascaded_cover_image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="classification_inclusions")]
		public EpisodeRelationshipsClassification_inclusions Classification_inclusions { get; set; }
		
		/// <summary>
		/// The cover art for this episode, if an episode-specific image has been provided.
		///The `/images` endpoint provideds details to the image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cover_image")]
		public EpisodeRelationshipsCover_image Cover_image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="credits")]
		public EpisodeRelationshipsCredits Credits { get; set; }
		
		/// <summary>
		/// Only visible if the credential has write privileges on the series
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="default_marker_points")]
		public EpisodeRelationshipsDefault_marker_points Default_marker_points { get; set; }
		
		/// <summary>
		/// Only visible if the credential has write privileges on the series
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="episode_versions")]
		public EpisodeRelationshipsEpisode_versions Episode_versions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="images")]
		public EpisodeRelationshipsImages Images { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="season")]
		public EpisodeRelationshipsSeason Season { get; set; }
		
		/// <summary>
		/// Only visible if the credential has write privileges on the series
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="segment_lists")]
		public EpisodeRelationshipsSegment_lists Segment_lists { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="series")]
		public EpisodeRelationshipsSeries Series { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taggings")]
		public EpisodeRelationshipsTaggings Taggings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public EpisodeRelationshipsTags Tags { get; set; }
	}
	
	public class EpisodeRelationshipsCascaded_cover_image
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class EpisodeRelationshipsClassification_inclusions
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class EpisodeRelationshipsCover_image
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class EpisodeRelationshipsCredits
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class EpisodeRelationshipsDefault_marker_points
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class EpisodeRelationshipsEpisode_versions
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class EpisodeRelationshipsImages
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class EpisodeRelationshipsSeason
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class EpisodeRelationshipsSegment_lists
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class EpisodeRelationshipsSeries
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class EpisodeRelationshipsTaggings
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class EpisodeRelationshipsTags
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Image
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public ImageAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public ImageRelationships Relationships { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `images`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class ImageAttributes
	{
		
		/// <summary>
		/// This will be replaced by the relationship `bucket` in a future update.<br/>
		///The ID of the owning entity
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket_id")]
		public string Bucket_id { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `bucket` in a future update.<br/>
		///The type of the owning entity
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket_type")]
		public System.Nullable<ImageAttributesBucket_type> Bucket_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="crop_data")]
		public ImageAttributesCrop_data Crop_data { get; set; }
		
		/// <summary>
		/// The current value of the image state machine. It starts with `uploaded` and
		///transitions to `processing` once a worker has picked it up. If all variations and
		///styles of an image have been successfully created, the status becomes `valid`. In
		///case of a problem during the processing it changes to `invalid`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ImageAttributesStatus> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImageAttributesBucket_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AdRepAccount")]
		AdRepAccount = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Agency")]
		Agency = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Network")]
		Network = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Series")]
		Series = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="User")]
		User = 4,
	}
	
	public class ImageAttributesCrop_data
	{
		
		/// <summary>
		/// The height of the crop area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Single> Height { get; set; }
		
		/// <summary>
		/// The left coordinate of the crop area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="left")]
		public System.Nullable<System.Single> Left { get; set; }
		
		/// <summary>
		/// The top coordinate of the crop area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="top")]
		public System.Nullable<System.Single> Top { get; set; }
		
		/// <summary>
		/// The width of the crop area
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Single> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImageAttributesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="invalid")]
		invalid = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="processing")]
		processing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="uploaded")]
		uploaded = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="valid")]
		valid = 3,
	}
	
	public class ImageRelationships
	{
		
		[System.Runtime.Serialization.DataMember(Name="media_assets")]
		public ImageRelationshipsMedia_assets Media_assets { get; set; }
	}
	
	public class ImageRelationshipsMedia_assets
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Links
	{
		
		/// <summary>
		/// A URL to retrieve the first page of data keeping the provided page size
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first")]
		public string First { get; set; }
		
		/// <summary>
		/// A URL to retrieve the last page of data keeping the provided page size
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last")]
		public string Last { get; set; }
		
		/// <summary>
		/// A URL to retrieve the next page of data keeping the provided page size
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next")]
		public string Next { get; set; }
		
		/// <summary>
		/// A URL to retrieve the previous page of keeping using the provided page size
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prev")]
		public string Prev { get; set; }
		
		/// <summary>
		/// A URL to retrieve the collection as the primary data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MediaAsset
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public MediaAssetAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `media_assets`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class MediaAssetAttributes
	{
		
		/// <summary>
		/// This will be replaced by the relationship `attachment` in a future update.<br/>
		///The ID of the entity this media asset is attached to
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attachment_id")]
		public string Attachment_id { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `attachment` in a future update.<br/>
		///The type of the entity this media asset is attached to
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attachment_type")]
		public System.Nullable<MediaAssetAttributesAttachment_type> Attachment_type { get; set; }
		
		/// <summary>
		/// The CDN-URL where the media asset is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cdn_url")]
		public string Cdn_url { get; set; }
		
		/// <summary>
		/// The MIME type of the media asset
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The filename of the media asset without any path components.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file_name")]
		public string File_name { get; set; }
		
		/// <summary>
		/// The size in bytes of the media asset
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file_size")]
		public System.Nullable<System.Int32> File_size { get; set; }
		
		/// <summary>
		/// The height in pixels of the media asset, if the media asset is an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size_height")]
		public System.Nullable<System.Int32> Size_height { get; set; }
		
		/// <summary>
		/// The width in pixels of the media asset, if the media asset is an image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size_width")]
		public System.Nullable<System.Int32> Size_width { get; set; }
		
		/// <summary>
		/// The style of the media asset. A media asset is part of a collection of related media files,
		///for example an image or an episode (audio). Images usually have differently sized versions,
		///and episodes can have different audio formats.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="style")]
		public System.Nullable<MediaAssetAttributesStyle> Style { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaAssetAttributesAttachment_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Image")]
		Image = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Segment")]
		Segment = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SegmentList")]
		SegmentList = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MediaAssetAttributesStyle
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="info")]
		info = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="itunes")]
		itunes = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="medium")]
		medium = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="original")]
		original = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="regular")]
		regular = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="square-400")]
		squareMinus400 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="square-640")]
		squareMinus640 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="square-888")]
		squareMinus888 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="square-3000")]
		squareMinus3000 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="stripped-original")]
		strippedMinusoriginal = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="thumb")]
		thumb = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="waveform_data")]
		waveform_data = 11,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Network
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public NetworkAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public NetworkRelationships Relationships { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `networks`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class NetworkAttributes
	{
		
		/// <summary>
		/// The copyright of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copyright")]
		public string Copyright { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The description of the network eventually in HTML format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Determines whether `description` is in HTML format or plain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description_is_html")]
		public System.Nullable<System.Boolean> Description_is_html { get; set; }
		
		/// <summary>
		/// The description with all HTML markup removed. If the description does not contain markup
		///this is identitcal to `description`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description_plain")]
		public string Description_plain { get; set; }
		
		/// <summary>
		/// Where to find this network on Facebook
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facebook_url")]
		public string Facebook_url { get; set; }
		
		/// <summary>
		/// Where to find this network on Instagram
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instagram_url")]
		public string Instagram_url { get; set; }
		
		/// <summary>
		/// Where to find the network on LinkedIn
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkedin_url")]
		public string Linkedin_url { get; set; }
		
		/// <summary>
		/// The name of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A public point of contact through email
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_email")]
		public string Public_email { get; set; }
		
		/// <summary>
		/// If this is `true`, a public web page for this network is available under
		///`https://art19.com/networks/{slug}`, where `slug` is the value of the corresponding attribute.
		///This public page provides details about the network as well as descriptive links to all its
		///series' public pages. If this is `false`, no such public page is available.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_page_enabled")]
		public System.Nullable<System.Boolean> Public_page_enabled { get; set; }
		
		/// <summary>
		/// The unique slug for the network also used on its public page for example.
		///This value is unique system-wide amongst all networks _and_ series.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// Where to find the network on Tumblr
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tumblr_url")]
		public string Tumblr_url { get; set; }
		
		/// <summary>
		/// Where to find the network on Twitter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twitter_url")]
		public string Twitter_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// A public website for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website_url")]
		public string Website_url { get; set; }
	}
	
	public class NetworkRelationships
	{
		
		/// <summary>
		/// The cover image for the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cover_image")]
		public NetworkRelationshipsCover_image Cover_image { get; set; }
		
		/// <summary>
		/// A collection of images linked to the network. This currently only includes
		///the cover image for the network.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="images")]
		public NetworkRelationshipsImages Images { get; set; }
		
		/// <summary>
		/// The parent network of the network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public NetworkRelationshipsParent Parent { get; set; }
		
		/// <summary>
		/// List of series within the network which are accessible to you
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="series")]
		public NetworkRelationshipsSeries Series { get; set; }
	}
	
	public class NetworkRelationshipsCover_image
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class NetworkRelationshipsImages
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class NetworkRelationshipsParent
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class NetworkRelationshipsSeries
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Person
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public PersonAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public PersonRelationships Relationships { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `people`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class PersonAttributes
	{
		
		/// <summary>
		/// This will be replaced by the relationship `avatar` in a future update.<br/>
		///The image ID of an avatar or head shot of the person. Details can be
		///retrieved using the `/images` endpoint.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar_id")]
		public string Avatar_id { get; set; }
		
		/// <summary>
		/// The biography of the person without markup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="biography")]
		public string Biography { get; set; }
		
		/// <summary>
		/// The birthday of the person
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="born")]
		public System.Nullable<System.DateOnly> Born { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The day of death of the person
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="died")]
		public System.Nullable<System.DateOnly> Died { get; set; }
		
		/// <summary>
		/// The first name of the person
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first_name")]
		public string First_name { get; set; }
		
		/// <summary>
		/// The country the person is from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from_country")]
		public string From_country { get; set; }
		
		/// <summary>
		/// The locality or city the person is from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from_locality")]
		public string From_locality { get; set; }
		
		/// <summary>
		/// The region/state/province the person is from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from_region")]
		public string From_region { get; set; }
		
		/// <summary>
		/// The last name of the person
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_name")]
		public string Last_name { get; set; }
		
		/// <summary>
		/// The public email contact for the person
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_email")]
		public string Public_email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	public class PersonRelationships
	{
		
		/// <summary>
		/// The avatar or head shot of the person. Details can be retrieved using the `/images` endpoint.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar")]
		public PersonRelationshipsAvatar Avatar { get; set; }
	}
	
	public class PersonRelationshipsAvatar
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	/// <summary>
	/// Links related to the retrieved resource
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceLink
	{
		
		/// <summary>
		/// A URL to retrieve the resource as the primary data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="self")]
		public string Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Season
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public SeasonAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public SeasonRelationships Relationships { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `seasons`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class SeasonAttributes
	{
		
		/// <summary>
		/// This will be replaced by the relationship `cascaded_cover_image` in a future update.<br/>
		///The image ID of the cover art for this season. If there is no specific cover for the season,
		///the image ID of the series' cover art will be returned.
		///The `/images` endpoint provideds details to the image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cascaded_cover_image_id")]
		public string Cascaded_cover_image_id { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `cover_image` in a future update.<br/>
		///The image ID of the cover art for this season. The `/images` endpoint provideds details to the image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cover_image_id")]
		public string Cover_image_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The description of the season eventually in HTML format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Determines whether `description` is in HTML format or plain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description_is_html")]
		public System.Nullable<System.Boolean> Description_is_html { get; set; }
		
		/// <summary>
		/// The description with all HTML markup removed. If the description does not contain markup
		///this is identitcal to `description`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description_plain")]
		public string Description_plain { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `first_released_episode` in a future update.<br/>
		///The ID of the first released episode within the season
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first_released_episode_id")]
		public string First_released_episode_id { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `last_released_episode` in a future update.<br/>
		///The ID of the most recently released episode within the season
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_released_episode_id")]
		public string Last_released_episode_id { get; set; }
		
		/// <summary>
		/// The number of the season. This could be `null` as well.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="season_number")]
		public System.Nullable<System.Int32> Season_number { get; set; }
		
		/// <summary>
		/// The title of the season modified for sorting. This converts all characters to
		///lower case, removes an eventually leading `The` as well as leading and trailling whitespace characters.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sort_title")]
		public string Sort_title { get; set; }
		
		/// <summary>
		/// The current status of the season
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public EpisodeAttributesStatus Status { get; set; }
		
		/// <summary>
		/// The title of the season
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	public class SeasonRelationships
	{
		
		/// <summary>
		/// The cover art for this season. If there is no specific cover for the season,
		///the cover image of the series' cover art will be returned.
		///The `/images` endpoint provideds details to the image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cascaded_cover_image")]
		public SeasonRelationshipsCascaded_cover_image Cascaded_cover_image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="classification_inclusions")]
		public SeasonRelationshipsClassification_inclusions Classification_inclusions { get; set; }
		
		/// <summary>
		/// The cover image for the season
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cover_image")]
		public SeasonRelationshipsCover_image Cover_image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="credits")]
		public SeasonRelationshipsCredits Credits { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SeasonRelationshipsEpisodes Episodes { get; set; }
		
		/// <summary>
		/// The first released episode within the season
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first_released_episode")]
		public SeasonRelationshipsFirst_released_episode First_released_episode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="images")]
		public SeasonRelationshipsImages Images { get; set; }
		
		/// <summary>
		/// The most recently released episode within the season
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_released_episode")]
		public SeasonRelationshipsLast_released_episode Last_released_episode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="series")]
		public SeasonRelationshipsSeries Series { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taggings")]
		public SeasonRelationshipsTaggings Taggings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public SeasonRelationshipsTags Tags { get; set; }
	}
	
	public class SeasonRelationshipsCascaded_cover_image
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class SeasonRelationshipsClassification_inclusions
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeasonRelationshipsCover_image
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class SeasonRelationshipsCredits
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeasonRelationshipsEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeasonRelationshipsFirst_released_episode
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class SeasonRelationshipsImages
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeasonRelationshipsLast_released_episode
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class SeasonRelationshipsSeries
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class SeasonRelationshipsTaggings
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeasonRelationshipsTags
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Series
	{
		
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public SeriesAttributes Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationships")]
		public SeriesRelationships Relationships { get; set; }
		
		/// <summary>
		/// The type of resource. This is always `series`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class SeriesAttributes
	{
		
		/// <summary>
		/// If `null` or `true`, the ART19 web player will render an Amazon subscription badge
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amazon_subscription_badge_enabled")]
		public System.Nullable<System.Boolean> Amazon_subscription_badge_enabled { get; set; }
		
		/// <summary>
		/// The Amazon Music subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amazon_subscription_url")]
		public string Amazon_subscription_url { get; set; }
		
		/// <summary>
		/// The CastBox subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="castbox_subscription_url")]
		public string Castbox_subscription_url { get; set; }
		
		/// <summary>
		/// This will be replaced by the relationship `cover_image` in a future update.<br/>
		///The image ID of the cover art for this series. The `/images` endpoint provideds details to the image.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cover_image_id")]
		public string Cover_image_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The description of the series eventually in HTML format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Determines whether `description` is in HTML format or plain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description_is_html")]
		public System.Nullable<System.Boolean> Description_is_html { get; set; }
		
		/// <summary>
		/// The description with all HTML markup removed. If the description does not contain markup
		///this is identitcal to `description`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description_plain")]
		public string Description_plain { get; set; }
		
		/// <summary>
		/// The URL of the series on Facebook
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facebook_url")]
		public string Facebook_url { get; set; }
		
		/// <summary>
		/// The Google subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="google_subscription_url")]
		public string Google_subscription_url { get; set; }
		
		/// <summary>
		/// The iHeartRadio subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iheart_subscription_url")]
		public string Iheart_subscription_url { get; set; }
		
		/// <summary>
		/// The URL of the series on Instagram
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instagram_url")]
		public string Instagram_url { get; set; }
		
		/// <summary>
		/// If `null` or `true`, the ART19 web player will render an iTunes subscription badge
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="itunes_subscription_badge_enabled")]
		public System.Nullable<System.Boolean> Itunes_subscription_badge_enabled { get; set; }
		
		/// <summary>
		/// The Apple iTunes subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="itunes_subscription_url")]
		public string Itunes_subscription_url { get; set; }
		
		/// <summary>
		/// The URL of the series on LinkedIn
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkedin_url")]
		public string Linkedin_url { get; set; }
		
		/// <summary>
		/// The Pocket Casts subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pocket_casts_subscription_url")]
		public string Pocket_casts_subscription_url { get; set; }
		
		/// <summary>
		/// The URL of the RSS feed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="podcast_subscription_url")]
		public string Podcast_subscription_url { get; set; }
		
		/// <summary>
		/// If this is `true`, a public web page for this series is available under
		///`https://art19.com/shows/{slug}`, where `slug` is the value of the corresponding attribute.
		///This public page provides details about the series as well as descriptive links to all its
		///episodes. If this is `false`, no such public page is available.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_page_enabled")]
		public System.Nullable<System.Boolean> Public_page_enabled { get; set; }
		
		/// <summary>
		/// If present, this is the preferred title for the series in the RSS Feed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_title")]
		public string Public_title { get; set; }
		
		/// <summary>
		/// The RadioPublic subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="radio_public_subscription_url")]
		public string Radio_public_subscription_url { get; set; }
		
		/// <summary>
		/// The author responsible for the RSS feed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rss_author")]
		public string Rss_author { get; set; }
		
		/// <summary>
		/// The copyright disclaimer for the contents of the show, appearing after a  symbol, e.g. `2020 ART19, Inc.`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rss_copyright")]
		public string Rss_copyright { get; set; }
		
		/// <summary>
		/// The pubic point of contact for the show
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rss_email")]
		public string Rss_email { get; set; }
		
		/// <summary>
		/// The name of the contact for the show
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rss_owner")]
		public string Rss_owner { get; set; }
		
		/// <summary>
		/// This slug is unique over all series and networks system wide and is used to access the series' feed
		///as well as its eventually enabled public page on ART19.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		/// <summary>
		/// The title of the series modified for sorting. This converts all characters to
		///lower case, removes an eventually leading `The` as well as leading and trailling whitespace characters.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sort_title")]
		public string Sort_title { get; set; }
		
		/// <summary>
		/// If `null` or `true`, the ART19 web player will render a Spotify subscription badge
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spotify_subscription_badge_enabled")]
		public System.Nullable<System.Boolean> Spotify_subscription_badge_enabled { get; set; }
		
		/// <summary>
		/// The Spotify subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spotify_subscription_url")]
		public string Spotify_subscription_url { get; set; }
		
		/// <summary>
		/// The status of the series
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public EpisodeAttributesStatus Status { get; set; }
		
		/// <summary>
		/// If `null` or `true`, the ART19 web player will render a Stitcher subscription badge
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stitcher_subscription_badge_enabled")]
		public System.Nullable<System.Boolean> Stitcher_subscription_badge_enabled { get; set; }
		
		/// <summary>
		/// The Stitcher subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stitcher_subscription_url")]
		public string Stitcher_subscription_url { get; set; }
		
		/// <summary>
		/// The title of the series
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// The URL of the series on Tumblr
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tumblr_url")]
		public string Tumblr_url { get; set; }
		
		/// <summary>
		/// The TuneIn subscription URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tune_in_subscription_url")]
		public string Tune_in_subscription_url { get; set; }
		
		/// <summary>
		/// The URL of the series on Twitter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="twitter_url")]
		public string Twitter_url { get; set; }
		
		/// <summary>
		/// The type of the series
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<SeriesAttributesType> Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// The custom website URL for the series
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website_url")]
		public string Website_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SeriesAttributesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Series")]
		Series = 0,
	}
	
	public class SeriesRelationships
	{
		
		[System.Runtime.Serialization.DataMember(Name="classification_inclusions")]
		public SeriesRelationshipsClassification_inclusions Classification_inclusions { get; set; }
		
		/// <summary>
		/// The cover image for the series
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cover_image")]
		public SeriesRelationshipsCover_image Cover_image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="credits")]
		public SeriesRelationshipsCredits Credits { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SeriesRelationshipsEpisodes Episodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="images")]
		public SeriesRelationshipsImages Images { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public SeriesRelationshipsNetwork Network { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SeriesRelationshipsSeasons Seasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taggings")]
		public SeriesRelationshipsTaggings Taggings { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public SeriesRelationshipsTags Tags { get; set; }
	}
	
	public class SeriesRelationshipsClassification_inclusions
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeriesRelationshipsCover_image
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class SeriesRelationshipsCredits
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeriesRelationshipsEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeriesRelationshipsImages
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeriesRelationshipsNetwork
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier Data { get; set; }
	}
	
	public class SeriesRelationshipsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeriesRelationshipsTaggings
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public class SeriesRelationshipsTags
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourceIdentifier[] Data { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get ClassificationInclusion records
		/// Classification Inclusions connect classifications with entities like series, episodes, or campaigns, amongst others.
		/// 
		/// In order to retrieve a set of classification inclusions, at least one of the following filter parameters must
		/// be provided. Failing to do so renders a `400 Bad Request` response.
		/// 
		/// - `ids[]`
		/// - `classified_id` and `classified_type`
		/// - `classified_id` and `classification_type`
		/// - `classification_id` and `classified_type`
		/// 
		/// Classification_inclusionsGetByIds_AndPage_numberAndPage_sizeAndClassification_idAndClassification_typeAndClassified_idAndClassified_typeAndQAndSort classification_inclusions
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <param name="page_number">Select which page number to receive results for. Pages are numbered starting at 1.
		///
		///
		/// Minimum: 1
		// </param>
		/// <param name="page_size">Indicate how many records to return per page. The maximum is 100.
		///
		///
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="classification_id">Limit the result to classification inclusions linked to a classification with this ID.</param>
		/// <param name="classification_type">The type of classification that the classification inclusions are linked to.
		///Depending on the permissions of your credential, only a subset of these types are usable.
		///</param>
		/// <param name="classified_id">Limit the result to classification inclusions linked to a resource with this ID.
		///You will have to use this filter together with either `classified_type` or `classification_type`.
		///</param>
		/// <param name="classified_type">Limit the result to classification inclusions linked to this type of entity.</param>
		/// <param name="q">Limit the result to classification inclusions linked to a classification containing
		///the parameter value disregarding case.
		///</param>
		/// <param name="sort">Specify how to sort the result. Please refer to either the top section or the
		///[JSON:API specification](https://jsonapi.org/format/#fetching-sorting) on how sorting works in general.
		///</param>
		/// <returns>Success</returns>
		public async Task Classification_inclusionsGetByIds_AndPage_numberAndPage_sizeAndClassification_idAndClassification_typeAndClassified_idAndClassified_typeAndQAndSortAsync(string[] ids_, int page_number, int page_size, string classification_id, ClassificationAttributesType classification_type, string classified_id, ClassificationInclusionAttributesClassified_type classified_type, string q, string[] sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "classification_inclusions?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"))+"&page[number]="+page_number+"&page[size]="+page_size+"&classification_id=" + (classification_id==null? "" : System.Uri.EscapeDataString(classification_id))+"&classification_type=" + classification_type+"&classified_id=" + (classified_id==null? "" : System.Uri.EscapeDataString(classified_id))+"&classified_type=" + classified_type+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific classification inclusion
		/// Classification_inclusions_idGet classification_inclusions/{id}
		/// </summary>
		/// <param name="id">The ID of the classification inclusion resource to load.</param>
		/// <returns>Success</returns>
		public async Task Classification_inclusions_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "classification_inclusions/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of classifications
		/// ClassificationsGetByIds_AndPage_numberAndPage_sizeAndTypeAndQAndIs_countryAndSort classifications
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <param name="page_number">Select which page number to receive results for. Pages are numbered starting at 1.
		///
		///
		/// Minimum: 1
		// </param>
		/// <param name="page_size">Indicate how many records to return per page. The maximum is 100.
		///
		///
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="type">Limit the result to classifications of this type. The possible values for types
		///depends on the privileges of the provided credential.
		///</param>
		/// <param name="q">Limit the result to classifications with a value containing the parameter value
		///disregarding case.
		///</param>
		/// <param name="is_country">If this parameter is provided and not empty, limit the result to classifications
		///of type `Geography` representing countries. The credential must have at least one
		///privilege with a network, series, or advertiser profile.
		///</param>
		/// <param name="sort">Specify how to sort the result. Please refer to either the top section or the
		///[JSON:API specification](https://jsonapi.org/format/#fetching-sorting) on how sorting works in general.
		///</param>
		/// <returns>Success</returns>
		public async Task ClassificationsGetByIds_AndPage_numberAndPage_sizeAndTypeAndQAndIs_countryAndSortAsync(string[] ids_, int page_number, int page_size, ClassificationAttributesType type, string q, string is_country, string[] sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "classifications?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"))+"&page[number]="+page_number+"&page[size]="+page_size+"&type=" + type+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&is_country=" + (is_country==null? "" : System.Uri.EscapeDataString(is_country))+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific classification
		/// Classifications_idGet classifications/{id}
		/// </summary>
		/// <param name="id">The ID of the classification resource to load.</param>
		/// <returns>Success</returns>
		public async Task Classifications_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "classifications/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of credits
		/// CreditsGetByIds_AndPage_numberAndPage_sizeAndCreditable_idAndCreditable_typeAndSort credits
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <param name="page_number">Select which page number to receive results for. Pages are numbered starting at 1.
		///
		///
		/// Minimum: 1
		// </param>
		/// <param name="page_size">Indicate how many records to return per page. The maximum is 100.
		///
		///
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="creditable_id">Limit the result to credits for the entity with this ID only. If the entity is not
		///published, the credential needs to have the right privilege to list the credits for it.
		///</param>
		/// <param name="creditable_type">Limit the result to credits linked to this type of entity only.
		///Depending on the privileges of the credential, this list might be further reduced to
		///only published entities.
		///</param>
		/// <param name="sort">Specify how to sort the result. Please refer to either the top section or the
		///[JSON:API specification](https://jsonapi.org/format/#fetching-sorting) on how sorting works in general.
		///</param>
		/// <returns>Success</returns>
		public async Task CreditsGetByIds_AndPage_numberAndPage_sizeAndCreditable_idAndCreditable_typeAndSortAsync(string[] ids_, int page_number, int page_size, string creditable_id, ClassificationInclusionAttributesClassified_type creditable_type, string[] sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "credits?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"))+"&page[number]="+page_number+"&page[size]="+page_size+"&creditable_id=" + (creditable_id==null? "" : System.Uri.EscapeDataString(creditable_id))+"&creditable_type=" + creditable_type+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific credit
		/// Credits_idGet credits/{id}
		/// </summary>
		/// <param name="id">The ID of the credit resource to load.</param>
		/// <returns>Success</returns>
		public async Task Credits_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "credits/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of episodes
		/// One initial filter must be provided (`ids`, `series_id`, or `season_id`), otherwise a `400 Bad Request` response
		/// will be returned. Additional filters are allowed.
		/// 
		/// This API will only return episodes that your credential has permission to access, which may not be exclusive to
		/// your account, depending on the filter(s) being used. Be careful to filter the results as needed.
		/// 
		/// EpisodesGetByIds_AndPage_numberAndPage_sizeAndIncluded_in_inventory_calendarAndMonthAndPublishedAndQAndReleased_afterAndReleased_beforeAndRssAndSeason_idAndSeries_idAndSortAndYear episodes
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <param name="page_number">Select which page number to receive results for. Pages are numbered starting at 1.
		///
		///
		/// Minimum: 1
		// </param>
		/// <param name="page_size">Indicate how many records to return per page. The maximum is 100.
		///
		///
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="included_in_inventory_calendar">Limit the result to episodes usable with an inventory management calendar for the provided AdDeal ID.</param>
		/// <param name="month">Limit the result to episodes released in this month.</param>
		/// <param name="published">If `true`, limit the result to published episodes only.
		///If `false`, limit the result to _unpublished_ episodes only.
		///</param>
		/// <param name="q">Limit the result to episodes with a title containing this parameter in a case-insensitive way.</param>
		/// <param name="released_after">Limit the result to episodes released after this timestamp.</param>
		/// <param name="released_before">Limit the result to episodes released before this timestamp.</param>
		/// <param name="rss">If `true`, limit the result to published and released episodes holding an available media file.
		///If this is `true`, it also changes the default sort order to `-released_at`.
		///</param>
		/// <param name="season_id">Limit result to episodes linked to this season.</param>
		/// <param name="series_id">Limit the result to episodes linked to this series.</param>
		/// <param name="sort">Specify how to sort the result. Please refer to either the top section or the
		///[JSON:API specification](https://jsonapi.org/format/#fetching-sorting) on how sorting works in general.
		///</param>
		/// <param name="year">Limit the result to episodes released in this year.</param>
		/// <returns>Success</returns>
		public async Task EpisodesGetByIds_AndPage_numberAndPage_sizeAndIncluded_in_inventory_calendarAndMonthAndPublishedAndQAndReleased_afterAndReleased_beforeAndRssAndSeason_idAndSeries_idAndSortAndYearAsync(string[] ids_, int page_number, int page_size, string included_in_inventory_calendar, string month, bool published, string q, System.DateTimeOffset released_after, System.DateTimeOffset released_before, bool rss, string season_id, string series_id, string[] sort, string year, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "episodes?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"))+"&page[number]="+page_number+"&page[size]="+page_size+"&included_in_inventory_calendar=" + (included_in_inventory_calendar==null? "" : System.Uri.EscapeDataString(included_in_inventory_calendar))+"&month=" + (month==null? "" : System.Uri.EscapeDataString(month))+"&published="+published+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&released_after=" + released_after.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&released_before=" + released_before.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&rss="+rss+"&season_id=" + (season_id==null? "" : System.Uri.EscapeDataString(season_id))+"&series_id=" + (series_id==null? "" : System.Uri.EscapeDataString(series_id))+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"))+"&year=" + (year==null? "" : System.Uri.EscapeDataString(year));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific episode
		/// Episodes_idGet episodes/{id}
		/// </summary>
		/// <param name="id">The ID of the episode resource to load.</param>
		/// <returns>Success</returns>
		public async Task Episodes_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "episodes/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the episode released right after the specified one
		/// Episodes_idNext_siblingGetByRss episodes/{id}/next_sibling
		/// </summary>
		/// <param name="id">The ID of the episode to find the one episode released right after it.</param>
		/// <param name="rss">If `true`, get the next released and published episode with an available media file.
		///</param>
		/// <returns>Success</returns>
		public async Task Episodes_idNext_siblingGetByRssAsync(string id, bool rss, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "episodes/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/next_sibling&rss="+rss;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get the episode released right before the specified one
		/// Episodes_idPrevious_siblingGetByRss episodes/{id}/previous_sibling
		/// </summary>
		/// <param name="id">The ID of the episode to find the one episode released right before it.</param>
		/// <param name="rss">If `true`, get the previously released and published episode with an available media file.
		///</param>
		/// <returns>Success</returns>
		public async Task Episodes_idPrevious_siblingGetByRssAsync(string id, bool rss, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "episodes/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/previous_sibling&rss="+rss;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of images
		/// An image represents a piece of artwork attached to some entity like a series, season, or episode,
		/// and is _owned_ by an entity called the `bucket`.
		/// An image is also a container for several `MediaAssets` representing the physical files for various
		/// styles used.
		/// 
		/// ## Media Asset Styles for Images
		/// 
		/// Most media assets use square images. You may upload and use a square image, or upload an image of any
		/// shape and crop it to a square by specifying the cropping area. This area  identified by a coordinate
		/// `x, y` and a `width` & `height`  is the portion of the image used for all cover art. If an image has
		/// cropping defined, the cropped version of the image will be used in any `regular` or `square` style of media
		/// asset. If the original file is rectangular and does not have cropping, then the system will use a squared
		/// version of the original file with the smaller of width or height as the square size.
		/// 
		/// The original image as uploaded into the system is always retained unmodified and available through
		/// the style `original`. All media asset styles except `stripped-original` consist of the cropped image.
		/// 
		/// An image has media assets with the following styles:
		/// 
		/// - `original`: This is the original file provided. May not be available, depending on permissions
		/// and file type.
		/// - `stripped-original`: The original file with all metadata (EXIF, XMP, PNG metadata, etc.) removed.
		/// This should be used for any application needing the original, uncropped, image.
		/// - `regular`: If the image has cropping defined, this is the cropped image.
		/// If not, this is a square version of the original.
		/// - `thumb`: A square thumbnail of the image with a size of `100x100` pixels.
		/// - `square-400`: A square version of the image with a size of `400x400` pixels.
		/// - `square-640`: A square version of the image with a size of `640x640` pixels.
		/// - `square-888`: A square version of the image with a size of `888x888` pixels.
		/// - `square-3000`: A square version of the image with a size of `3000x3000` pixels.
		/// This variant is only created if the cropped width & height are each at least 3000.
		/// - `itunes`: A square version of the image with a size of `1400x1400` pixels.
		/// 
		/// ### Preferred image used in feeds
		/// 
		/// For the main series image used in feeds, it is ideal to use the `square-3000` version.
		/// If that is not available, the `itunes` version should be used instead.
		/// 
		/// 
		/// ImagesGetByIds_ images
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <returns>Success</returns>
		public async Task ImagesGetByIds_Async(string[] ids_, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific image
		/// An image represents a piece of artwork attached to some entity like a series, season, or episode,
		/// and is _owned_ by an entity called the `bucket`.
		/// An image is also a container for several `MediaAssets` representing the physical files for various
		/// styles used.
		/// 
		/// ## Media Asset Styles for Images
		/// 
		/// Most media assets use square images. You may upload and use a square image, or upload an image of any
		/// shape and crop it to a square by specifying the cropping area. This area  identified by a coordinate
		/// `x, y` and a `width` & `height`  is the portion of the image used for all cover art. If an image has
		/// cropping defined, the cropped version of the image will be used in any `regular` or `square` style of media
		/// asset. If the original file is rectangular and does not have cropping, then the system will use a squared
		/// version of the original file with the smaller of width or height as the square size.
		/// 
		/// The original image as uploaded into the system is always retained unmodified and available through
		/// the style `original`. All media asset styles except `stripped-original` consist of the cropped image.
		/// 
		/// An image has media assets with the following styles:
		/// 
		/// - `original`: This is the original file provided. May not be available, depending on permissions
		/// and file type.
		/// - `stripped-original`: The original file with all metadata (EXIF, XMP, PNG metadata, etc.) removed.
		/// This should be used for any application needing the original, uncropped, image.
		/// - `regular`: If the image has cropping defined, this is the cropped image.
		/// If not, this is a square version of the original.
		/// - `thumb`: A square thumbnail of the image with a size of `100x100` pixels.
		/// - `square-400`: A square version of the image with a size of `400x400` pixels.
		/// - `square-640`: A square version of the image with a size of `640x640` pixels.
		/// - `square-888`: A square version of the image with a size of `888x888` pixels.
		/// - `square-3000`: A square version of the image with a size of `3000x3000` pixels.
		/// This variant is only created if the cropped width & height are each at least 3000.
		/// - `itunes`: A square version of the image with a size of `1400x1400` pixels.
		/// 
		/// ### Preferred image used in feeds
		/// 
		/// For the main series image used in feeds, it is ideal to use the `square-3000` version.
		/// If that is not available, the `itunes` version should be used instead.
		/// 
		/// 
		/// Images_idGet images/{id}
		/// </summary>
		/// <param name="id">The ID of the image resource to load.</param>
		/// <returns>Success</returns>
		public async Task Images_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of media assets
		/// A media asset is part of a collection of assets or files representing an image or a piece of audio content
		/// like an episode or an ad. Images, for example, have differently sized versions for better rendering performance,
		/// and a piece of audio content usually comes in different encoding formats.
		/// 
		/// The `style` attribute of a media asset describes the role an asset plays in the context of the collection.
		/// The collection is what an asset is attached to (`attachment_id|type`).
		/// 
		/// ## Styles for Images
		/// 
		/// Most media assets use square images. You may upload and use a square image, or upload an image of any
		/// shape and crop it to a square by specifying the cropping area. This area  identified by a coordinate
		/// `x, y` and a `width` & `height`  is the portion of the image used for all cover art. If an image has
		/// cropping defined, the cropped version of the image will be used in any `regular` or `square` style of media
		/// asset. If the original file is rectangular and does not have cropping, then the system will use a squared
		/// version of the original file with the smaller of width or height as the square size.
		/// 
		/// The original image as uploaded into the system is always retained unmodified and available through
		/// the style `original`. All media asset styles except `stripped-original` consist of the cropped image.
		/// 
		/// An image has media assets with the following styles:
		/// 
		/// - `original`: This is the original file provided. May not be available, depending on permissions
		/// and file type.
		/// - `stripped-original`: The original file with all metadata (EXIF, XMP, PNG metadata, etc.) removed.
		/// This should be used for any application needing the original, uncropped, image.
		/// - `regular`: If the image has cropping defined, this is the cropped image.
		/// If not, this is a square version of the original.
		/// - `thumb`: A square thumbnail of the image with a size of `100x100` pixels.
		/// - `square-400`: A square version of the image with a size of `400x400` pixels.
		/// - `square-640`: A square version of the image with a size of `640x640` pixels.
		/// - `square-888`: A square version of the image with a size of `888x888` pixels.
		/// - `square-3000`: A square version of the image with a size of `3000x3000` pixels.
		/// This variant is only created if the cropped width & height are each at least 3000.
		/// - `itunes`: A square version of the image with a size of `1400x1400` pixels.
		/// 
		/// ### Preferred image used in feeds
		/// 
		/// For the main series image used in feeds, it is ideal to use the `square-3000` version.
		/// If that is not available, the `itunes` version should be used instead.
		/// 
		/// 
		/// ## Styles for Audio
		/// 
		/// - `medium`: A medium-quality version of the audio asset in various formats.
		/// - `original`: This is the original file provided. May not be available, depending on permissions
		/// and file type.
		/// - `waveform_data`: The generated BBC Audiowaveform data in JSON or binary format.
		/// 
		/// 
		/// Media_assetsGetByIds_ media_assets
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <returns>Success</returns>
		public async Task Media_assetsGetByIds_Async(string[] ids_, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "media_assets?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific media asset
		/// A media asset is part of a collection of assets or files representing an image or a piece of audio content
		/// like an episode or an ad. Images, for example, have differently sized versions for better rendering performance,
		/// and a piece of audio content usually comes in different encoding formats.
		/// 
		/// The `style` attribute of a media asset describes the role an asset plays in the context of the collection.
		/// The collection is what an asset is attached to (`attachment_id|type`).
		/// 
		/// ## Styles for Images
		/// 
		/// Most media assets use square images. You may upload and use a square image, or upload an image of any
		/// shape and crop it to a square by specifying the cropping area. This area  identified by a coordinate
		/// `x, y` and a `width` & `height`  is the portion of the image used for all cover art. If an image has
		/// cropping defined, the cropped version of the image will be used in any `regular` or `square` style of media
		/// asset. If the original file is rectangular and does not have cropping, then the system will use a squared
		/// version of the original file with the smaller of width or height as the square size.
		/// 
		/// The original image as uploaded into the system is always retained unmodified and available through
		/// the style `original`. All media asset styles except `stripped-original` consist of the cropped image.
		/// 
		/// An image has media assets with the following styles:
		/// 
		/// - `original`: This is the original file provided. May not be available, depending on permissions
		/// and file type.
		/// - `stripped-original`: The original file with all metadata (EXIF, XMP, PNG metadata, etc.) removed.
		/// This should be used for any application needing the original, uncropped, image.
		/// - `regular`: If the image has cropping defined, this is the cropped image.
		/// If not, this is a square version of the original.
		/// - `thumb`: A square thumbnail of the image with a size of `100x100` pixels.
		/// - `square-400`: A square version of the image with a size of `400x400` pixels.
		/// - `square-640`: A square version of the image with a size of `640x640` pixels.
		/// - `square-888`: A square version of the image with a size of `888x888` pixels.
		/// - `square-3000`: A square version of the image with a size of `3000x3000` pixels.
		/// This variant is only created if the cropped width & height are each at least 3000.
		/// - `itunes`: A square version of the image with a size of `1400x1400` pixels.
		/// 
		/// ### Preferred image used in feeds
		/// 
		/// For the main series image used in feeds, it is ideal to use the `square-3000` version.
		/// If that is not available, the `itunes` version should be used instead.
		/// 
		/// 
		/// ## Styles for Audio
		/// 
		/// - `medium`: A medium-quality version of the audio asset in various formats.
		/// - `original`: This is the original file provided. May not be available, depending on permissions
		/// and file type.
		/// - `waveform_data`: The generated BBC Audiowaveform data in JSON or binary format.
		/// 
		/// 
		/// Media_assets_idGet media_assets/{id}
		/// </summary>
		/// <param name="id">The ID of the media asset resource to load.</param>
		/// <returns>Success</returns>
		public async Task Media_assets_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "media_assets/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of networks
		/// ### Deprecations
		/// 
		/// - The attribute `cover_image_id` has been replaced with the relationship `cover_image`
		/// and will be removed from the response in a future release.
		/// 
		/// NetworksGetByIds_AndPage_numberAndPage_sizeAndQAndAd_rep_account_idAndAd_deal_statusAndSort networks
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <param name="page_number">Select which page number to receive results for. Pages are numbered starting at 1.
		///
		///
		/// Minimum: 1
		// </param>
		/// <param name="page_size">Indicate how many records to return per page. The maximum is 100.
		///
		///
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="q">Limit the result to networks with a name containing this parameter in a case-insensitive way.</param>
		/// <param name="ad_rep_account_id">Limit the result to networks containing at least one series with an ad deal of this Ad Ops profile.
		///</param>
		/// <param name="ad_deal_status">Limit the result to networks containing at least one series with an ad deal matching one of the
		///values in this parameter.
		///</param>
		/// <param name="sort">Specify how to sort the result. Please refer to either the top section or the
		///[JSON:API specification](https://jsonapi.org/format/#fetching-sorting) on how sorting works in general.
		///</param>
		/// <returns>Success</returns>
		public async Task NetworksGetByIds_AndPage_numberAndPage_sizeAndQAndAd_rep_account_idAndAd_deal_statusAndSortAsync(string[] ids_, int page_number, int page_size, string q, string ad_rep_account_id, string[] ad_deal_status, string[] sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"))+"&page[number]="+page_number+"&page[size]="+page_size+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&ad_rep_account_id=" + (ad_rep_account_id==null? "" : System.Uri.EscapeDataString(ad_rep_account_id))+"&"+string.Join("&", ad_deal_status.Select(z => $"ad_deal_status={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific network
		/// ### Deprecations
		/// 
		/// - The attribute `cover_image_id` has been replaced with the relationship `cover_image`
		/// and will be removed from the response in a future release.
		/// 
		/// Networks_idGet networks/{id}
		/// </summary>
		/// <param name="id">The ID of the network resource to load.</param>
		/// <returns>Success</returns>
		public async Task Networks_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of people
		/// Each series, season, and episode has a Credits section where you may add people and roles.
		/// This is an internal tool to recognize contributors. It is not related to ART19 users or account permissions.
		/// Each Person added will have no additional access or permissions granted as a result of being included in the Credits section.
		/// 
		/// PeopleGetByIds_AndPage_numberAndPage_sizeAndQAndSort people
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <param name="page_number">Select which page number to receive results for. Pages are numbered starting at 1.
		///
		///
		/// Minimum: 1
		// </param>
		/// <param name="page_size">Indicate how many records to return per page. The maximum is 100.
		///
		///
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="q">Limit the result to people with a full name containing this parameter in a case-insensitive way.</param>
		/// <param name="sort">Specify how to sort the result. Please refer to either the top section or the
		///[JSON:API specification](https://jsonapi.org/format/#fetching-sorting) on how sorting works in general.
		///</param>
		/// <returns>Success</returns>
		public async Task PeopleGetByIds_AndPage_numberAndPage_sizeAndQAndSortAsync(string[] ids_, int page_number, int page_size, string q, string[] sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "people?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"))+"&page[number]="+page_number+"&page[size]="+page_size+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific person
		/// Each series, season, and episode has a Credits section where you may add people and roles.
		/// This is an internal tool to recognize contributors. It is not related to ART19 users or account permissions.
		/// Each Person added will have no additional access or permissions granted as a result of being included in the Credits section.
		/// 
		/// People_idGet people/{id}
		/// </summary>
		/// <param name="id">The ID of the person resource to load.</param>
		/// <returns>Success</returns>
		public async Task People_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "people/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of seasons
		/// When retrieving a list of seasons, the result is automatically filtered depending on the
		/// privileges the used credential holds. If there are no specific privileges to a series or network,
		/// only active seasons for active series are included.
		/// 
		/// SeasonsGetByIds_AndPage_numberAndPage_sizeAndSeries_idAndQAndSort seasons
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <param name="page_number">Select which page number to receive results for. Pages are numbered starting at 1.
		///
		///
		/// Minimum: 1
		// </param>
		/// <param name="page_size">Indicate how many records to return per page. The maximum is 100.
		///
		///
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="series_id">Limit the result to seasons owned by this series.</param>
		/// <param name="q">Limit the result to seasons with a title containing this parameter in a case-insensitive way.</param>
		/// <param name="sort">Specify how to sort the result. Please refer to either the top section or the
		///[JSON:API specification](https://jsonapi.org/format/#fetching-sorting) on how sorting works in general.
		///</param>
		/// <returns>Success</returns>
		public async Task SeasonsGetByIds_AndPage_numberAndPage_sizeAndSeries_idAndQAndSortAsync(string[] ids_, int page_number, int page_size, string series_id, string q, string[] sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "seasons?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"))+"&page[number]="+page_number+"&page[size]="+page_size+"&series_id=" + (series_id==null? "" : System.Uri.EscapeDataString(series_id))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific season
		/// Seasons_idGet seasons/{id}
		/// </summary>
		/// <param name="id">The ID of the season resource to load.</param>
		/// <returns>Success</returns>
		public async Task Seasons_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "seasons/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a list of series
		/// When retrieving a list of series, the result is automatically filtered depending on the
		/// privileges the used credential holds. All credentials will have access to active series
		/// with a public page enabled (on ART19). Utilizing a filter to limit the result to series
		/// associated with your account is recommended.
		/// 
		/// SeriesGetByIds_AndPage_numberAndPage_sizeAndAd_rep_account_idAndNetwork_idAndQAndSort series
		/// </summary>
		/// <param name="ids_">The list of IDs to filter by. Repeat this parameter for each ID you want to include in the filter.
		///The brackets *MUST* be percent-encoded, per the requirements in
		///[RFC 3986  3.4](https://tools.ietf.org/html/rfc3986#section-3.4).
		///</param>
		/// <param name="page_number">Select which page number to receive results for. Pages are numbered starting at 1.
		///
		///
		/// Minimum: 1
		// </param>
		/// <param name="page_size">Indicate how many records to return per page. The maximum is 100.
		///
		///
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="ad_rep_account_id">Limit the result to series with an ad deal of this Ad Ops profile.
		///</param>
		/// <param name="network_id">Limit the result to series owned by this network.</param>
		/// <param name="q">Limit the result to series with a title or slug containing this parameter in a case-insensitive way.</param>
		/// <param name="sort">Specify how to sort the result. Please refer to either the top section or the
		///[JSON:API specification](https://jsonapi.org/format/#fetching-sorting) on how sorting works in general.
		///</param>
		/// <returns>Success</returns>
		public async Task SeriesGetByIds_AndPage_numberAndPage_sizeAndAd_rep_account_idAndNetwork_idAndQAndSortAsync(string[] ids_, int page_number, int page_size, string ad_rep_account_id, string network_id, string q, string[] sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series?"+string.Join("&", ids_.Select(z => $"ids[]={System.Uri.EscapeDataString(z.ToString())}"))+"&page[number]="+page_number+"&page[size]="+page_size+"&ad_rep_account_id=" + (ad_rep_account_id==null? "" : System.Uri.EscapeDataString(ad_rep_account_id))+"&network_id=" + (network_id==null? "" : System.Uri.EscapeDataString(network_id))+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get a specific series
		/// Series_idGet series/{id}
		/// </summary>
		/// <param name="id">The ID of the series resource to load.</param>
		/// <returns>Success</returns>
		public async Task Series_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "series/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
