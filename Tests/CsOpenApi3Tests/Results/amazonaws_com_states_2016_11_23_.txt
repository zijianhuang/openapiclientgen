//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateActivityOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activityArn")]
		public string ActivityArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateActivityInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
	}
	
	/// <summary>
	/// <p>Tags are key-value pairs that can be associated with Step Functions state machines and activities.</p> <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a> in the <i>Amazon Web Services Billing and Cost Management User Guide</i>, and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html">Controlling Access Using IAM Tags</a>.</p> <p>Tags may only contain Unicode letters, digits, white space, or these symbols: <code>_ . : / = + - @</code>.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityLimitExceeded
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidName
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyTags
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateStateMachineOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateStateMachineInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roleArn")]
		public string RoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public StateMachineType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="loggingConfiguration")]
		public LoggingConfiguration LoggingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tracingConfiguration")]
		public TracingConfiguration TracingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="publish")]
		public System.Nullable<System.Boolean> Publish { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="versionDescription")]
		public string VersionDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum StateMachineType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPRESS = 1,
	}
	
	/// <summary>
	/// The <code>LoggingConfiguration</code> data type is used to set CloudWatch Logs options.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LoggingConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="level")]
		public LogLevel Level { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="includeExecutionData")]
		public System.Nullable<System.Boolean> IncludeExecutionData { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinations")]
		public LogDestination[] Destinations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LogLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FATAL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFF = 3,
	}
	
	/// <summary>
	/// <p/>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogDestination
	{
		
		[System.Runtime.Serialization.DataMember(Name="cloudWatchLogsLogGroup")]
		public CloudWatchLogsLogGroup CloudWatchLogsLogGroup { get; set; }
	}
	
	/// <summary>
	/// <p/>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudWatchLogsLogGroup
	{
		
		[System.Runtime.Serialization.DataMember(Name="logGroupArn")]
		public string LogGroupArn { get; set; }
	}
	
	/// <summary>
	/// Selects whether or not the state machine's X-Ray tracing is enabled. Default is <code>false</code> 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TracingConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidArn
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidDefinition
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidLoggingConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidTracingConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateMachineAlreadyExists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateMachineDeleting
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateMachineLimitExceeded
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateMachineTypeNotSupported
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateStateMachineAliasOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateStateMachineAliasInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routingConfiguration")]
		public RoutingConfigurationListItem[] RoutingConfiguration { get; set; }
	}
	
	/// <summary>
	/// Contains details about the routing configuration of a state machine alias. In a routing configuration, you define an array of objects that specify up to two state machine versions. You also specify the percentage of traffic to be routed to each version.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoutingConfigurationListItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public int Weight { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceNotFound
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceQuotaExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteActivityOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteActivityInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activityArn")]
		public string ActivityArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteStateMachineOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteStateMachineInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteStateMachineAliasOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteStateMachineAliasInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteStateMachineVersionOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteStateMachineVersionInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeActivityOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activityArn")]
		public string ActivityArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeActivityInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activityArn")]
		public string ActivityArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityDoesNotExist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeExecutionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ExecutionStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public System.DateTimeOffset StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stopDate")]
		public System.DateTimeOffset StopDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
		
		/// <summary>
		/// Provides details about execution input or output.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputDetails")]
		public CloudWatchEventsExecutionDataDetails InputDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
		
		/// <summary>
		/// Provides details about execution input or output.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputDetails")]
		public CloudWatchEventsExecutionDataDetails OutputDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="traceHeader")]
		public string TraceHeader { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ExecutionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIMED_OUT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 4,
	}
	
	/// <summary>
	/// Provides details about execution input or output.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudWatchEventsExecutionDataDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="included")]
		public System.Nullable<System.Boolean> Included { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeExecutionInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionDoesNotExist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeMapRunOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public MapRunStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public System.DateTimeOffset StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stopDate")]
		public System.DateTimeOffset StopDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxConcurrency")]
		public int MaxConcurrency { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="toleratedFailurePercentage")]
		public float ToleratedFailurePercentage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="toleratedFailureCount")]
		public int ToleratedFailureCount { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="itemCounts")]
		public MapRunItemCounts ItemCounts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionCounts")]
		public MapRunExecutionCounts ExecutionCounts { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MapRunStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 3,
	}
	
	/// <summary>
	/// Contains details about items that were processed in all of the child workflow executions that were started by a Map Run.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapRunItemCounts
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pending")]
		public int Pending { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="running")]
		public int Running { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="succeeded")]
		public int Succeeded { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failed")]
		public int Failed { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timedOut")]
		public int TimedOut { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="aborted")]
		public int Aborted { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resultsWritten")]
		public int ResultsWritten { get; set; }
	}
	
	/// <summary>
	/// Contains details about all of the child workflow executions started by a Map Run.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapRunExecutionCounts
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pending")]
		public int Pending { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="running")]
		public int Running { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="succeeded")]
		public int Succeeded { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failed")]
		public int Failed { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timedOut")]
		public int TimedOut { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="aborted")]
		public int Aborted { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total")]
		public int Total { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resultsWritten")]
		public int ResultsWritten { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeMapRunInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeStateMachineOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public StateMachineStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roleArn")]
		public string RoleArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public StateMachineType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
		
		/// <summary>
		/// The <code>LoggingConfiguration</code> data type is used to set CloudWatch Logs options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loggingConfiguration")]
		public LoggingConfiguration LoggingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tracingConfiguration")]
		public TracingConfiguration TracingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		public string RevisionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum StateMachineStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeStateMachineInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateMachineDoesNotExist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeStateMachineAliasOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="routingConfiguration")]
		public RoutingConfigurationListItem[] RoutingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updateDate")]
		public System.DateTimeOffset UpdateDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeStateMachineAliasInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeStateMachineForExecutionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="roleArn")]
		public string RoleArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updateDate")]
		public System.DateTimeOffset UpdateDate { get; set; }
		
		/// <summary>
		/// The <code>LoggingConfiguration</code> data type is used to set CloudWatch Logs options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loggingConfiguration")]
		public LoggingConfiguration LoggingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tracingConfiguration")]
		public TracingConfiguration TracingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		public string RevisionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeStateMachineForExecutionInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetActivityTaskOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="taskToken")]
		public string TaskToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetActivityTaskInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activityArn")]
		public string ActivityArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="workerName")]
		public string WorkerName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityWorkerLimitExceeded
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetExecutionHistoryOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="events")]
		public HistoryEvent[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains details about the events of an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HistoryEvent
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.DateTimeOffset Timestamp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public HistoryEventType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previousEventId")]
		public System.Nullable<System.Int32> PreviousEventId { get; set; }
		
		/// <summary>
		/// Contains details about an activity that failed during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activityFailedEventDetails")]
		public ActivityFailedEventDetails ActivityFailedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="activityScheduleFailedEventDetails")]
		public ActivityScheduleFailedEventDetails ActivityScheduleFailedEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about an activity scheduled during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activityScheduledEventDetails")]
		public ActivityScheduledEventDetails ActivityScheduledEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about the start of an activity during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activityStartedEventDetails")]
		public ActivityStartedEventDetails ActivityStartedEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about an activity that successfully terminated during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activitySucceededEventDetails")]
		public ActivitySucceededEventDetails ActivitySucceededEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about an activity timeout that occurred during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activityTimedOutEventDetails")]
		public ActivityTimedOutEventDetails ActivityTimedOutEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskFailedEventDetails")]
		public TaskFailedEventDetails TaskFailedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskScheduledEventDetails")]
		public TaskScheduledEventDetails TaskScheduledEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskStartFailedEventDetails")]
		public TaskStartFailedEventDetails TaskStartFailedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskStartedEventDetails")]
		public TaskStartedEventDetails TaskStartedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskSubmitFailedEventDetails")]
		public TaskSubmitFailedEventDetails TaskSubmitFailedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskSubmittedEventDetails")]
		public TaskSubmittedEventDetails TaskSubmittedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskSucceededEventDetails")]
		public TaskSucceededEventDetails TaskSucceededEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskTimedOutEventDetails")]
		public TaskTimedOutEventDetails TaskTimedOutEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about an execution failure event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionFailedEventDetails")]
		public ExecutionFailedEventDetails ExecutionFailedEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about the start of the execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionStartedEventDetails")]
		public ExecutionStartedEventDetails ExecutionStartedEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about the successful termination of the execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionSucceededEventDetails")]
		public ExecutionSucceededEventDetails ExecutionSucceededEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about an abort of an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionAbortedEventDetails")]
		public ExecutionAbortedEventDetails ExecutionAbortedEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about the execution timeout that occurred during the execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionTimedOutEventDetails")]
		public ExecutionTimedOutEventDetails ExecutionTimedOutEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapStateStartedEventDetails")]
		public MapStateStartedEventDetails MapStateStartedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapIterationStartedEventDetails")]
		public MapIterationEventDetails MapIterationStartedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapIterationSucceededEventDetails")]
		public MapIterationEventDetails MapIterationSucceededEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapIterationFailedEventDetails")]
		public MapIterationEventDetails MapIterationFailedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapIterationAbortedEventDetails")]
		public MapIterationEventDetails MapIterationAbortedEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about a Lambda function that failed during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionFailedEventDetails")]
		public LambdaFunctionFailedEventDetails LambdaFunctionFailedEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about a failed Lambda function schedule event that occurred during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionScheduleFailedEventDetails")]
		public LambdaFunctionScheduleFailedEventDetails LambdaFunctionScheduleFailedEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about a Lambda function scheduled during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionScheduledEventDetails")]
		public LambdaFunctionScheduledEventDetails LambdaFunctionScheduledEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionStartFailedEventDetails")]
		public LambdaFunctionStartFailedEventDetails LambdaFunctionStartFailedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionSucceededEventDetails")]
		public LambdaFunctionSucceededEventDetails LambdaFunctionSucceededEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about a Lambda function timeout that occurred during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionTimedOutEventDetails")]
		public LambdaFunctionTimedOutEventDetails LambdaFunctionTimedOutEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about a state entered during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateEnteredEventDetails")]
		public StateEnteredEventDetails StateEnteredEventDetails { get; set; }
		
		/// <summary>
		/// Contains details about an exit from a state during an execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateExitedEventDetails")]
		public StateExitedEventDetails StateExitedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapRunStartedEventDetails")]
		public MapRunStartedEventDetails MapRunStartedEventDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapRunFailedEventDetails")]
		public MapRunFailedEventDetails MapRunFailedEventDetails { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HistoryEventType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ActivityFailed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ActivityScheduled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ActivityScheduleFailed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ActivityStarted = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ActivitySucceeded = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ActivityTimedOut = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ChoiceStateEntered = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ChoiceStateExited = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExecutionAborted = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExecutionFailed = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExecutionStarted = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExecutionSucceeded = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ExecutionTimedOut = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FailStateEntered = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LambdaFunctionFailed = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LambdaFunctionScheduled = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LambdaFunctionScheduleFailed = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LambdaFunctionStarted = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LambdaFunctionStartFailed = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LambdaFunctionSucceeded = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LambdaFunctionTimedOut = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapIterationAborted = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapIterationFailed = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapIterationStarted = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapIterationSucceeded = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapStateAborted = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapStateEntered = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapStateExited = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapStateFailed = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapStateStarted = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapStateSucceeded = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ParallelStateAborted = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ParallelStateEntered = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ParallelStateExited = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ParallelStateFailed = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ParallelStateStarted = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ParallelStateSucceeded = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PassStateEntered = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PassStateExited = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SucceedStateEntered = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SucceedStateExited = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskFailed = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskScheduled = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskStarted = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskStartFailed = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskStateAborted = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskStateEntered = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskStateExited = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskSubmitFailed = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskSubmitted = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskSucceeded = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TaskTimedOut = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WaitStateAborted = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WaitStateEntered = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WaitStateExited = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapRunAborted = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapRunFailed = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapRunStarted = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MapRunSucceeded = 58,
	}
	
	/// <summary>
	/// Contains details about an activity that failed during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityFailedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about an activity schedule failure that occurred during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityScheduleFailedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about an activity scheduled during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityScheduledEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="inputDetails")]
		public HistoryEventExecutionDataDetails InputDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeoutInSeconds")]
		public System.Nullable<System.Int32> TimeoutInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="heartbeatInSeconds")]
		public System.Nullable<System.Int32> HeartbeatInSeconds { get; set; }
	}
	
	/// <summary>
	/// Provides details about input or output in an execution history event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HistoryEventExecutionDataDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="truncated")]
		public System.Nullable<System.Boolean> Truncated { get; set; }
	}
	
	/// <summary>
	/// Contains details about the start of an activity during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityStartedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="workerName")]
		public string WorkerName { get; set; }
	}
	
	/// <summary>
	/// Contains details about an activity that successfully terminated during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivitySucceededEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="outputDetails")]
		public HistoryEventExecutionDataDetails OutputDetails { get; set; }
	}
	
	/// <summary>
	/// Contains details about an activity timeout that occurred during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityTimedOutEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about a task failure event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskFailedEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about a task scheduled during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskScheduledEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public string Parameters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeoutInSeconds")]
		public System.Nullable<System.Int32> TimeoutInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="heartbeatInSeconds")]
		public System.Nullable<System.Int32> HeartbeatInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskCredentials")]
		public TaskCredentials TaskCredentials { get; set; }
	}
	
	/// <summary>
	/// Contains details about the credentials that Step Functions uses for a task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskCredentials
	{
		
		[System.Runtime.Serialization.DataMember(Name="roleArn")]
		public string RoleArn { get; set; }
	}
	
	/// <summary>
	/// Contains details about a task that failed to start during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskStartFailedEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about the start of a task during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskStartedEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
	}
	
	/// <summary>
	/// Contains details about a task that failed to submit during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskSubmitFailedEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about a task submitted to a resource .
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskSubmittedEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="outputDetails")]
		public HistoryEventExecutionDataDetails OutputDetails { get; set; }
	}
	
	/// <summary>
	/// Contains details about the successful completion of a task state.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskSucceededEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="outputDetails")]
		public HistoryEventExecutionDataDetails OutputDetails { get; set; }
	}
	
	/// <summary>
	/// Contains details about a resource timeout that occurred during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskTimedOutEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceType")]
		public string ResourceType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about an execution failure event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionFailedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about the start of the execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionStartedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="inputDetails")]
		public HistoryEventExecutionDataDetails InputDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="roleArn")]
		public string RoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
	}
	
	/// <summary>
	/// Contains details about the successful termination of the execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionSucceededEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="outputDetails")]
		public HistoryEventExecutionDataDetails OutputDetails { get; set; }
	}
	
	/// <summary>
	/// Contains details about an abort of an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionAbortedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about the execution timeout that occurred during the execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionTimedOutEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Details about a Map state that was started.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapStateStartedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="length")]
		public System.Nullable<System.Int32> Length { get; set; }
	}
	
	/// <summary>
	/// Contains details about an iteration of a Map state.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapIterationEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Int32> Index { get; set; }
	}
	
	/// <summary>
	/// Contains details about a Lambda function that failed during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaFunctionFailedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about a failed Lambda function schedule event that occurred during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaFunctionScheduleFailedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about a Lambda function scheduled during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaFunctionScheduledEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="inputDetails")]
		public HistoryEventExecutionDataDetails InputDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeoutInSeconds")]
		public System.Nullable<System.Int32> TimeoutInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="taskCredentials")]
		public TaskCredentials TaskCredentials { get; set; }
	}
	
	/// <summary>
	/// Contains details about a lambda function that failed to start during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaFunctionStartFailedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about a Lambda function that successfully terminated during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaFunctionSucceededEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="outputDetails")]
		public HistoryEventExecutionDataDetails OutputDetails { get; set; }
	}
	
	/// <summary>
	/// Contains details about a Lambda function timeout that occurred during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaFunctionTimedOutEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	/// <summary>
	/// Contains details about a state entered during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateEnteredEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="inputDetails")]
		public HistoryEventExecutionDataDetails InputDetails { get; set; }
	}
	
	/// <summary>
	/// Contains details about an exit from a state during an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateExitedEventDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="outputDetails")]
		public HistoryEventExecutionDataDetails OutputDetails { get; set; }
	}
	
	/// <summary>
	/// Contains details about a Map Run that was started during a state machine execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapRunStartedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
	}
	
	/// <summary>
	/// Contains details about a Map Run failure event that occurred during a state machine execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapRunFailedEventDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetExecutionHistoryInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reverseOrder")]
		public System.Nullable<System.Boolean> ReverseOrder { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="includeExecutionData")]
		public System.Nullable<System.Boolean> IncludeExecutionData { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidToken
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListActivitiesOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activities")]
		public ActivityListItem[] Activities { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains details about an activity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivityListItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="activityArn")]
		public string ActivityArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListActivitiesInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListExecutionsOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executions")]
		public ExecutionListItem[] Executions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains details about an execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionListItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ExecutionStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public System.DateTimeOffset StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stopDate")]
		public System.DateTimeOffset StopDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="itemCount")]
		public System.Nullable<System.Int32> ItemCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListExecutionsInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statusFilter")]
		public ExecutionStatus StatusFilter { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListMapRunsOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mapRuns")]
		public MapRunListItem[] MapRuns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains details about a specific Map Run.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapRunListItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public System.DateTimeOffset StartDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stopDate")]
		public System.DateTimeOffset StopDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListMapRunsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListStateMachineAliasesOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliases")]
		public StateMachineAliasListItem[] StateMachineAliases { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains details about a specific state machine alias.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateMachineAliasListItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListStateMachineAliasesInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListStateMachineVersionsOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersions")]
		public StateMachineVersionListItem[] StateMachineVersions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains details about a specific state machine version.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateMachineVersionListItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListStateMachineVersionsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListStateMachinesOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachines")]
		public StateMachineListItem[] StateMachines { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Contains details about the state machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateMachineListItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public StateMachineType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListStateMachinesInput
	{
		
		[System.Runtime.Serialization.DataMember(Name="maxResults")]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceOutput
	{
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublishStateMachineVersionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="creationDate")]
		public System.DateTimeOffset CreationDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublishStateMachineVersionInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		public string RevisionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendTaskFailureOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendTaskFailureInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="taskToken")]
		public string TaskToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskDoesNotExist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskTimedOut
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendTaskHeartbeatOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendTaskHeartbeatInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="taskToken")]
		public string TaskToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendTaskSuccessOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SendTaskSuccessInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="taskToken")]
		public string TaskToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartExecutionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public System.DateTimeOffset StartDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartExecutionInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="traceHeader")]
		public string TraceHeader { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionLimitExceeded
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecutionAlreadyExists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidExecutionInput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartSyncExecutionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startDate")]
		public System.DateTimeOffset StartDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stopDate")]
		public System.DateTimeOffset StopDate { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public SyncExecutionStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
		
		/// <summary>
		/// Provides details about execution input or output.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputDetails")]
		public CloudWatchEventsExecutionDataDetails InputDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="output")]
		public string Output { get; set; }
		
		/// <summary>
		/// Provides details about execution input or output.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputDetails")]
		public CloudWatchEventsExecutionDataDetails OutputDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="traceHeader")]
		public string TraceHeader { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="billingDetails")]
		public BillingDetails BillingDetails { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SyncExecutionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIMED_OUT = 2,
	}
	
	/// <summary>
	/// An object that describes workflow billing details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BillingDetails
	{
		
		[System.Runtime.Serialization.DataMember(Name="billedMemoryUsedInMB")]
		public System.Nullable<System.Int32> BilledMemoryUsedInMB { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="billedDurationInMilliseconds")]
		public System.Nullable<System.Int32> BilledDurationInMilliseconds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartSyncExecutionInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="input")]
		public string Input { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="traceHeader")]
		public string TraceHeader { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StopExecutionOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stopDate")]
		public System.DateTimeOffset StopDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StopExecutionInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="executionArn")]
		public string ExecutionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cause")]
		public string Cause { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceArn")]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tagKeys")]
		public string[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateMapRunOutput
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateMapRunInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mapRunArn")]
		public string MapRunArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxConcurrency")]
		public System.Nullable<System.Int32> MaxConcurrency { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="toleratedFailurePercentage")]
		public float ToleratedFailurePercentage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="toleratedFailureCount")]
		public System.Nullable<System.Int32> ToleratedFailureCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateStateMachineOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updateDate")]
		public System.DateTimeOffset UpdateDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="revisionId")]
		public string RevisionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMachineVersionArn")]
		public string StateMachineVersionArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateStateMachineInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineArn")]
		public string StateMachineArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="roleArn")]
		public string RoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="loggingConfiguration")]
		public LoggingConfiguration LoggingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tracingConfiguration")]
		public TracingConfiguration TracingConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="publish")]
		public System.Nullable<System.Boolean> Publish { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="versionDescription")]
		public string VersionDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MissingRequiredParameter
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateStateMachineAliasOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updateDate")]
		public System.DateTimeOffset UpdateDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateStateMachineAliasInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateMachineAliasArn")]
		public string StateMachineAliasArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="routingConfiguration")]
		public RoutingConfigurationListItem[] RoutingConfiguration { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// <p>Creates an activity. An activity is a task that you write in any programming language and host on any machine that has access to Step Functions. Activities must poll Step Functions using the <code>GetActivityTask</code> API action and respond using <code>SendTask*</code> API actions. This function lets Step Functions know the existence of your activity and returns an identifier for use in a state machine and when polling from the activity.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note> <note> <p> <code>CreateActivity</code> is an idempotent API. Subsequent requests wont create a duplicate resource if it was already created. <code>CreateActivity</code>'s idempotency check is based on the activity <code>name</code>. If a following request has different <code>tags</code> values, Step Functions will ignore these differences and treat it as an idempotent request of the previous. In this case, <code>tags</code> will not be updated, even if they are different.</p> </note>
		/// CreateActivity #X-Amz-Target=AWSStepFunctions.CreateActivity
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateActivityOutput> CreateActivityAsync(CreateActivityInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.CreateActivity";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateActivityOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a state machine. A state machine consists of a collection of states that can do work (<code>Task</code> states), determine to which states to transition next (<code>Choice</code> states), stop an execution with an error (<code>Fail</code> states), and so on. State machines are specified using a JSON-based, structured language. For more information, see <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-amazon-states-language.html">Amazon States Language</a> in the Step Functions User Guide.</p> <p>If you set the <code>publish</code> parameter of this API action to <code>true</code>, it publishes version <code>1</code> as the first revision of the state machine.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note> <note> <p> <code>CreateStateMachine</code> is an idempotent API. Subsequent requests wont create a duplicate resource if it was already created. <code>CreateStateMachine</code>'s idempotency check is based on the state machine <code>name</code>, <code>definition</code>, <code>type</code>, <code>LoggingConfiguration</code>, and <code>TracingConfiguration</code>. The check is also based on the <code>publish</code> and <code>versionDescription</code> parameters. If a following request has a different <code>roleArn</code> or <code>tags</code>, Step Functions will ignore these differences and treat it as an idempotent request of the previous. In this case, <code>roleArn</code> and <code>tags</code> will not be updated, even if they are different.</p> </note>
		/// CreateStateMachine #X-Amz-Target=AWSStepFunctions.CreateStateMachine
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateStateMachineOutput> CreateStateMachineAsync(CreateStateMachineInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.CreateStateMachine";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateStateMachineOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates an <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">alias</a> for a state machine that points to one or two <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">versions</a> of the same state machine. You can set your application to call <a>StartExecution</a> with an alias and update the version the alias uses without changing the client's code.</p> <p>You can also map an alias to split <a>StartExecution</a> requests between two versions of a state machine. To do this, add a second <code>RoutingConfig</code> object in the <code>routingConfiguration</code> parameter. You must also specify the percentage of execution run requests each version should receive in both <code>RoutingConfig</code> objects. Step Functions randomly chooses which version runs a given execution based on the percentage you specify.</p> <p>To create an alias that points to a single version, specify a single <code>RoutingConfig</code> object with a <code>weight</code> set to 100.</p> <p>You can create up to 100 aliases for each state machine. You must delete unused aliases using the <a>DeleteStateMachineAlias</a> API action.</p> <p> <code>CreateStateMachineAlias</code> is an idempotent API. Step Functions bases the idempotency check on the <code>stateMachineArn</code>, <code>description</code>, <code>name</code>, and <code>routingConfiguration</code> parameters. Requests that contain the same values for these parameters return a successful idempotent response without creating a duplicate resource.</p> <p> <b>Related operations:</b> </p> <ul> <li> <p> <a>DescribeStateMachineAlias</a> </p> </li> <li> <p> <a>ListStateMachineAliases</a> </p> </li> <li> <p> <a>UpdateStateMachineAlias</a> </p> </li> <li> <p> <a>DeleteStateMachineAlias</a> </p> </li> </ul>
		/// CreateStateMachineAlias #X-Amz-Target=AWSStepFunctions.CreateStateMachineAlias
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateStateMachineAliasOutput> CreateStateMachineAliasAsync(CreateStateMachineAliasInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.CreateStateMachineAlias";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateStateMachineAliasOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an activity.
		/// DeleteActivity #X-Amz-Target=AWSStepFunctions.DeleteActivity
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteActivityOutput> DeleteActivityAsync(DeleteActivityInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DeleteActivity";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteActivityOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a state machine. This is an asynchronous operation: It sets the state machine's status to <code>DELETING</code> and begins the deletion process. </p> <p>A qualified state machine ARN can either refer to a <i>Distributed Map state</i> defined within a state machine, a version ARN, or an alias ARN.</p> <p>The following are some examples of qualified and unqualified state machine ARNs:</p> <ul> <li> <p>The following qualified state machine ARN refers to a <i>Distributed Map state</i> with a label <code>mapStateLabel</code> in a state machine named <code>myStateMachine</code>.</p> <p> <code>arn:partition:states:region:account-id:stateMachine:myStateMachine/mapStateLabel</code> </p> <note> <p>If you provide a qualified state machine ARN that refers to a <i>Distributed Map state</i>, the request fails with <code>ValidationException</code>.</p> </note> </li> <li> <p>The following unqualified state machine ARN refers to a state machine named <code>myStateMachine</code>.</p> <p> <code>arn:partition:states:region:account-id:stateMachine:myStateMachine</code> </p> </li> </ul> <p>This API action also deletes all <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">versions</a> and <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">aliases</a> associated with a state machine.</p> <note> <p>For <code>EXPRESS</code> state machines, the deletion happens eventually (usually in less than a minute). Running executions may emit logs after <code>DeleteStateMachine</code> API is called.</p> </note>
		/// DeleteStateMachine #X-Amz-Target=AWSStepFunctions.DeleteStateMachine
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteStateMachineOutput> DeleteStateMachineAsync(DeleteStateMachineInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DeleteStateMachine";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteStateMachineOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a state machine <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">alias</a>.</p> <p>After you delete a state machine alias, you can't use it to start executions. When you delete a state machine alias, Step Functions doesn't delete the state machine versions that alias references.</p> <p> <b>Related operations:</b> </p> <ul> <li> <p> <a>CreateStateMachineAlias</a> </p> </li> <li> <p> <a>DescribeStateMachineAlias</a> </p> </li> <li> <p> <a>ListStateMachineAliases</a> </p> </li> <li> <p> <a>UpdateStateMachineAlias</a> </p> </li> </ul>
		/// DeleteStateMachineAlias #X-Amz-Target=AWSStepFunctions.DeleteStateMachineAlias
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteStateMachineAliasOutput> DeleteStateMachineAliasAsync(DeleteStateMachineAliasInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DeleteStateMachineAlias";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteStateMachineAliasOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a state machine <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">version</a>. After you delete a version, you can't call <a>StartExecution</a> using that version's ARN or use the version with a state machine <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">alias</a>.</p> <note> <p>Deleting a state machine version won't terminate its in-progress executions.</p> </note> <note> <p>You can't delete a state machine version currently referenced by one or more aliases. Before you delete a version, you must either delete the aliases or update them to point to another state machine version.</p> </note> <p> <b>Related operations:</b> </p> <ul> <li> <p> <a>PublishStateMachineVersion</a> </p> </li> <li> <p> <a>ListStateMachineVersions</a> </p> </li> </ul>
		/// DeleteStateMachineVersion #X-Amz-Target=AWSStepFunctions.DeleteStateMachineVersion
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteStateMachineVersionOutput> DeleteStateMachineVersionAsync(DeleteStateMachineVersionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DeleteStateMachineVersion";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteStateMachineVersionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Describes an activity.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note>
		/// DescribeActivity #X-Amz-Target=AWSStepFunctions.DescribeActivity
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeActivityOutput> DescribeActivityAsync(DescribeActivityInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DescribeActivity";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeActivityOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Provides information about a state machine execution, such as the state machine associated with the execution, the execution input and output, and relevant execution metadata. Use this API action to return the Map Run Amazon Resource Name (ARN) if the execution was dispatched by a Map Run.</p> <p>If you specify a version or alias ARN when you call the <a>StartExecution</a> API action, <code>DescribeExecution</code> returns that ARN.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note> <p>Executions of an <code>EXPRESS</code> state machinearen't supported by <code>DescribeExecution</code> unless a Map Run dispatched them.</p>
		/// DescribeExecution #X-Amz-Target=AWSStepFunctions.DescribeExecution
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeExecutionOutput> DescribeExecutionAsync(DescribeExecutionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DescribeExecution";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeExecutionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Provides information about a Map Run's configuration, progress, and results. For more information, see <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-examine-map-run.html">Examining Map Run</a> in the <i>Step Functions Developer Guide</i>.
		/// DescribeMapRun #X-Amz-Target=AWSStepFunctions.DescribeMapRun
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeMapRunOutput> DescribeMapRunAsync(DescribeMapRunInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DescribeMapRun";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeMapRunOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Provides information about a state machine's definition, its IAM role Amazon Resource Name (ARN), and configuration.</p> <p>A qualified state machine ARN can either refer to a <i>Distributed Map state</i> defined within a state machine, a version ARN, or an alias ARN.</p> <p>The following are some examples of qualified and unqualified state machine ARNs:</p> <ul> <li> <p>The following qualified state machine ARN refers to a <i>Distributed Map state</i> with a label <code>mapStateLabel</code> in a state machine named <code>myStateMachine</code>.</p> <p> <code>arn:partition:states:region:account-id:stateMachine:myStateMachine/mapStateLabel</code> </p> <note> <p>If you provide a qualified state machine ARN that refers to a <i>Distributed Map state</i>, the request fails with <code>ValidationException</code>.</p> </note> </li> <li> <p>The following qualified state machine ARN refers to an alias named <code>PROD</code>.</p> <p> <code>arn:&lt;partition&gt;:states:&lt;region&gt;:&lt;account-id&gt;:stateMachine:&lt;myStateMachine:PROD&gt;</code> </p> <note> <p>If you provide a qualified state machine ARN that refers to a version ARN or an alias ARN, the request starts execution for that version or alias.</p> </note> </li> <li> <p>The following unqualified state machine ARN refers to a state machine named <code>myStateMachine</code>.</p> <p> <code>arn:&lt;partition&gt;:states:&lt;region&gt;:&lt;account-id&gt;:stateMachine:&lt;myStateMachine&gt;</code> </p> </li> </ul> <p>This API action returns the details for a state machine version if the <code>stateMachineArn</code> you specify is a state machine version ARN.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note>
		/// DescribeStateMachine #X-Amz-Target=AWSStepFunctions.DescribeStateMachine
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeStateMachineOutput> DescribeStateMachineAsync(DescribeStateMachineInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DescribeStateMachine";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeStateMachineOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns details about a state machine <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">alias</a>.</p> <p> <b>Related operations:</b> </p> <ul> <li> <p> <a>CreateStateMachineAlias</a> </p> </li> <li> <p> <a>ListStateMachineAliases</a> </p> </li> <li> <p> <a>UpdateStateMachineAlias</a> </p> </li> <li> <p> <a>DeleteStateMachineAlias</a> </p> </li> </ul>
		/// DescribeStateMachineAlias #X-Amz-Target=AWSStepFunctions.DescribeStateMachineAlias
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeStateMachineAliasOutput> DescribeStateMachineAliasAsync(DescribeStateMachineAliasInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DescribeStateMachineAlias";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeStateMachineAliasOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Provides information about a state machine's definition, its execution role ARN, and configuration. If a Map Run dispatched the execution, this action returns the Map Run Amazon Resource Name (ARN) in the response. The state machine returned is the state machine associated with the Map Run.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note> <p>This API action is not supported by <code>EXPRESS</code> state machines.</p>
		/// DescribeStateMachineForExecution #X-Amz-Target=AWSStepFunctions.DescribeStateMachineForExecution
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeStateMachineForExecutionOutput> DescribeStateMachineForExecutionAsync(DescribeStateMachineForExecutionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.DescribeStateMachineForExecution";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeStateMachineForExecutionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Used by workers to retrieve a task (with the specified activity ARN) which has been scheduled for execution by a running state machine. This initiates a long poll, where the service holds the HTTP connection open and responds as soon as a task becomes available (i.e. an execution of a task of this type is needed.) The maximum time the service holds on to the request before responding is 60 seconds. If no task is available within 60 seconds, the poll returns a <code>taskToken</code> with a null string.</p> <note> <p>This API action isn't logged in CloudTrail.</p> </note> <important> <p>Workers should set their client side socket timeout to at least 65 seconds (5 seconds higher than the maximum time the service may hold the poll request).</p> <p>Polling with <code>GetActivityTask</code> can cause latency in some implementations. See <a href="https://docs.aws.amazon.com/step-functions/latest/dg/bp-activity-pollers.html">Avoid Latency When Polling for Activity Tasks</a> in the Step Functions Developer Guide.</p> </important>
		/// GetActivityTask #X-Amz-Target=AWSStepFunctions.GetActivityTask
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetActivityTaskOutput> GetActivityTaskAsync(GetActivityTaskInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.GetActivityTask";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetActivityTaskOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the history of the specified execution as a list of events. By default, the results are returned in ascending order of the <code>timeStamp</code> of the events. Use the <code>reverseOrder</code> parameter to get the latest events first.</p> <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p> <p>This API action is not supported by <code>EXPRESS</code> state machines.</p>
		/// GetExecutionHistory #X-Amz-Target=AWSStepFunctions.GetExecutionHistory
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<GetExecutionHistoryOutput> GetExecutionHistoryAsync(string maxResults, string nextToken, GetExecutionHistoryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.GetExecutionHistory?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetExecutionHistoryOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the existing activities.</p> <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note>
		/// ListActivities #X-Amz-Target=AWSStepFunctions.ListActivities
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListActivitiesOutput> ListActivitiesAsync(string maxResults, string nextToken, ListActivitiesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.ListActivities?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListActivitiesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all executions of a state machine or a Map Run. You can list all executions related to a state machine by specifying a state machine Amazon Resource Name (ARN), or those related to a Map Run by specifying a Map Run ARN.</p> <p>You can also provide a state machine <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">alias</a> ARN or <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">version</a> ARN to list the executions associated with a specific alias or version.</p> <p>Results are sorted by time, with the most recent execution first.</p> <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note> <p>This API action is not supported by <code>EXPRESS</code> state machines.</p>
		/// ListExecutions #X-Amz-Target=AWSStepFunctions.ListExecutions
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListExecutionsOutput> ListExecutionsAsync(string maxResults, string nextToken, ListExecutionsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.ListExecutions?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListExecutionsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all Map Runs that were started by a given state machine execution. Use this API action to obtain Map Run ARNs, and then call <code>DescribeMapRun</code> to obtain more information, if needed.
		/// ListMapRuns #X-Amz-Target=AWSStepFunctions.ListMapRuns
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListMapRunsOutput> ListMapRunsAsync(string maxResults, string nextToken, ListMapRunsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.ListMapRuns?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListMapRunsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">aliases</a> for a specified state machine ARN. Results are sorted by time, with the most recently created aliases listed first. </p> <p>To list aliases that reference a state machine <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">version</a>, you can specify the version ARN in the <code>stateMachineArn</code> parameter.</p> <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p> <p> <b>Related operations:</b> </p> <ul> <li> <p> <a>CreateStateMachineAlias</a> </p> </li> <li> <p> <a>DescribeStateMachineAlias</a> </p> </li> <li> <p> <a>UpdateStateMachineAlias</a> </p> </li> <li> <p> <a>DeleteStateMachineAlias</a> </p> </li> </ul>
		/// ListStateMachineAliases #X-Amz-Target=AWSStepFunctions.ListStateMachineAliases
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListStateMachineAliasesOutput> ListStateMachineAliasesAsync(ListStateMachineAliasesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.ListStateMachineAliases";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListStateMachineAliasesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">versions</a> for the specified state machine Amazon Resource Name (ARN).</p> <p>The results are sorted in descending order of the version creation time.</p> <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p> <p> <b>Related operations:</b> </p> <ul> <li> <p> <a>PublishStateMachineVersion</a> </p> </li> <li> <p> <a>DeleteStateMachineVersion</a> </p> </li> </ul>
		/// ListStateMachineVersions #X-Amz-Target=AWSStepFunctions.ListStateMachineVersions
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListStateMachineVersionsOutput> ListStateMachineVersionsAsync(ListStateMachineVersionsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.ListStateMachineVersions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListStateMachineVersionsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the existing state machines.</p> <p>If <code>nextToken</code> is returned, there are more results available. The value of <code>nextToken</code> is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an <i>HTTP 400 InvalidToken</i> error.</p> <note> <p>This operation is eventually consistent. The results are best effort and may not reflect very recent updates and changes.</p> </note>
		/// ListStateMachines #X-Amz-Target=AWSStepFunctions.ListStateMachines
		/// </summary>
		/// <param name="maxResults">Pagination limit</param>
		/// <param name="nextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListStateMachinesOutput> ListStateMachinesAsync(string maxResults, string nextToken, ListStateMachinesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.ListStateMachines?maxResults=" + (maxResults==null? "" : System.Uri.EscapeDataString(maxResults))+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListStateMachinesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>List tags for a given resource.</p> <p>Tags may only contain Unicode letters, digits, white space, or these symbols: <code>_ . : / = + - @</code>.</p>
		/// ListTagsForResource #X-Amz-Target=AWSStepFunctions.ListTagsForResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceOutput> ListTagsForResourceAsync(ListTagsForResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.ListTagsForResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">version</a> from the current revision of a state machine. Use versions to create immutable snapshots of your state machine. You can start executions from versions either directly or with an alias. To create an alias, use <a>CreateStateMachineAlias</a>.</p> <p>You can publish up to 1000 versions for each state machine. You must manually delete unused versions using the <a>DeleteStateMachineVersion</a> API action.</p> <p> <code>PublishStateMachineVersion</code> is an idempotent API. It doesn't create a duplicate state machine version if it already exists for the current revision. Step Functions bases <code>PublishStateMachineVersion</code>'s idempotency check on the <code>stateMachineArn</code>, <code>name</code>, and <code>revisionId</code> parameters. Requests with the same parameters return a successful idempotent response. If you don't specify a <code>revisionId</code>, Step Functions checks for a previously published version of the state machine's current revision.</p> <p> <b>Related operations:</b> </p> <ul> <li> <p> <a>DeleteStateMachineVersion</a> </p> </li> <li> <p> <a>ListStateMachineVersions</a> </p> </li> </ul>
		/// PublishStateMachineVersion #X-Amz-Target=AWSStepFunctions.PublishStateMachineVersion
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PublishStateMachineVersionOutput> PublishStateMachineVersionAsync(PublishStateMachineVersionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.PublishStateMachineVersion";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublishStateMachineVersionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Used by activity workers and task states using the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token">callback</a> pattern to report that the task identified by the <code>taskToken</code> failed.
		/// SendTaskFailure #X-Amz-Target=AWSStepFunctions.SendTaskFailure
		/// </summary>
		/// <returns>Success</returns>
		public async Task<SendTaskFailureOutput> SendTaskFailureAsync(SendTaskFailureInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.SendTaskFailure";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SendTaskFailureOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Used by activity workers and task states using the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token">callback</a> pattern to report to Step Functions that the task represented by the specified <code>taskToken</code> is still making progress. This action resets the <code>Heartbeat</code> clock. The <code>Heartbeat</code> threshold is specified in the state machine's Amazon States Language definition (<code>HeartbeatSeconds</code>). This action does not in itself create an event in the execution history. However, if the task times out, the execution history contains an <code>ActivityTimedOut</code> entry for activities, or a <code>TaskTimedOut</code> entry for for tasks using the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-sync">job run</a> or <a href="https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token">callback</a> pattern.</p> <note> <p>The <code>Timeout</code> of a task, defined in the state machine's Amazon States Language definition, is its maximum allowed duration, regardless of the number of <a>SendTaskHeartbeat</a> requests received. Use <code>HeartbeatSeconds</code> to configure the timeout interval for heartbeats.</p> </note>
		/// SendTaskHeartbeat #X-Amz-Target=AWSStepFunctions.SendTaskHeartbeat
		/// </summary>
		/// <returns>Success</returns>
		public async Task<SendTaskHeartbeatOutput> SendTaskHeartbeatAsync(SendTaskHeartbeatInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.SendTaskHeartbeat";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SendTaskHeartbeatOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Used by activity workers and task states using the <a href="https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token">callback</a> pattern to report that the task identified by the <code>taskToken</code> completed successfully.
		/// SendTaskSuccess #X-Amz-Target=AWSStepFunctions.SendTaskSuccess
		/// </summary>
		/// <returns>Success</returns>
		public async Task<SendTaskSuccessOutput> SendTaskSuccessAsync(SendTaskSuccessInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.SendTaskSuccess";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SendTaskSuccessOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Starts a state machine execution.</p> <p>A qualified state machine ARN can either refer to a <i>Distributed Map state</i> defined within a state machine, a version ARN, or an alias ARN.</p> <p>The following are some examples of qualified and unqualified state machine ARNs:</p> <ul> <li> <p>The following qualified state machine ARN refers to a <i>Distributed Map state</i> with a label <code>mapStateLabel</code> in a state machine named <code>myStateMachine</code>.</p> <p> <code>arn:partition:states:region:account-id:stateMachine:myStateMachine/mapStateLabel</code> </p> <note> <p>If you provide a qualified state machine ARN that refers to a <i>Distributed Map state</i>, the request fails with <code>ValidationException</code>.</p> </note> </li> <li> <p>The following qualified state machine ARN refers to an alias named <code>PROD</code>.</p> <p> <code>arn:&lt;partition&gt;:states:&lt;region&gt;:&lt;account-id&gt;:stateMachine:&lt;myStateMachine:PROD&gt;</code> </p> <note> <p>If you provide a qualified state machine ARN that refers to a version ARN or an alias ARN, the request starts execution for that version or alias.</p> </note> </li> <li> <p>The following unqualified state machine ARN refers to a state machine named <code>myStateMachine</code>.</p> <p> <code>arn:&lt;partition&gt;:states:&lt;region&gt;:&lt;account-id&gt;:stateMachine:&lt;myStateMachine&gt;</code> </p> </li> </ul> <p>If you start an execution with an unqualified state machine ARN, Step Functions uses the latest revision of the state machine for the execution.</p> <p>To start executions of a state machine <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">version</a>, call <code>StartExecution</code> and provide the version ARN or the ARN of an <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">alias</a> that points to the version.</p> <note> <p> <code>StartExecution</code> is idempotent for <code>STANDARD</code> workflows. For a <code>STANDARD</code> workflow, if you call <code>StartExecution</code> with the same name and input as a running execution, the call succeeds and return the same response as the original request. If the execution is closed or if the input is different, it returns a <code>400 ExecutionAlreadyExists</code> error. You can reuse names after 90 days. </p> <p> <code>StartExecution</code> isn't idempotent for <code>EXPRESS</code> workflows. </p> </note>
		/// StartExecution #X-Amz-Target=AWSStepFunctions.StartExecution
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartExecutionOutput> StartExecutionAsync(StartExecutionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.StartExecution";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartExecutionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Starts a Synchronous Express state machine execution. <code>StartSyncExecution</code> is not available for <code>STANDARD</code> workflows.</p> <note> <p> <code>StartSyncExecution</code> will return a <code>200 OK</code> response, even if your execution fails, because the status code in the API response doesn't reflect function errors. Error codes are reserved for errors that prevent your execution from running, such as permissions errors, limit errors, or issues with your state machine code and configuration. </p> </note> <note> <p>This API action isn't logged in CloudTrail.</p> </note>
		/// StartSyncExecution #X-Amz-Target=AWSStepFunctions.StartSyncExecution
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartSyncExecutionOutput> StartSyncExecutionAsync(StartSyncExecutionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.StartSyncExecution";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartSyncExecutionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Stops an execution.</p> <p>This API action is not supported by <code>EXPRESS</code> state machines.</p>
		/// StopExecution #X-Amz-Target=AWSStepFunctions.StopExecution
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StopExecutionOutput> StopExecutionAsync(StopExecutionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.StopExecution";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StopExecutionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Add a tag to a Step Functions resource.</p> <p>An array of key-value pairs. For more information, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a> in the <i>Amazon Web Services Billing and Cost Management User Guide</i>, and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_iam-tags.html">Controlling Access Using IAM Tags</a>.</p> <p>Tags may only contain Unicode letters, digits, white space, or these symbols: <code>_ . : / = + - @</code>.</p>
		/// TagResource #X-Amz-Target=AWSStepFunctions.TagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TagResourceOutput> TagResourceAsync(TagResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.TagResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TagResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove a tag from a Step Functions resource
		/// UntagResource #X-Amz-Target=AWSStepFunctions.UntagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UntagResourceOutput> UntagResourceAsync(UntagResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.UntagResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UntagResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an in-progress Map Run's configuration to include changes to the settings that control maximum concurrency and Map Run failure.
		/// UpdateMapRun #X-Amz-Target=AWSStepFunctions.UpdateMapRun
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateMapRunOutput> UpdateMapRunAsync(UpdateMapRunInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.UpdateMapRun";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateMapRunOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Updates an existing state machine by modifying its <code>definition</code>, <code>roleArn</code>, or <code>loggingConfiguration</code>. Running executions will continue to use the previous <code>definition</code> and <code>roleArn</code>. You must include at least one of <code>definition</code> or <code>roleArn</code> or you will receive a <code>MissingRequiredParameter</code> error.</p> <p>A qualified state machine ARN refers to a <i>Distributed Map state</i> defined within a state machine. For example, the qualified state machine ARN <code>arn:partition:states:region:account-id:stateMachine:stateMachineName/mapStateLabel</code> refers to a <i>Distributed Map state</i> with a label <code>mapStateLabel</code> in the state machine named <code>stateMachineName</code>.</p> <p>A qualified state machine ARN can either refer to a <i>Distributed Map state</i> defined within a state machine, a version ARN, or an alias ARN.</p> <p>The following are some examples of qualified and unqualified state machine ARNs:</p> <ul> <li> <p>The following qualified state machine ARN refers to a <i>Distributed Map state</i> with a label <code>mapStateLabel</code> in a state machine named <code>myStateMachine</code>.</p> <p> <code>arn:partition:states:region:account-id:stateMachine:myStateMachine/mapStateLabel</code> </p> <note> <p>If you provide a qualified state machine ARN that refers to a <i>Distributed Map state</i>, the request fails with <code>ValidationException</code>.</p> </note> </li> <li> <p>The following qualified state machine ARN refers to an alias named <code>PROD</code>.</p> <p> <code>arn:&lt;partition&gt;:states:&lt;region&gt;:&lt;account-id&gt;:stateMachine:&lt;myStateMachine:PROD&gt;</code> </p> <note> <p>If you provide a qualified state machine ARN that refers to a version ARN or an alias ARN, the request starts execution for that version or alias.</p> </note> </li> <li> <p>The following unqualified state machine ARN refers to a state machine named <code>myStateMachine</code>.</p> <p> <code>arn:&lt;partition&gt;:states:&lt;region&gt;:&lt;account-id&gt;:stateMachine:&lt;myStateMachine&gt;</code> </p> </li> </ul> <p>After you update your state machine, you can set the <code>publish</code> parameter to <code>true</code> in the same action to publish a new <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-version.html">version</a>. This way, you can opt-in to strict versioning of your state machine.</p> <note> <p>Step Functions assigns monotonically increasing integers for state machine versions, starting at version number 1.</p> </note> <note> <p>All <code>StartExecution</code> calls within a few seconds use the updated <code>definition</code> and <code>roleArn</code>. Executions started immediately after you call <code>UpdateStateMachine</code> may use the previous state machine <code>definition</code> and <code>roleArn</code>. </p> </note>
		/// UpdateStateMachine #X-Amz-Target=AWSStepFunctions.UpdateStateMachine
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateStateMachineOutput> UpdateStateMachineAsync(UpdateStateMachineInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.UpdateStateMachine";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateStateMachineOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Updates the configuration of an existing state machine <a href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-alias.html">alias</a> by modifying its <code>description</code> or <code>routingConfiguration</code>.</p> <p>You must specify at least one of the <code>description</code> or <code>routingConfiguration</code> parameters to update a state machine alias.</p> <note> <p> <code>UpdateStateMachineAlias</code> is an idempotent API. Step Functions bases the idempotency check on the <code>stateMachineAliasArn</code>, <code>description</code>, and <code>routingConfiguration</code> parameters. Requests with the same parameters return an idempotent response.</p> </note> <note> <p>This operation is eventually consistent. All <a>StartExecution</a> requests made within a few seconds use the latest alias configuration. Executions started immediately after calling <code>UpdateStateMachineAlias</code> may use the previous routing configuration.</p> </note> <p> <b>Related operations:</b> </p> <ul> <li> <p> <a>CreateStateMachineAlias</a> </p> </li> <li> <p> <a>DescribeStateMachineAlias</a> </p> </li> <li> <p> <a>ListStateMachineAliases</a> </p> </li> <li> <p> <a>DeleteStateMachineAlias</a> </p> </li> </ul>
		/// UpdateStateMachineAlias #X-Amz-Target=AWSStepFunctions.UpdateStateMachineAlias
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateStateMachineAliasOutput> UpdateStateMachineAliasAsync(UpdateStateMachineAliasInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=AWSStepFunctions.UpdateStateMachineAlias";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateStateMachineAliasOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum CreateActivityX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.CreateActivity")]
		AWSStepFunctions_CreateActivity = 0,
	}
	
	public enum CreateStateMachineX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.CreateStateMachine")]
		AWSStepFunctions_CreateStateMachine = 0,
	}
	
	public enum CreateStateMachineAliasX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.CreateStateMachineAlias")]
		AWSStepFunctions_CreateStateMachineAlias = 0,
	}
	
	public enum DeleteActivityX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DeleteActivity")]
		AWSStepFunctions_DeleteActivity = 0,
	}
	
	public enum DeleteStateMachineX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DeleteStateMachine")]
		AWSStepFunctions_DeleteStateMachine = 0,
	}
	
	public enum DeleteStateMachineAliasX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DeleteStateMachineAlias")]
		AWSStepFunctions_DeleteStateMachineAlias = 0,
	}
	
	public enum DeleteStateMachineVersionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DeleteStateMachineVersion")]
		AWSStepFunctions_DeleteStateMachineVersion = 0,
	}
	
	public enum DescribeActivityX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DescribeActivity")]
		AWSStepFunctions_DescribeActivity = 0,
	}
	
	public enum DescribeExecutionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DescribeExecution")]
		AWSStepFunctions_DescribeExecution = 0,
	}
	
	public enum DescribeMapRunX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DescribeMapRun")]
		AWSStepFunctions_DescribeMapRun = 0,
	}
	
	public enum DescribeStateMachineX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DescribeStateMachine")]
		AWSStepFunctions_DescribeStateMachine = 0,
	}
	
	public enum DescribeStateMachineAliasX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DescribeStateMachineAlias")]
		AWSStepFunctions_DescribeStateMachineAlias = 0,
	}
	
	public enum DescribeStateMachineForExecutionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.DescribeStateMachineForExecution")]
		AWSStepFunctions_DescribeStateMachineForExecution = 0,
	}
	
	public enum GetActivityTaskX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.GetActivityTask")]
		AWSStepFunctions_GetActivityTask = 0,
	}
	
	public enum GetExecutionHistoryX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.GetExecutionHistory")]
		AWSStepFunctions_GetExecutionHistory = 0,
	}
	
	public enum ListActivitiesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.ListActivities")]
		AWSStepFunctions_ListActivities = 0,
	}
	
	public enum ListExecutionsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.ListExecutions")]
		AWSStepFunctions_ListExecutions = 0,
	}
	
	public enum ListMapRunsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.ListMapRuns")]
		AWSStepFunctions_ListMapRuns = 0,
	}
	
	public enum ListStateMachineAliasesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.ListStateMachineAliases")]
		AWSStepFunctions_ListStateMachineAliases = 0,
	}
	
	public enum ListStateMachineVersionsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.ListStateMachineVersions")]
		AWSStepFunctions_ListStateMachineVersions = 0,
	}
	
	public enum ListStateMachinesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.ListStateMachines")]
		AWSStepFunctions_ListStateMachines = 0,
	}
	
	public enum ListTagsForResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.ListTagsForResource")]
		AWSStepFunctions_ListTagsForResource = 0,
	}
	
	public enum PublishStateMachineVersionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.PublishStateMachineVersion")]
		AWSStepFunctions_PublishStateMachineVersion = 0,
	}
	
	public enum SendTaskFailureX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.SendTaskFailure")]
		AWSStepFunctions_SendTaskFailure = 0,
	}
	
	public enum SendTaskHeartbeatX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.SendTaskHeartbeat")]
		AWSStepFunctions_SendTaskHeartbeat = 0,
	}
	
	public enum SendTaskSuccessX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.SendTaskSuccess")]
		AWSStepFunctions_SendTaskSuccess = 0,
	}
	
	public enum StartExecutionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.StartExecution")]
		AWSStepFunctions_StartExecution = 0,
	}
	
	public enum StartSyncExecutionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.StartSyncExecution")]
		AWSStepFunctions_StartSyncExecution = 0,
	}
	
	public enum StopExecutionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.StopExecution")]
		AWSStepFunctions_StopExecution = 0,
	}
	
	public enum TagResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.TagResource")]
		AWSStepFunctions_TagResource = 0,
	}
	
	public enum UntagResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.UntagResource")]
		AWSStepFunctions_UntagResource = 0,
	}
	
	public enum UpdateMapRunX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.UpdateMapRun")]
		AWSStepFunctions_UpdateMapRun = 0,
	}
	
	public enum UpdateStateMachineX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.UpdateStateMachine")]
		AWSStepFunctions_UpdateStateMachine = 0,
	}
	
	public enum UpdateStateMachineAliasX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSStepFunctions.UpdateStateMachineAlias")]
		AWSStepFunctions_UpdateStateMachineAlias = 0,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
