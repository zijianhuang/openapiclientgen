//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchExecuteStatementOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BatchStatementResponse[] Responses { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity[] ConsumedCapacity { get; set; }
	}
	
	/// <summary>
	///  A PartiQL batch statement response.. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchStatementResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BatchStatementError Error { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Item { get; set; }
	}
	
	/// <summary>
	///  An error associated with a statement in a PartiQL batch that was run. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchStatementError
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BatchStatementErrorCodeEnum Code { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Item { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BatchStatementErrorCodeEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ConditionalCheckFailed")]
		ConditionalCheckFailed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ItemCollectionSizeLimitExceeded")]
		ItemCollectionSizeLimitExceeded = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RequestLimitExceeded")]
		RequestLimitExceeded = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ValidationError")]
		ValidationError = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ProvisionedThroughputExceeded")]
		ProvisionedThroughputExceeded = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransactionConflict")]
		TransactionConflict = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ThrottlingError")]
		ThrottlingError = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="InternalServerError")]
		InternalServerError = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ResourceNotFound")]
		ResourceNotFound = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AccessDenied")]
		AccessDenied = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DuplicateItem")]
		DuplicateItem = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeMap
	{
	}
	
	/// <summary>
	/// The capacity units consumed by an operation. The data returned includes the total provisioned throughput consumed, along with statistics for the table and any indexes involved in the operation. <code>ConsumedCapacity</code> is only returned if the request asked for it. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned Throughput</a> in the <i>Amazon DynamoDB Developer Guide</i>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConsumedCapacity
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> CapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> WriteCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Capacity Table { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SecondaryIndexesCapacityMap LocalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SecondaryIndexesCapacityMap GlobalSecondaryIndexes { get; set; }
	}
	
	/// <summary>
	/// Represents the amount of provisioned throughput capacity consumed on a table or an index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Capacity
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> WriteCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> CapacityUnits { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecondaryIndexesCapacityMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchExecuteStatementInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BatchStatementRequest[] Statements { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<BatchExecuteStatementInputReturnConsumedCapacity> ReturnConsumedCapacity { get; set; }
	}
	
	/// <summary>
	///  A PartiQL batch statement request. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchStatementRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Statement { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue[] Parameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	/// <summary>
	/// <p>Represents the data for an attribute.</p> <p>Each attribute value is described as a name-value pair. The name is the data type, and the value is the data itself.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html#HowItWorks.DataTypes">Data Types</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeValue
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string S { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string N { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string B { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SS { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] NS { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] BS { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MapAttributeValue M { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue[] L { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> NULL { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> BOOL { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapAttributeValue
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReturnValuesOnConditionCheckFailure
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL_OLD")]
		ALL_OLD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BatchExecuteStatementInputReturnConsumedCapacity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INDEXES")]
		INDEXES = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TOTAL")]
		TOTAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RequestLimitExceeded
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalServerError
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>BatchGetItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BatchGetResponseMap Responses { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchGetRequestMap UnprocessedKeys { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity[] ConsumedCapacity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetResponseMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetRequestMap
	{
	}
	
	/// <summary>
	/// Represents the input of a <code>BatchGetItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchGetItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BatchGetRequestMap RequestItems { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedThroughputExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceNotFoundException
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>BatchWriteItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchWriteItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BatchWriteItemRequestMap UnprocessedItems { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ItemCollectionMetricsPerTable ItemCollectionMetrics { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity[] ConsumedCapacity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchWriteItemRequestMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ItemCollectionMetricsPerTable
	{
	}
	
	/// <summary>
	/// Represents the input of a <code>BatchWriteItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchWriteItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BatchWriteItemRequestMap RequestItems { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnItemCollectionMetrics ReturnItemCollectionMetrics { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReturnItemCollectionMetrics
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SIZE")]
		SIZE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ItemCollectionSizeLimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateBackupOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BackupDetails BackupDetails { get; set; }
	}
	
	/// <summary>
	/// Contains the details of the backup created for the table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackupDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeBytes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupStatus BackupStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BackupType BackupType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset BackupCreationDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset BackupExpiryDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BackupStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETED")]
		DELETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AVAILABLE")]
		AVAILABLE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BackupType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="USER")]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SYSTEM")]
		SYSTEM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS_BACKUP")]
		AWS_BACKUP = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateBackupInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TableNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TableInUseException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContinuousBackupsUnavailableException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackupInUseException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateGlobalTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalTableDescription GlobalTableDescription { get; set; }
	}
	
	/// <summary>
	/// Contains details about the global table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalTableDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaDescription[] ReplicationGroup { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalTableStatus GlobalTableStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
	}
	
	/// <summary>
	/// Contains the details of the replica.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaStatus ReplicaStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ReplicaStatusDescription { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ReplicaStatusPercentProgress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KMSMasterKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughputOverride ProvisionedThroughputOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaGlobalSecondaryIndexDescription[] GlobalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ReplicaInaccessibleDateTime { get; set; }
		
		/// <summary>
		/// Contains details of the table class.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TableClassSummary ReplicaTableClassSummary { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReplicaStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATION_FAILED")]
		CREATION_FAILED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPDATING")]
		UPDATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REGION_DISABLED")]
		REGION_DISABLED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACCESSIBLE_ENCRYPTION_CREDENTIALS")]
		INACCESSIBLE_ENCRYPTION_CREDENTIALS = 6,
	}
	
	/// <summary>
	/// Replica-specific provisioned throughput settings. If not specified, uses the source table's provisioned throughput settings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedThroughputOverride
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ReadCapacityUnits { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a replica global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaGlobalSecondaryIndexDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughputOverride ProvisionedThroughputOverride { get; set; }
	}
	
	/// <summary>
	/// Contains details of the table class.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TableClassSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableClass TableClass { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastUpdateDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TableClass
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STANDARD")]
		STANDARD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STANDARD_INFREQUENT_ACCESS")]
		STANDARD_INFREQUENT_ACCESS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GlobalTableStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPDATING")]
		UPDATING = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateGlobalTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Replica[] ReplicationGroup { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a replica.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Replica
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalTableAlreadyExistsException
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>CreateTable</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription TableDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TableDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeDefinition[] AttributeDefinitions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableStatus TableStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughputDescription ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TableSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ItemCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingModeSummary BillingModeSummary { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LocalSecondaryIndexDescription[] LocalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalSecondaryIndexDescription[] GlobalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StreamSpecification StreamSpecification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LatestStreamLabel { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LatestStreamArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaDescription[] Replicas { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RestoreSummary RestoreSummary { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSEDescription SSEDescription { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ArchivalSummary ArchivalSummary { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableClassSummary TableClassSummary { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DeletionProtectionEnabled { get; set; }
	}
	
	/// <summary>
	/// Represents an attribute for describing the key schema for the table and indexes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeDefinition
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AttributeName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ScalarAttributeType AttributeType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ScalarAttributeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="S")]
		S = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="N")]
		N = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="B")]
		B = 2,
	}
	
	/// <summary>
	/// <p>Represents <i>a single element</i> of a key schema. A key schema specifies the attributes that make up the primary key of a table, or the key attributes of an index.</p> <p>A <code>KeySchemaElement</code> represents exactly one attribute of the primary key. For example, a simple primary key would be represented by one <code>KeySchemaElement</code> (for the partition key). A composite primary key would require one <code>KeySchemaElement</code> for the partition key, and another <code>KeySchemaElement</code> for the sort key.</p> <p>A <code>KeySchemaElement</code> must be a scalar, top-level attribute (not a nested attribute). The data type must be one of String, Number, or Binary. The attribute cannot be nested within a List or a Map.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeySchemaElement
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AttributeName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeyType KeyType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum KeyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HASH")]
		HASH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RANGE")]
		RANGE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TableStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPDATING")]
		UPDATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACCESSIBLE_ENCRYPTION_CREDENTIALS")]
		INACCESSIBLE_ENCRYPTION_CREDENTIALS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ARCHIVING")]
		ARCHIVING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ARCHIVED")]
		ARCHIVED = 6,
	}
	
	/// <summary>
	/// Represents the provisioned throughput settings for the table, consisting of read and write capacity units, along with data about increases and decreases.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedThroughputDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastIncreaseDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastDecreaseDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfDecreasesToday { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> WriteCapacityUnits { get; set; }
	}
	
	/// <summary>
	/// <p>Contains the details for the read/write capacity mode. This page talks about <code>PROVISIONED</code> and <code>PAY_PER_REQUEST</code> billing modes. For more information about these modes, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html">Read/write capacity mode</a>.</p> <note> <p>You may need to switch to on-demand mode at least once in order to return a <code>BillingModeSummary</code> response.</p> </note>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BillingModeSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BillingMode BillingMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastUpdateToPayPerRequestDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BillingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PROVISIONED")]
		PROVISIONED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PAY_PER_REQUEST")]
		PAY_PER_REQUEST = 1,
	}
	
	/// <summary>
	/// Represents the properties of a local secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalSecondaryIndexDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Projection Projection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ItemCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexArn { get; set; }
	}
	
	/// <summary>
	/// Represents attributes that are copied (projected) from the table into an index. These are in addition to the primary key attributes and index key attributes, which are automatically projected.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Projection
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ProjectionType ProjectionType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] NonKeyAttributes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ProjectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL")]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="KEYS_ONLY")]
		KEYS_ONLY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INCLUDE")]
		INCLUDE = 2,
	}
	
	/// <summary>
	/// Represents the properties of a global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalSecondaryIndexDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Projection Projection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IndexStatus IndexStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Backfilling { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughputDescription ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> IndexSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ItemCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum IndexStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPDATING")]
		UPDATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 3,
	}
	
	/// <summary>
	/// Represents the DynamoDB Streams configuration for a table in DynamoDB.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StreamSpecification
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool StreamEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StreamViewType StreamViewType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum StreamViewType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NEW_IMAGE")]
		NEW_IMAGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OLD_IMAGE")]
		OLD_IMAGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NEW_AND_OLD_IMAGES")]
		NEW_AND_OLD_IMAGES = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="KEYS_ONLY")]
		KEYS_ONLY = 3,
	}
	
	/// <summary>
	/// Contains details for the restore.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RestoreSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceBackupArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceTableArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset RestoreDateTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool RestoreInProgress { get; set; }
	}
	
	/// <summary>
	/// The description of the server-side encryption status on the specified table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SSEDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public SSEStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSEType SSEType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KMSMasterKeyArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset InaccessibleEncryptionDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SSEStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLING")]
		ENABLING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLED")]
		ENABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLING")]
		DISABLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPDATING")]
		UPDATING = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SSEType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AES256")]
		AES256 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="KMS")]
		KMS = 1,
	}
	
	/// <summary>
	/// Contains details of a table archival operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArchivalSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ArchivalDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ArchivalReason { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ArchivalBackupArn { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>CreateTable</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AttributeDefinition[] AttributeDefinitions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LocalSecondaryIndex[] LocalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalSecondaryIndex[] GlobalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingMode BillingMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StreamSpecification StreamSpecification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSESpecification SSESpecification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableClass TableClass { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DeletionProtectionEnabled { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a local secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalSecondaryIndex
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Projection Projection { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalSecondaryIndex
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Projection Projection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
	}
	
	/// <summary>
	/// <p>Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the <code>UpdateTable</code> operation.</p> <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedThroughput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int ReadCapacityUnits { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int WriteCapacityUnits { get; set; }
	}
	
	/// <summary>
	/// Represents the settings used to enable server-side encryption.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SSESpecification
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSEType SSEType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KMSMasterKeyId { get; set; }
	}
	
	/// <summary>
	/// <p>Describes a tag. A tag is a key-value pair. You can add up to 50 tags to a single DynamoDB table. </p> <p>Amazon Web Services-assigned tag names and values are automatically assigned the <code>aws:</code> prefix, which the user cannot assign. Amazon Web Services-assigned tag names do not count towards the tag limit of 50. User-assigned tag names have the prefix <code>user:</code> in the Cost Allocation Report. You cannot backdate the application of a tag.</p> <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceInUseException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteBackupOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BackupDescription BackupDescription { get; set; }
	}
	
	/// <summary>
	/// Contains the description of the backup created for the table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackupDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BackupDetails BackupDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SourceTableDetails SourceTableDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SourceTableFeatureDetails SourceTableFeatureDetails { get; set; }
	}
	
	/// <summary>
	/// Contains the details of the table when the backup was created. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceTableDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TableSizeBytes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset TableCreationDateTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ItemCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingMode BillingMode { get; set; }
	}
	
	/// <summary>
	/// Contains the details of the features enabled on the table when the backup was created. For example, LSIs, GSIs, streams, TTL. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceTableFeatureDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LocalSecondaryIndexInfo[] LocalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalSecondaryIndexInfo[] GlobalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StreamSpecification StreamDescription { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TimeToLiveDescription TimeToLiveDescription { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSEDescription SSEDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a local secondary index for the table when the backup was created.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalSecondaryIndexInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Projection Projection { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a global secondary index for the table when the backup was created.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalSecondaryIndexInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Projection Projection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
	}
	
	/// <summary>
	/// The description of the Time to Live (TTL) status on the specified table. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeToLiveDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TimeToLiveStatus TimeToLiveStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AttributeName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TimeToLiveStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLING")]
		ENABLING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLING")]
		DISABLING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLED")]
		ENABLED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteBackupInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackupNotFoundException
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>DeleteItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity ConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ItemCollectionMetrics ItemCollectionMetrics { get; set; }
	}
	
	/// <summary>
	/// Information about item collections, if any, that were affected by the operation. <code>ItemCollectionMetrics</code> is only returned if the request asked for it. If the table does not have any local secondary indexes, this information is not returned in the response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ItemCollectionMetrics
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ItemCollectionKeyAttributeMap ItemCollectionKey { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> SizeEstimateRangeGB { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ItemCollectionKeyAttributeMap
	{
	}
	
	/// <summary>
	/// Represents the input of a <code>DeleteItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpectedAttributeMap Expected { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConditionalOperator ConditionalOperator { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValue ReturnValues { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnItemCollectionMetrics ReturnItemCollectionMetrics { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConditionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Key
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpectedAttributeMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ConditionalOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AND")]
		AND = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OR")]
		OR = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReturnValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL_OLD")]
		ALL_OLD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPDATED_OLD")]
		UPDATED_OLD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL_NEW")]
		ALL_NEW = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPDATED_NEW")]
		UPDATED_NEW = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpressionAttributeNameMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpressionAttributeValueMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConditionalCheckFailedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactionConflictException
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>DeleteTable</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription TableDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>DeleteTable</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeBackupOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BackupDescription BackupDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeBackupInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeContinuousBackupsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ContinuousBackupsDescription ContinuousBackupsDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the continuous backups and point in time recovery settings on the table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContinuousBackupsDescription
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ContinuousBackupsStatus ContinuousBackupsStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PointInTimeRecoveryDescription PointInTimeRecoveryDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ContinuousBackupsStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLED")]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 1,
	}
	
	/// <summary>
	/// The description of the point in time settings applied to the table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PointInTimeRecoveryDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ContinuousBackupsStatus PointInTimeRecoveryStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EarliestRestorableDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LatestRestorableDateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeContinuousBackupsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeContributorInsightsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ContributorInsightsRuleList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ContributorInsightsStatus ContributorInsightsStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastUpdateDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FailureException FailureException { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ContributorInsightsStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLING")]
		ENABLING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLED")]
		ENABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLING")]
		DISABLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 4,
	}
	
	/// <summary>
	/// Represents a failure a contributor insights operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FailureException
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ExceptionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExceptionDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeContributorInsightsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeEndpointsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Endpoint[] Endpoints { get; set; }
	}
	
	/// <summary>
	/// An endpoint information details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Endpoint
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Address { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int CachePeriodInMinutes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeEndpointsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeExportOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ExportDescription ExportDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of the exported table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ExportArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExportStatus ExportStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExportManifest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ExportTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string S3Bucket { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string S3BucketOwner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string S3Prefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSEType S3SseAlgorithm { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string S3SseKmsKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FailureCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FailureMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExportFormat ExportFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BilledSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ItemCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ExportStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IN_PROGRESS")]
		IN_PROGRESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPLETED")]
		COMPLETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ExportFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DYNAMODB_JSON")]
		DYNAMODB_JSON = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ION")]
		ION = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeExportInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExportArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeGlobalTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalTableDescription GlobalTableDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeGlobalTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalTableNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeGlobalTableSettingsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaSettingsDescription[] ReplicaSettings { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a replica.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaSettingsDescription
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaStatus ReplicaStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingModeSummary ReplicaBillingModeSummary { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ReplicaProvisionedReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsDescription ReplicaProvisionedReadCapacityAutoScalingSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ReplicaProvisionedWriteCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsDescription ReplicaProvisionedWriteCapacityAutoScalingSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaGlobalSecondaryIndexSettingsDescription[] ReplicaGlobalSecondaryIndexSettings { get; set; }
		
		/// <summary>
		/// Contains details of the table class.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public TableClassSummary ReplicaTableClassSummary { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling settings for a global table or global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoScalingSettingsDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinimumUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaximumUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AutoScalingDisabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AutoScalingRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingPolicyDescription[] ScalingPolicies { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of the scaling policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoScalingPolicyDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PolicyName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingTargetTrackingScalingPolicyConfigurationDescription TargetTrackingScalingPolicyConfiguration { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a target tracking scaling policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoScalingTargetTrackingScalingPolicyConfigurationDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DisableScaleIn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScaleInCooldown { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScaleOutCooldown { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public double TargetValue { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaGlobalSecondaryIndexSettingsDescription
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IndexStatus IndexStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProvisionedReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsDescription ProvisionedReadCapacityAutoScalingSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProvisionedWriteCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsDescription ProvisionedWriteCapacityAutoScalingSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeGlobalTableSettingsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeImportOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ImportTableDescription ImportTableDescription { get; set; }
	}
	
	/// <summary>
	///  Represents the properties of the table being imported into. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportTableDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ImportArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ImportStatus ImportStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public S3BucketSource S3BucketSource { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ErrorCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CloudWatchLogGroupArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InputFormat InputFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InputFormatOptions InputFormatOptions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InputCompressionType InputCompressionType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableCreationParameters TableCreationParameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProcessedSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProcessedItemCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ImportedItemCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FailureCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FailureMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImportStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IN_PROGRESS")]
		IN_PROGRESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPLETED")]
		COMPLETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CANCELLING")]
		CANCELLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CANCELLED")]
		CANCELLED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 4,
	}
	
	/// <summary>
	///  The S3 bucket that is being imported from. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class S3BucketSource
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string S3BucketOwner { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string S3Bucket { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string S3KeyPrefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum InputFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DYNAMODB_JSON")]
		DYNAMODB_JSON = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ION")]
		ION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CSV")]
		CSV = 2,
	}
	
	/// <summary>
	///  The format options for the data that was imported into the target table. There is one value, CsvOption.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InputFormatOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CsvOptions Csv { get; set; }
	}
	
	/// <summary>
	///  Processing options for the CSV file being imported. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CsvOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Delimiter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] HeaderList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum InputCompressionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GZIP")]
		GZIP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ZSTD")]
		ZSTD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 2,
	}
	
	/// <summary>
	///  The parameters for the table created as part of the import operation. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TableCreationParameters
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AttributeDefinition[] AttributeDefinitions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingMode BillingMode { get; set; }
		
		/// <summary>
		/// <p>Represents the provisioned throughput settings for a specified table or index. The settings can be modified using the <code>UpdateTable</code> operation.</p> <p>For current minimum and maximum provisioned throughput values, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
		
		/// <summary>
		/// Represents the settings used to enable server-side encryption.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SSESpecification SSESpecification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalSecondaryIndex[] GlobalSecondaryIndexes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeImportInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ImportArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeKinesisStreamingDestinationOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KinesisDataStreamDestination[] KinesisDataStreamDestinations { get; set; }
	}
	
	/// <summary>
	/// Describes a Kinesis data stream destination.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KinesisDataStreamDestination
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DestinationStatus DestinationStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DestinationStatusDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DestinationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLING")]
		ENABLING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLING")]
		DISABLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLE_FAILED")]
		ENABLE_FAILED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeKinesisStreamingDestinationInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a <code>DescribeLimits</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeLimitsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AccountMaxReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> AccountMaxWriteCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TableMaxReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TableMaxWriteCapacityUnits { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>DescribeLimits</code> operation. Has no content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeLimitsInput
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>DescribeTable</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription Table { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>DescribeTable</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeTableReplicaAutoScalingOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableAutoScalingDescription TableAutoScalingDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling configuration for a global table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TableAutoScalingDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableStatus TableStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaAutoScalingDescription[] Replicas { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling settings of the replica.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaAutoScalingDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaGlobalSecondaryIndexAutoScalingDescription[] GlobalSecondaryIndexes { get; set; }
		
		/// <summary>
		/// Represents the auto scaling settings for a global table or global secondary index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsDescription ReplicaProvisionedReadCapacityAutoScalingSettings { get; set; }
		
		/// <summary>
		/// Represents the auto scaling settings for a global table or global secondary index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsDescription ReplicaProvisionedWriteCapacityAutoScalingSettings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaStatus ReplicaStatus { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling configuration for a replica global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaGlobalSecondaryIndexAutoScalingDescription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IndexStatus IndexStatus { get; set; }
		
		/// <summary>
		/// Represents the auto scaling settings for a global table or global secondary index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsDescription ProvisionedReadCapacityAutoScalingSettings { get; set; }
		
		/// <summary>
		/// Represents the auto scaling settings for a global table or global secondary index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsDescription ProvisionedWriteCapacityAutoScalingSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeTableReplicaAutoScalingInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeTimeToLiveOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TimeToLiveDescription TimeToLiveDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeTimeToLiveInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KinesisStreamingDestinationOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StreamArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DestinationStatus DestinationStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KinesisStreamingDestinationInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string StreamArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecuteStatementOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// The capacity units consumed by an operation. The data returned includes the total provisioned throughput consumed, along with statistics for the table and any indexes involved in the operation. <code>ConsumedCapacity</code> is only returned if the request asked for it. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html">Provisioned Throughput</a> in the <i>Amazon DynamoDB Developer Guide</i>.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity ConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key LastEvaluatedKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecuteStatementInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Statement { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue[] Parameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DuplicateItemException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecuteTransactionOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ItemResponse[] Responses { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity[] ConsumedCapacity { get; set; }
	}
	
	/// <summary>
	/// Details for the requested item.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ItemResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Item { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExecuteTransactionInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ParameterizedStatement[] TransactStatements { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
	}
	
	/// <summary>
	///  Represents a PartiQL statment that uses parameters. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ParameterizedStatement
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Statement { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue[] Parameters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactionCanceledException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactionInProgressException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdempotentParameterMismatchException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportTableToPointInTimeOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ExportDescription ExportDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportTableToPointInTimeInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ExportTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string S3Bucket { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string S3BucketOwner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string S3Prefix { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSEType S3SseAlgorithm { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string S3SseKmsKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExportFormat ExportFormat { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PointInTimeRecoveryUnavailableException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidExportTimeException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportConflictException
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>GetItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Item { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity ConsumedCapacity { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>GetItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AttributesToGet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProjectionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportTableOutput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ImportTableDescription ImportTableDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportTableInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public S3BucketSource S3BucketSource { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public InputFormat InputFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InputFormatOptions InputFormatOptions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InputCompressionType InputCompressionType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TableCreationParameters TableCreationParameters { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListBackupsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BackupSummary[] BackupSummaries { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LastEvaluatedBackupArn { get; set; }
	}
	
	/// <summary>
	/// Contains details for the backup.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackupSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BackupName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset BackupCreationDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset BackupExpiryDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupStatus BackupStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupType BackupType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> BackupSizeBytes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListBackupsInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset TimeRangeLowerBound { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset TimeRangeUpperBound { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExclusiveStartBackupArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BackupTypeFilter BackupType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BackupTypeFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="USER")]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SYSTEM")]
		SYSTEM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS_BACKUP")]
		AWS_BACKUP = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL")]
		ALL = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListContributorInsightsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ContributorInsightsSummary[] ContributorInsightsSummaries { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Represents a Contributor Insights summary entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContributorInsightsSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ContributorInsightsStatus ContributorInsightsStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListContributorInsightsInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListExportsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ExportSummary[] ExportSummaries { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Summary information about an export task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExportSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ExportArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExportStatus ExportStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListExportsInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGlobalTablesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalTable[] GlobalTables { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LastEvaluatedGlobalTableName { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a global table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalTable
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Replica[] ReplicationGroup { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGlobalTablesInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ExclusiveStartGlobalTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListImportsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ImportSummary[] ImportSummaryList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	///  Summary information about the source file for the import. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ImportArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ImportStatus ImportStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public S3BucketSource S3BucketSource { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CloudWatchLogGroupArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InputFormat InputFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListImportsInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> PageSize { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a <code>ListTables</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTablesOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] TableNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LastEvaluatedTableName { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>ListTables</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTablesInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ExclusiveStartTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsOfResourceOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsOfResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a <code>PutItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity ConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ItemCollectionMetrics ItemCollectionMetrics { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>PutItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PutItemInputAttributeMap Item { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpectedAttributeMap Expected { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValue ReturnValues { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnItemCollectionMetrics ReturnItemCollectionMetrics { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConditionalOperator ConditionalOperator { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConditionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutItemInputAttributeMap
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>Query</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Count { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScannedCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key LastEvaluatedKey { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity ConsumedCapacity { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>Query</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Select Select { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AttributesToGet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KeyConditions KeyConditions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FilterConditionMap QueryFilter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConditionalOperator ConditionalOperator { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ScanIndexForward { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key ExclusiveStartKey { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProjectionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FilterExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KeyConditionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Select
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL_ATTRIBUTES")]
		ALL_ATTRIBUTES = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL_PROJECTED_ATTRIBUTES")]
		ALL_PROJECTED_ATTRIBUTES = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SPECIFIC_ATTRIBUTES")]
		SPECIFIC_ATTRIBUTES = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COUNT")]
		COUNT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeyConditions
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FilterConditionMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RestoreTableFromBackupOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription TableDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RestoreTableFromBackupInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetTableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BackupArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingMode BillingModeOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalSecondaryIndex[] GlobalSecondaryIndexOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LocalSecondaryIndex[] LocalSecondaryIndexOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughputOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSESpecification SSESpecificationOverride { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TableAlreadyExistsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RestoreTableToPointInTimeOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription TableDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RestoreTableToPointInTimeInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceTableArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceTableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> UseLatestRestorableTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset RestoreDateTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingMode BillingModeOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalSecondaryIndex[] GlobalSecondaryIndexOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LocalSecondaryIndex[] LocalSecondaryIndexOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughputOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSESpecification SSESpecificationOverride { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidRestoreTimeException
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>Scan</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScanOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Count { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScannedCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key LastEvaluatedKey { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity ConsumedCapacity { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>Scan</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScanInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AttributesToGet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Select Select { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FilterConditionMap ScanFilter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConditionalOperator ConditionalOperator { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Key ExclusiveStartKey { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalSegments { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Segment { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProjectionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FilterExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactGetItemsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity[] ConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ItemResponse[] Responses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactGetItemsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TransactGetItem[] TransactItems { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
	}
	
	/// <summary>
	/// Specifies an item to be retrieved as part of the transaction.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactGetItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Get Get { get; set; }
	}
	
	/// <summary>
	/// Specifies an item and related attribute values to retrieve in a <code>TransactGetItem</code> object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Get
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProjectionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactWriteItemsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity[] ConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ItemCollectionMetricsPerTable ItemCollectionMetrics { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactWriteItemsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TransactWriteItem[] TransactItems { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnItemCollectionMetrics ReturnItemCollectionMetrics { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestToken { get; set; }
	}
	
	/// <summary>
	/// A list of requests that can perform update, put, delete, or check operations on multiple items in one or more tables atomically.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TransactWriteItem
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ConditionCheck ConditionCheck { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Put Put { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Delete Delete { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Update Update { get; set; }
	}
	
	/// <summary>
	/// Represents a request to perform a check that an item exists or to check the condition of specific attributes of the item.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConditionCheck
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConditionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	/// <summary>
	/// Represents a request to perform a <code>PutItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Put
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PutItemInputAttributeMap Item { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConditionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	/// <summary>
	/// Represents a request to perform a <code>DeleteItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Delete
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConditionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	/// <summary>
	/// Represents a request to perform an <code>UpdateItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Update
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UpdateExpression { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConditionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResourceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateContinuousBackupsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ContinuousBackupsDescription ContinuousBackupsDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateContinuousBackupsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PointInTimeRecoverySpecification PointInTimeRecoverySpecification { get; set; }
	}
	
	/// <summary>
	/// Represents the settings used to enable point in time recovery.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PointInTimeRecoverySpecification
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool PointInTimeRecoveryEnabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateContributorInsightsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ContributorInsightsStatus ContributorInsightsStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateContributorInsightsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ContributorInsightsAction ContributorInsightsAction { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ContributorInsightsAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLE")]
		ENABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLE")]
		DISABLE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGlobalTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalTableDescription GlobalTableDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGlobalTableInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ReplicaUpdate[] ReplicaUpdates { get; set; }
	}
	
	/// <summary>
	/// <p>Represents one of the following:</p> <ul> <li> <p>A new replica to be added to an existing global table.</p> </li> <li> <p>New parameters for an existing replica.</p> </li> <li> <p>An existing replica to be removed from an existing global table.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CreateReplicaAction Create { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeleteReplicaAction Delete { get; set; }
	}
	
	/// <summary>
	/// Represents a replica to be added.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateReplicaAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
	}
	
	/// <summary>
	/// Represents a replica to be removed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteReplicaAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaAlreadyExistsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGlobalTableSettingsOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaSettingsDescription[] ReplicaSettings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGlobalTableSettingsInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string GlobalTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingMode GlobalTableBillingMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> GlobalTableProvisionedWriteCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsUpdate GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalTableGlobalSecondaryIndexSettingsUpdate[] GlobalTableGlobalSecondaryIndexSettingsUpdate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaSettingsUpdate[] ReplicaSettingsUpdate { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling settings to be modified for a global table or global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoScalingSettingsUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MinimumUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaximumUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> AutoScalingDisabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AutoScalingRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingPolicyUpdate ScalingPolicyUpdate { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling policy to be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoScalingPolicyUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PolicyName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingTargetTrackingScalingPolicyConfigurationUpdate TargetTrackingScalingPolicyConfiguration { get; set; }
	}
	
	/// <summary>
	/// Represents the settings of a target tracking scaling policy that will be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoScalingTargetTrackingScalingPolicyConfigurationUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DisableScaleIn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScaleInCooldown { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ScaleOutCooldown { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public double TargetValue { get; set; }
	}
	
	/// <summary>
	/// Represents the settings of a global secondary index for a global table that will be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalTableGlobalSecondaryIndexSettingsUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProvisionedWriteCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsUpdate ProvisionedWriteCapacityAutoScalingSettingsUpdate { get; set; }
	}
	
	/// <summary>
	/// Represents the settings for a global table in a Region that will be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaSettingsUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ReplicaProvisionedReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsUpdate ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaGlobalSecondaryIndexSettingsUpdate[] ReplicaGlobalSecondaryIndexSettingsUpdate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableClass ReplicaTableClass { get; set; }
	}
	
	/// <summary>
	/// Represents the settings of a global secondary index for a global table that will be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaGlobalSecondaryIndexSettingsUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ProvisionedReadCapacityUnits { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsUpdate ProvisionedReadCapacityAutoScalingSettingsUpdate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IndexNotFoundException
	{
	}
	
	/// <summary>
	/// Represents the output of an <code>UpdateItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateItemOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeMap Attributes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConsumedCapacity ConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ItemCollectionMetrics ItemCollectionMetrics { get; set; }
	}
	
	/// <summary>
	/// Represents the input of an <code>UpdateItem</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateItemInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeUpdates AttributeUpdates { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpectedAttributeMap Expected { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConditionalOperator ConditionalOperator { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValue ReturnValues { get; set; }
		
		/// <summary>
		/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BatchExecuteStatementInputReturnConsumedCapacity ReturnConsumedCapacity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnItemCollectionMetrics ReturnItemCollectionMetrics { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UpdateExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConditionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeValueMap ExpressionAttributeValues { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReturnValuesOnConditionCheckFailure ReturnValuesOnConditionCheckFailure { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeUpdates
	{
	}
	
	/// <summary>
	/// Represents the output of an <code>UpdateTable</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTableOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableDescription TableDescription { get; set; }
	}
	
	/// <summary>
	/// Represents the input of an <code>UpdateTable</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTableInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeDefinition[] AttributeDefinitions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BillingMode BillingMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalSecondaryIndexUpdate[] GlobalSecondaryIndexUpdates { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StreamSpecification StreamSpecification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SSESpecification SSESpecification { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicationGroupUpdate[] ReplicaUpdates { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableClass TableClass { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> DeletionProtectionEnabled { get; set; }
	}
	
	/// <summary>
	/// <p>Represents one of the following:</p> <ul> <li> <p>A new global secondary index to be added to an existing table.</p> </li> <li> <p>New provisioned throughput parameters for an existing global secondary index.</p> </li> <li> <p>An existing global secondary index to be removed from an existing table.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalSecondaryIndexUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateGlobalSecondaryIndexAction Update { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CreateGlobalSecondaryIndexAction Create { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeleteGlobalSecondaryIndexAction Delete { get; set; }
	}
	
	/// <summary>
	/// Represents the new provisioned throughput settings to be applied to a global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGlobalSecondaryIndexAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
	}
	
	/// <summary>
	/// Represents a new global secondary index to be added to an existing table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateGlobalSecondaryIndexAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySchemaElement[] KeySchema { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Projection Projection { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
	}
	
	/// <summary>
	/// Represents a global secondary index to be deleted from an existing table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteGlobalSecondaryIndexAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
	}
	
	/// <summary>
	/// <p>Represents one of the following:</p> <ul> <li> <p>A new replica to be added to an existing regional table or global table. This request invokes the <code>CreateTableReplica</code> action in the destination Region.</p> </li> <li> <p>New parameters for an existing replica. This request invokes the <code>UpdateTable</code> action in the destination Region.</p> </li> <li> <p>An existing replica to be deleted. The request invokes the <code>DeleteTableReplica</code> action in the destination Region, deleting the replica and all if its items in the destination Region.</p> </li> </ul> <note> <p>When you manually remove a table or global table replica, you do not automatically remove any associated scalable targets, scaling policies, or CloudWatch alarms.</p> </note>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicationGroupUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CreateReplicationGroupMemberAction Create { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UpdateReplicationGroupMemberAction Update { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeleteReplicationGroupMemberAction Delete { get; set; }
	}
	
	/// <summary>
	/// Represents a replica to be created.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateReplicationGroupMemberAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KMSMasterKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughputOverride ProvisionedThroughputOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaGlobalSecondaryIndex[] GlobalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableClass TableClassOverride { get; set; }
	}
	
	/// <summary>
	/// Represents the properties of a replica global secondary index.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaGlobalSecondaryIndex
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughputOverride ProvisionedThroughputOverride { get; set; }
	}
	
	/// <summary>
	/// Represents a replica to be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateReplicationGroupMemberAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KMSMasterKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughputOverride ProvisionedThroughputOverride { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaGlobalSecondaryIndex[] GlobalSecondaryIndexes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TableClass TableClassOverride { get; set; }
	}
	
	/// <summary>
	/// Represents a replica to be deleted.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteReplicationGroupMemberAction
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTableReplicaAutoScalingOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TableAutoScalingDescription TableAutoScalingDescription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTableReplicaAutoScalingInput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GlobalSecondaryIndexAutoScalingUpdate[] GlobalSecondaryIndexUpdates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Represents the auto scaling settings to be modified for a global table or global secondary index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsUpdate ProvisionedWriteCapacityAutoScalingUpdate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaAutoScalingUpdate[] ReplicaUpdates { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling settings of a global secondary index for a global table that will be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalSecondaryIndexAutoScalingUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		/// <summary>
		/// Represents the auto scaling settings to be modified for a global table or global secondary index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsUpdate ProvisionedWriteCapacityAutoScalingUpdate { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling settings of a replica that will be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaAutoScalingUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RegionName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ReplicaGlobalSecondaryIndexAutoScalingUpdate[] ReplicaGlobalSecondaryIndexUpdates { get; set; }
		
		/// <summary>
		/// Represents the auto scaling settings to be modified for a global table or global secondary index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsUpdate ReplicaProvisionedReadCapacityAutoScalingUpdate { get; set; }
	}
	
	/// <summary>
	/// Represents the auto scaling settings of a global secondary index for a replica that will be modified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReplicaGlobalSecondaryIndexAutoScalingUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IndexName { get; set; }
		
		/// <summary>
		/// Represents the auto scaling settings to be modified for a global table or global secondary index.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AutoScalingSettingsUpdate ProvisionedReadCapacityAutoScalingUpdate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTimeToLiveOutput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TimeToLiveSpecification TimeToLiveSpecification { get; set; }
	}
	
	/// <summary>
	/// Represents the settings used to enable or disable Time to Live (TTL) for the specified table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TimeToLiveSpecification
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AttributeName { get; set; }
	}
	
	/// <summary>
	/// Represents the input of an <code>UpdateTimeToLive</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTimeToLiveInput
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TimeToLiveSpecification TimeToLiveSpecification { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AttributeAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ADD")]
		ADD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PUT")]
		PUT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETE")]
		DELETE = 2,
	}
	
	/// <summary>
	/// <p>For the <code>UpdateItem</code> operation, represents the attributes to be modified, the action to perform on each, and the new value for each.</p> <note> <p>You cannot use <code>UpdateItem</code> to update any primary key attributes. Instead, you will need to delete the item, and then use <code>PutItem</code> to create a new item with new attributes.</p> </note> <p>Attribute values cannot be null; string and binary type attributes must have lengths greater than zero; and set type attributes must not be empty. Requests with empty values will be rejected with a <code>ValidationException</code> exception.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttributeValueUpdate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue Value { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeAction Action { get; set; }
	}
	
	/// <summary>
	/// <p>Determines the level of detail about either provisioned or on-demand throughput consumption that is returned in the response:</p> <ul> <li> <p> <code>INDEXES</code> - The response includes the aggregate <code>ConsumedCapacity</code> for the operation, together with <code>ConsumedCapacity</code> for each table and secondary index that was accessed.</p> <p>Note that some operations, such as <code>GetItem</code> and <code>BatchGetItem</code>, do not access any indexes at all. In these cases, specifying <code>INDEXES</code> will only return <code>ConsumedCapacity</code> information for table(s).</p> </li> <li> <p> <code>TOTAL</code> - The response includes only the aggregate <code>ConsumedCapacity</code> for the operation.</p> </li> <li> <p> <code>NONE</code> - No <code>ConsumedCapacity</code> details are included in the response.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReturnConsumedCapacity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INDEXES")]
		INDEXES = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TOTAL")]
		TOTAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 2,
	}
	
	/// <summary>
	/// <p>Represents a set of primary keys and, for each key, the attributes to retrieve from the table.</p> <p>For each primary key, you must provide <i>all</i> of the key attributes. For example, with a simple primary key, you only need to provide the partition key. For a composite primary key, you must provide <i>both</i> the partition key and the sort key.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeysAndAttributes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key[] Keys { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AttributesToGet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> ConsistentRead { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProjectionExpression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExpressionAttributeNameMap ExpressionAttributeNames { get; set; }
	}
	
	/// <summary>
	/// Represents an operation to perform - either <code>DeleteItem</code> or <code>PutItem</code>. You can only request one of these operations, not both, in a single <code>WriteRequest</code>. If you do need to perform both of these operations, you need to provide two separate <code>WriteRequest</code> objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WriteRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PutRequest PutRequest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeleteRequest DeleteRequest { get; set; }
	}
	
	/// <summary>
	/// Represents a request to perform a <code>PutItem</code> operation on an item.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PutItemInputAttributeMap Item { get; set; }
	}
	
	/// <summary>
	/// Represents a request to perform a <code>DeleteItem</code> operation on an item.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Key Key { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ComparisonOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="EQ")]
		EQ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NE")]
		NE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IN")]
		IN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LE")]
		LE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LT")]
		LT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GE")]
		GE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GT")]
		GT = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BETWEEN")]
		BETWEEN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NOT_NULL")]
		NOT_NULL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NULL")]
		NULL = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CONTAINS")]
		CONTAINS = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NOT_CONTAINS")]
		NOT_CONTAINS = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BEGINS_WITH")]
		BEGINS_WITH = 12,
	}
	
	/// <summary>
	/// <p>Represents the selection criteria for a <code>Query</code> or <code>Scan</code> operation:</p> <ul> <li> <p>For a <code>Query</code> operation, <code>Condition</code> is used for specifying the <code>KeyConditions</code> to use when querying a table or an index. For <code>KeyConditions</code>, only the following comparison operators are supported:</p> <p> <code>EQ | LE | LT | GE | GT | BEGINS_WITH | BETWEEN</code> </p> <p> <code>Condition</code> is also used in a <code>QueryFilter</code>, which evaluates the query results and returns only the desired values.</p> </li> <li> <p>For a <code>Scan</code> operation, <code>Condition</code> is used in a <code>ScanFilter</code>, which evaluates the scan results and returns only the desired values.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Condition
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue[] AttributeValueList { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ComparisonOperator ComparisonOperator { get; set; }
	}
	
	/// <summary>
	/// <p>Represents a condition to be compared with an attribute value. This condition can be used with <code>DeleteItem</code>, <code>PutItem</code>, or <code>UpdateItem</code> operations; if the comparison evaluates to true, the operation succeeds; if not, the operation fails. You can use <code>ExpectedAttributeValue</code> in one of two different ways:</p> <ul> <li> <p>Use <code>AttributeValueList</code> to specify one or more values to compare against an attribute. Use <code>ComparisonOperator</code> to specify how you want to perform the comparison. If the comparison evaluates to true, then the conditional operation succeeds.</p> </li> <li> <p>Use <code>Value</code> to specify a value that DynamoDB will compare against an attribute. If the values match, then <code>ExpectedAttributeValue</code> evaluates to true and the conditional operation succeeds. Optionally, you can also set <code>Exists</code> to false, indicating that you <i>do not</i> expect to find the attribute value in the table. In this case, the conditional operation succeeds only if the comparison evaluates to false.</p> </li> </ul> <p> <code>Value</code> and <code>Exists</code> are incompatible with <code>AttributeValueList</code> and <code>ComparisonOperator</code>. Note that if you use both sets of parameters at once, DynamoDB will return a <code>ValidationException</code> exception.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExpectedAttributeValue
	{
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue Value { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Exists { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ComparisonOperator ComparisonOperator { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AttributeValue[] AttributeValueList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum S3SseAlgorithm
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AES256")]
		AES256 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="KMS")]
		KMS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PointInTimeRecoveryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ENABLED")]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DISABLED")]
		DISABLED = 1,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// <p>This operation allows you to perform batch reads or writes on data stored in DynamoDB, using PartiQL. Each read statement in a <code>BatchExecuteStatement</code> must specify an equality condition on all key attributes. This enforces that each <code>SELECT</code> statement in a batch returns at most a single item.</p> <note> <p>The entire batch must consist of either read statements or write statements, you cannot mix both in one batch.</p> </note> <important> <p>A HTTP 200 response does not mean that all statements in the BatchExecuteStatement succeeded. Error details for individual statements can be found under the <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchStatementResponse.html#DDB-Type-BatchStatementResponse-Error">Error</a> field of the <code>BatchStatementResponse</code> for each statement.</p> </important>
		/// BatchExecuteStatement #X-Amz-Target=DynamoDB_20120810.BatchExecuteStatement
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchExecuteStatementOutput> BatchExecuteStatementAsync(BatchExecuteStatementInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.BatchExecuteStatement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchExecuteStatementOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>The <code>BatchGetItem</code> operation returns the attributes of one or more items from one or more tables. You identify requested items by primary key.</p> <p>A single operation can retrieve up to 16 MB of data, which can contain as many as 100 items. <code>BatchGetItem</code> returns a partial result if the response size limit is exceeded, the table's provisioned throughput is exceeded, more than 1MB per partition is requested, or an internal processing failure occurs. If a partial result is returned, the operation returns a value for <code>UnprocessedKeys</code>. You can use this value to retry the operation starting with the next item to get.</p> <important> <p>If you request more than 100 items, <code>BatchGetItem</code> returns a <code>ValidationException</code> with the message "Too many items requested for the BatchGetItem call."</p> </important> <p>For example, if you ask to retrieve 100 items, but each individual item is 300 KB in size, the system returns 52 items (so as not to exceed the 16 MB limit). It also returns an appropriate <code>UnprocessedKeys</code> value so you can get the next page of results. If desired, your application can include its own logic to assemble the pages of results into one dataset.</p> <p>If <i>none</i> of the items can be processed due to insufficient provisioned throughput on all of the tables in the request, then <code>BatchGetItem</code> returns a <code>ProvisionedThroughputExceededException</code>. If <i>at least one</i> of the items is successfully processed, then <code>BatchGetItem</code> completes successfully, while returning the keys of the unread items in <code>UnprocessedKeys</code>.</p> <important> <p>If DynamoDB returns any unprocessed items, you should retry the batch operation on those items. However, <i>we strongly recommend that you use an exponential backoff algorithm</i>. If you retry the batch operation immediately, the underlying read or write requests can still fail due to throttling on the individual tables. If you delay the batch operation using exponential backoff, the individual requests in the batch are much more likely to succeed.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOperations">Batch Operations and Error Handling</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p> </important> <p>By default, <code>BatchGetItem</code> performs eventually consistent reads on every table in the request. If you want strongly consistent reads instead, you can set <code>ConsistentRead</code> to <code>true</code> for any or all tables.</p> <p>In order to minimize response latency, <code>BatchGetItem</code> may retrieve items in parallel.</p> <p>When designing your application, keep in mind that DynamoDB does not return items in any particular order. To help parse the response by item, include the primary key values for the items in your request in the <code>ProjectionExpression</code> parameter.</p> <p>If a requested item does not exist, it is not returned in the result. Requests for nonexistent items consume the minimum read capacity units according to the type of read. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#CapacityUnitCalculations">Working with Tables</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
		/// BatchGetItem #X-Amz-Target=DynamoDB_20120810.BatchGetItem
		/// </summary>
		/// <param name="RequestItems">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<BatchGetItemOutput> BatchGetItemAsync(string RequestItems, BatchGetItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.BatchGetItem?RequestItems=" + (RequestItems==null? "" : System.Uri.EscapeDataString(RequestItems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchGetItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>The <code>BatchWriteItem</code> operation puts or deletes multiple items in one or more tables. A single call to <code>BatchWriteItem</code> can transmit up to 16MB of data over the network, consisting of up to 25 item put or delete operations. While individual items can be up to 400 KB once stored, it's important to note that an item's representation might be greater than 400KB while being sent in DynamoDB's JSON format for the API call. For more details on this distinction, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html">Naming Rules and Data Types</a>.</p> <note> <p> <code>BatchWriteItem</code> cannot update items. If you perform a <code>BatchWriteItem</code> operation on an existing item, that item's values will be overwritten by the operation and it will appear like it was updated. To update items, we recommend you use the <code>UpdateItem</code> action.</p> </note> <p>The individual <code>PutItem</code> and <code>DeleteItem</code> operations specified in <code>BatchWriteItem</code> are atomic; however <code>BatchWriteItem</code> as a whole is not. If any requested operations fail because the table's provisioned throughput is exceeded or an internal processing failure occurs, the failed operations are returned in the <code>UnprocessedItems</code> response parameter. You can investigate and optionally resend the requests. Typically, you would call <code>BatchWriteItem</code> in a loop. Each iteration would check for unprocessed items and submit a new <code>BatchWriteItem</code> request with those unprocessed items until all items have been processed.</p> <p>If <i>none</i> of the items can be processed due to insufficient provisioned throughput on all of the tables in the request, then <code>BatchWriteItem</code> returns a <code>ProvisionedThroughputExceededException</code>.</p> <important> <p>If DynamoDB returns any unprocessed items, you should retry the batch operation on those items. However, <i>we strongly recommend that you use an exponential backoff algorithm</i>. If you retry the batch operation immediately, the underlying read or write requests can still fail due to throttling on the individual tables. If you delay the batch operation using exponential backoff, the individual requests in the batch are much more likely to succeed.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#Programming.Errors.BatchOperations">Batch Operations and Error Handling</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p> </important> <p>With <code>BatchWriteItem</code>, you can efficiently write or delete large amounts of data, such as from Amazon EMR, or copy data from another database into DynamoDB. In order to improve performance with these large-scale operations, <code>BatchWriteItem</code> does not behave in the same way as individual <code>PutItem</code> and <code>DeleteItem</code> calls would. For example, you cannot specify conditions on individual put and delete requests, and <code>BatchWriteItem</code> does not return deleted items in the response.</p> <p>If you use a programming language that supports concurrency, you can use threads to write items in parallel. Your application must include the necessary logic to manage the threads. With languages that don't support threading, you must update or delete the specified items one at a time. In both situations, <code>BatchWriteItem</code> performs the specified put and delete operations in parallel, giving you the power of the thread pool approach without having to introduce complexity into your application.</p> <p>Parallel processing reduces latency, but each specified put and delete request consumes the same number of write capacity units whether it is processed in parallel or not. Delete operations on nonexistent items consume one write capacity unit.</p> <p>If one or more of the following is true, DynamoDB rejects the entire batch write operation:</p> <ul> <li> <p>One or more tables specified in the <code>BatchWriteItem</code> request does not exist.</p> </li> <li> <p>Primary key attributes specified on an item in the request do not match those in the corresponding table's primary key schema.</p> </li> <li> <p>You try to perform multiple operations on the same item in the same <code>BatchWriteItem</code> request. For example, you cannot put and delete the same item in the same <code>BatchWriteItem</code> request. </p> </li> <li> <p> Your request contains at least two items with identical hash and range keys (which essentially is two put operations). </p> </li> <li> <p>There are more than 25 requests in the batch.</p> </li> <li> <p>Any individual item in a batch exceeds 400 KB.</p> </li> <li> <p>The total request size exceeds 16 MB.</p> </li> </ul>
		/// BatchWriteItem #X-Amz-Target=DynamoDB_20120810.BatchWriteItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<BatchWriteItemOutput> BatchWriteItemAsync(BatchWriteItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.BatchWriteItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchWriteItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a backup for an existing table.</p> <p> Each time you create an on-demand backup, the entire table data is backed up. There is no limit to the number of on-demand backups that can be taken. </p> <p> When you create an on-demand backup, a time marker of the request is cataloged, and the backup is created asynchronously, by applying all changes until the time of the request to the last full table snapshot. Backup requests are processed instantaneously and become available for restore within minutes. </p> <p>You can call <code>CreateBackup</code> at a maximum rate of 50 times per second.</p> <p>All backups in DynamoDB work without consuming any provisioned throughput on the table.</p> <p> If you submit a backup request on 2018-12-14 at 14:25:00, the backup is guaranteed to contain all data committed to the table up to 14:24:00, and data committed after 14:26:00 will not be. The backup might contain data modifications made between 14:24:00 and 14:26:00. On-demand backup does not support causal consistency. </p> <p> Along with data, the following are also included on the backups: </p> <ul> <li> <p>Global secondary indexes (GSIs)</p> </li> <li> <p>Local secondary indexes (LSIs)</p> </li> <li> <p>Streams</p> </li> <li> <p>Provisioned read and write capacity</p> </li> </ul>
		/// CreateBackup #X-Amz-Target=DynamoDB_20120810.CreateBackup
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateBackupOutput> CreateBackupAsync(CreateBackupInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.CreateBackup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateBackupOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a global table from an existing table. A global table creates a replication relationship between two or more DynamoDB tables with the same table name in the provided Regions. </p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version 2017.11.29 (Legacy)</a> of global tables. We recommend using <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> when creating new global tables, as it provides greater flexibility, higher efficiency and consumes less write capacity than 2017.11.29 (Legacy). To determine which version you are using, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.DetermineVersion.html">Determining the version</a>. To update existing global tables from version 2017.11.29 (Legacy) to version 2019.11.21 (Current), see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_upgrade.html"> Updating global tables</a>. </p> </important> <p>If you want to add a new replica table to a global table, each of the following conditions must be true:</p> <ul> <li> <p>The table must have the same primary key as all of the other replicas.</p> </li> <li> <p>The table must have the same name as all of the other replicas.</p> </li> <li> <p>The table must have DynamoDB Streams enabled, with the stream containing both the new and the old images of the item.</p> </li> <li> <p>None of the replica tables in the global table can contain any data.</p> </li> </ul> <p> If global secondary indexes are specified, then the following conditions must also be met: </p> <ul> <li> <p> The global secondary indexes must have the same name. </p> </li> <li> <p> The global secondary indexes must have the same hash key and sort key (if present). </p> </li> </ul> <p> If local secondary indexes are specified, then the following conditions must also be met: </p> <ul> <li> <p> The local secondary indexes must have the same name. </p> </li> <li> <p> The local secondary indexes must have the same hash key and sort key (if present). </p> </li> </ul> <important> <p> Write capacity settings should be set consistently across your replica tables and secondary indexes. DynamoDB strongly recommends enabling auto scaling to manage the write capacity settings for all of your global tables replicas and indexes. </p> <p> If you prefer to manage write capacity settings manually, you should provision equal replicated write capacity units to your replica tables. You should also provision equal replicated write capacity units to matching secondary indexes across your global table. </p> </important>
		/// CreateGlobalTable #X-Amz-Target=DynamoDB_20120810.CreateGlobalTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateGlobalTableOutput> CreateGlobalTableAsync(CreateGlobalTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.CreateGlobalTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateGlobalTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>The <code>CreateTable</code> operation adds a new table to your account. In an Amazon Web Services account, table names must be unique within each Region. That is, you can have two tables with same name if you create the tables in different Regions.</p> <p> <code>CreateTable</code> is an asynchronous operation. Upon receiving a <code>CreateTable</code> request, DynamoDB immediately returns a response with a <code>TableStatus</code> of <code>CREATING</code>. After the table is created, DynamoDB sets the <code>TableStatus</code> to <code>ACTIVE</code>. You can perform read and write operations only on an <code>ACTIVE</code> table. </p> <p>You can optionally define secondary indexes on the new table, as part of the <code>CreateTable</code> operation. If you want to create multiple tables with secondary indexes on them, you must create the tables sequentially. Only one table with secondary indexes can be in the <code>CREATING</code> state at any given time.</p> <p>You can use the <code>DescribeTable</code> action to check the table status.</p>
		/// CreateTable #X-Amz-Target=DynamoDB_20120810.CreateTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateTableOutput> CreateTableAsync(CreateTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.CreateTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes an existing backup of a table.</p> <p>You can call <code>DeleteBackup</code> at a maximum rate of 10 times per second.</p>
		/// DeleteBackup #X-Amz-Target=DynamoDB_20120810.DeleteBackup
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteBackupOutput> DeleteBackupAsync(DeleteBackupInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DeleteBackup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteBackupOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a single item in a table by primary key. You can perform a conditional delete operation that deletes the item if it exists, or if it has an expected attribute value.</p> <p>In addition to deleting an item, you can also return the item's attribute values in the same operation, using the <code>ReturnValues</code> parameter.</p> <p>Unless you specify conditions, the <code>DeleteItem</code> is an idempotent operation; running it multiple times on the same item or attribute does <i>not</i> result in an error response.</p> <p>Conditional deletes are useful for deleting items only if specific conditions are met. If those conditions are met, DynamoDB performs the delete. Otherwise, the item is not deleted.</p>
		/// DeleteItem #X-Amz-Target=DynamoDB_20120810.DeleteItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteItemOutput> DeleteItemAsync(DeleteItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DeleteItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>The <code>DeleteTable</code> operation deletes a table and all of its items. After a <code>DeleteTable</code> request, the specified table is in the <code>DELETING</code> state until DynamoDB completes the deletion. If the table is in the <code>ACTIVE</code> state, you can delete it. If a table is in <code>CREATING</code> or <code>UPDATING</code> states, then DynamoDB returns a <code>ResourceInUseException</code>. If the specified table does not exist, DynamoDB returns a <code>ResourceNotFoundException</code>. If table is already in the <code>DELETING</code> state, no error is returned. </p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> of global tables. </p> </important> <note> <p>DynamoDB might continue to accept data read and write operations, such as <code>GetItem</code> and <code>PutItem</code>, on a table in the <code>DELETING</code> state until the table deletion is complete.</p> </note> <p>When you delete a table, any indexes on that table are also deleted.</p> <p>If you have DynamoDB Streams enabled on the table, then the corresponding stream on that table goes into the <code>DISABLED</code> state, and the stream is automatically deleted after 24 hours.</p> <p>Use the <code>DescribeTable</code> action to check the status of the table. </p>
		/// DeleteTable #X-Amz-Target=DynamoDB_20120810.DeleteTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DeleteTableOutput> DeleteTableAsync(DeleteTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DeleteTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Describes an existing backup of a table.</p> <p>You can call <code>DescribeBackup</code> at a maximum rate of 10 times per second.</p>
		/// DescribeBackup #X-Amz-Target=DynamoDB_20120810.DescribeBackup
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeBackupOutput> DescribeBackupAsync(DescribeBackupInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeBackup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeBackupOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Checks the status of continuous backups and point in time recovery on the specified table. Continuous backups are <code>ENABLED</code> on all tables at table creation. If point in time recovery is enabled, <code>PointInTimeRecoveryStatus</code> will be set to ENABLED.</p> <p> After continuous backups and point in time recovery are enabled, you can restore to any point in time within <code>EarliestRestorableDateTime</code> and <code>LatestRestorableDateTime</code>. </p> <p> <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time. You can restore your table to any point in time during the last 35 days. </p> <p>You can call <code>DescribeContinuousBackups</code> at a maximum rate of 10 times per second.</p>
		/// DescribeContinuousBackups #X-Amz-Target=DynamoDB_20120810.DescribeContinuousBackups
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeContinuousBackupsOutput> DescribeContinuousBackupsAsync(DescribeContinuousBackupsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeContinuousBackups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeContinuousBackupsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about contributor insights for a given table or global secondary index.
		/// DescribeContributorInsights #X-Amz-Target=DynamoDB_20120810.DescribeContributorInsights
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeContributorInsightsOutput> DescribeContributorInsightsAsync(DescribeContributorInsightsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeContributorInsights";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeContributorInsightsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the regional endpoint information. For more information on policy permissions, please see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/inter-network-traffic-privacy.html#inter-network-traffic-DescribeEndpoints">Internetwork traffic privacy</a>.
		/// DescribeEndpoints #X-Amz-Target=DynamoDB_20120810.DescribeEndpoints
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeEndpointsResponse> DescribeEndpointsAsync(DescribeEndpointsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeEndpoints";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeEndpointsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Describes an existing table export.
		/// DescribeExport #X-Amz-Target=DynamoDB_20120810.DescribeExport
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeExportOutput> DescribeExportAsync(DescribeExportInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeExport";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeExportOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns information about the specified global table.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version 2017.11.29 (Legacy)</a> of global tables. We recommend using <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> when creating new global tables, as it provides greater flexibility, higher efficiency and consumes less write capacity than 2017.11.29 (Legacy). To determine which version you are using, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.DetermineVersion.html">Determining the version</a>. To update existing global tables from version 2017.11.29 (Legacy) to version 2019.11.21 (Current), see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_upgrade.html"> Updating global tables</a>. </p> </important>
		/// DescribeGlobalTable #X-Amz-Target=DynamoDB_20120810.DescribeGlobalTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeGlobalTableOutput> DescribeGlobalTableAsync(DescribeGlobalTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeGlobalTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeGlobalTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Describes Region-specific settings for a global table.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version 2017.11.29 (Legacy)</a> of global tables. We recommend using <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> when creating new global tables, as it provides greater flexibility, higher efficiency and consumes less write capacity than 2017.11.29 (Legacy). To determine which version you are using, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.DetermineVersion.html">Determining the version</a>. To update existing global tables from version 2017.11.29 (Legacy) to version 2019.11.21 (Current), see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_upgrade.html"> Updating global tables</a>. </p> </important>
		/// DescribeGlobalTableSettings #X-Amz-Target=DynamoDB_20120810.DescribeGlobalTableSettings
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeGlobalTableSettingsOutput> DescribeGlobalTableSettingsAsync(DescribeGlobalTableSettingsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeGlobalTableSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeGlobalTableSettingsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Represents the properties of the import.
		/// DescribeImport #X-Amz-Target=DynamoDB_20120810.DescribeImport
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeImportOutput> DescribeImportAsync(DescribeImportInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeImport";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeImportOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns information about the status of Kinesis streaming.
		/// DescribeKinesisStreamingDestination #X-Amz-Target=DynamoDB_20120810.DescribeKinesisStreamingDestination
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeKinesisStreamingDestinationOutput> DescribeKinesisStreamingDestinationAsync(DescribeKinesisStreamingDestinationInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeKinesisStreamingDestination";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeKinesisStreamingDestinationOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the current provisioned-capacity quotas for your Amazon Web Services account in a Region, both for the Region as a whole and for any one DynamoDB table that you create there.</p> <p>When you establish an Amazon Web Services account, the account has initial quotas on the maximum read capacity units and write capacity units that you can provision across all of your DynamoDB tables in a given Region. Also, there are per-table quotas that apply when you create a table there. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html">Service, Account, and Table Quotas</a> page in the <i>Amazon DynamoDB Developer Guide</i>.</p> <p>Although you can increase these quotas by filing a case at <a href="https://console.aws.amazon.com/support/home#/">Amazon Web Services Support Center</a>, obtaining the increase is not instantaneous. The <code>DescribeLimits</code> action lets you write code to compare the capacity you are currently using to those quotas imposed by your account so that you have enough time to apply for an increase before you hit a quota.</p> <p>For example, you could use one of the Amazon Web Services SDKs to do the following:</p> <ol> <li> <p>Call <code>DescribeLimits</code> for a particular Region to obtain your current account quotas on provisioned capacity there.</p> </li> <li> <p>Create a variable to hold the aggregate read capacity units provisioned for all your tables in that Region, and one to hold the aggregate write capacity units. Zero them both.</p> </li> <li> <p>Call <code>ListTables</code> to obtain a list of all your DynamoDB tables.</p> </li> <li> <p>For each table name listed by <code>ListTables</code>, do the following:</p> <ul> <li> <p>Call <code>DescribeTable</code> with the table name.</p> </li> <li> <p>Use the data returned by <code>DescribeTable</code> to add the read capacity units and write capacity units provisioned for the table itself to your variables.</p> </li> <li> <p>If the table has one or more global secondary indexes (GSIs), loop over these GSIs and add their provisioned capacity values to your variables as well.</p> </li> </ul> </li> <li> <p>Report the account quotas for that Region returned by <code>DescribeLimits</code>, along with the total current provisioned capacity levels you have calculated.</p> </li> </ol> <p>This will let you see whether you are getting close to your account-level quotas.</p> <p>The per-table quotas apply only when you are creating a new table. They restrict the sum of the provisioned capacity of the new table itself and all its global secondary indexes.</p> <p>For existing tables and their GSIs, DynamoDB doesn't let you increase provisioned capacity extremely rapidly, but the only quota that applies is that the aggregate provisioned capacity over all your tables and GSIs cannot exceed either of the per-account quotas.</p> <note> <p> <code>DescribeLimits</code> should only be called periodically. You can expect throttling errors if you call it more than once in a minute.</p> </note> <p>The <code>DescribeLimits</code> Request element has no content.</p>
		/// DescribeLimits #X-Amz-Target=DynamoDB_20120810.DescribeLimits
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeLimitsOutput> DescribeLimitsAsync(DescribeLimitsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeLimits";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeLimitsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Returns information about the table, including the current status of the table, when it was created, the primary key schema, and any indexes on the table.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> of global tables. </p> </important> <note> <p>If you issue a <code>DescribeTable</code> request immediately after a <code>CreateTable</code> request, DynamoDB might return a <code>ResourceNotFoundException</code>. This is because <code>DescribeTable</code> uses an eventually consistent query, and the metadata for your table might not be available at that moment. Wait for a few seconds, and then try the <code>DescribeTable</code> request again.</p> </note>
		/// DescribeTable #X-Amz-Target=DynamoDB_20120810.DescribeTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeTableOutput> DescribeTableAsync(DescribeTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Describes auto scaling settings across replicas of the global table at once.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> of global tables.</p> </important>
		/// DescribeTableReplicaAutoScaling #X-Amz-Target=DynamoDB_20120810.DescribeTableReplicaAutoScaling
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeTableReplicaAutoScalingOutput> DescribeTableReplicaAutoScalingAsync(DescribeTableReplicaAutoScalingInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeTableReplicaAutoScaling";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeTableReplicaAutoScalingOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gives a description of the Time to Live (TTL) status on the specified table.
		/// DescribeTimeToLive #X-Amz-Target=DynamoDB_20120810.DescribeTimeToLive
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeTimeToLiveOutput> DescribeTimeToLiveAsync(DescribeTimeToLiveInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DescribeTimeToLive";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeTimeToLiveOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops replication from the DynamoDB table to the Kinesis data stream. This is done without deleting either of the resources.
		/// DisableKinesisStreamingDestination #X-Amz-Target=DynamoDB_20120810.DisableKinesisStreamingDestination
		/// </summary>
		/// <returns>Success</returns>
		public async Task<KinesisStreamingDestinationOutput> DisableKinesisStreamingDestinationAsync(KinesisStreamingDestinationInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.DisableKinesisStreamingDestination";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<KinesisStreamingDestinationOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts table data replication to the specified Kinesis data stream at a timestamp chosen during the enable workflow. If this operation doesn't return results immediately, use DescribeKinesisStreamingDestination to check if streaming to the Kinesis data stream is ACTIVE.
		/// EnableKinesisStreamingDestination #X-Amz-Target=DynamoDB_20120810.EnableKinesisStreamingDestination
		/// </summary>
		/// <returns>Success</returns>
		public async Task<KinesisStreamingDestinationOutput> EnableKinesisStreamingDestinationAsync(KinesisStreamingDestinationInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.EnableKinesisStreamingDestination";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<KinesisStreamingDestinationOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>This operation allows you to perform reads and singleton writes on data stored in DynamoDB, using PartiQL.</p> <p>For PartiQL reads (<code>SELECT</code> statement), if the total number of processed items exceeds the maximum dataset size limit of 1 MB, the read stops and results are returned to the user as a <code>LastEvaluatedKey</code> value to continue the read in a subsequent operation. If the filter criteria in <code>WHERE</code> clause does not match any data, the read will return an empty result set.</p> <p>A single <code>SELECT</code> statement response can return up to the maximum number of items (if using the Limit parameter) or a maximum of 1 MB of data (and then apply any filtering to the results using <code>WHERE</code> clause). If <code>LastEvaluatedKey</code> is present in the response, you need to paginate the result set. If <code>NextToken</code> is present, you need to paginate the result set and include <code>NextToken</code>.</p>
		/// ExecuteStatement #X-Amz-Target=DynamoDB_20120810.ExecuteStatement
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ExecuteStatementOutput> ExecuteStatementAsync(ExecuteStatementInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ExecuteStatement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExecuteStatementOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>This operation allows you to perform transactional reads or writes on data stored in DynamoDB, using PartiQL.</p> <note> <p>The entire transaction must consist of either read statements or write statements, you cannot mix both in one transaction. The EXISTS function is an exception and can be used to check the condition of specific attributes of the item in a similar manner to <code>ConditionCheck</code> in the <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transaction-apis.html#transaction-apis-txwriteitems">TransactWriteItems</a> API.</p> </note>
		/// ExecuteTransaction #X-Amz-Target=DynamoDB_20120810.ExecuteTransaction
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ExecuteTransactionOutput> ExecuteTransactionAsync(ExecuteTransactionInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ExecuteTransaction";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExecuteTransactionOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Exports table data to an S3 bucket. The table must have point in time recovery enabled, and you can export data from any time within the point in time recovery window.
		/// ExportTableToPointInTime #X-Amz-Target=DynamoDB_20120810.ExportTableToPointInTime
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ExportTableToPointInTimeOutput> ExportTableToPointInTimeAsync(ExportTableToPointInTimeInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ExportTableToPointInTime";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExportTableToPointInTimeOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>The <code>GetItem</code> operation returns a set of attributes for the item with the given primary key. If there is no matching item, <code>GetItem</code> does not return any data and there will be no <code>Item</code> element in the response.</p> <p> <code>GetItem</code> provides an eventually consistent read by default. If your application requires a strongly consistent read, set <code>ConsistentRead</code> to <code>true</code>. Although a strongly consistent read might take more time than an eventually consistent read, it always returns the last updated value.</p>
		/// GetItem #X-Amz-Target=DynamoDB_20120810.GetItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetItemOutput> GetItemAsync(GetItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.GetItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Imports table data from an S3 bucket.
		/// ImportTable #X-Amz-Target=DynamoDB_20120810.ImportTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ImportTableOutput> ImportTableAsync(ImportTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ImportTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImportTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>List backups associated with an Amazon Web Services account. To list backups for a given table, specify <code>TableName</code>. <code>ListBackups</code> returns a paginated list of results with at most 1 MB worth of items in a page. You can also specify a maximum number of entries to be returned in a page.</p> <p>In the request, start time is inclusive, but end time is exclusive. Note that these boundaries are for the time at which the original backup was requested.</p> <p>You can call <code>ListBackups</code> a maximum of five times per second.</p>
		/// ListBackups #X-Amz-Target=DynamoDB_20120810.ListBackups
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListBackupsOutput> ListBackupsAsync(ListBackupsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ListBackups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListBackupsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns a list of ContributorInsightsSummary for a table and all its global secondary indexes.
		/// ListContributorInsights #X-Amz-Target=DynamoDB_20120810.ListContributorInsights
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListContributorInsightsOutput> ListContributorInsightsAsync(string MaxResults, string NextToken, ListContributorInsightsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ListContributorInsights?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListContributorInsightsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists completed exports within the past 90 days.
		/// ListExports #X-Amz-Target=DynamoDB_20120810.ListExports
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListExportsOutput> ListExportsAsync(string MaxResults, string NextToken, ListExportsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ListExports?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListExportsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all global tables that have a replica in the specified Region.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version 2017.11.29 (Legacy)</a> of global tables. We recommend using <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> when creating new global tables, as it provides greater flexibility, higher efficiency and consumes less write capacity than 2017.11.29 (Legacy). To determine which version you are using, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.DetermineVersion.html">Determining the version</a>. To update existing global tables from version 2017.11.29 (Legacy) to version 2019.11.21 (Current), see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_upgrade.html"> Updating global tables</a>. </p> </important>
		/// ListGlobalTables #X-Amz-Target=DynamoDB_20120810.ListGlobalTables
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListGlobalTablesOutput> ListGlobalTablesAsync(ListGlobalTablesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ListGlobalTables";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListGlobalTablesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists completed imports within the past 90 days.
		/// ListImports #X-Amz-Target=DynamoDB_20120810.ListImports
		/// </summary>
		/// <param name="PageSize">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListImportsOutput> ListImportsAsync(string PageSize, string NextToken, ListImportsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ListImports?PageSize=" + (PageSize==null? "" : System.Uri.EscapeDataString(PageSize))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListImportsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns an array of table names associated with the current account and endpoint. The output from <code>ListTables</code> is paginated, with each page returning a maximum of 100 table names.
		/// ListTables #X-Amz-Target=DynamoDB_20120810.ListTables
		/// </summary>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="ExclusiveStartTableName">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListTablesOutput> ListTablesAsync(string Limit, string ExclusiveStartTableName, ListTablesInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ListTables?Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&ExclusiveStartTableName=" + (ExclusiveStartTableName==null? "" : System.Uri.EscapeDataString(ExclusiveStartTableName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTablesOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>List all tags on an Amazon DynamoDB resource. You can call ListTagsOfResource up to 10 times per second, per account.</p> <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
		/// ListTagsOfResource #X-Amz-Target=DynamoDB_20120810.ListTagsOfResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListTagsOfResourceOutput> ListTagsOfResourceAsync(ListTagsOfResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.ListTagsOfResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsOfResourceOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a new item, or replaces an old item with a new item. If an item that has the same primary key as the new item already exists in the specified table, the new item completely replaces the existing item. You can perform a conditional put operation (add a new item if one with the specified primary key doesn't exist), or replace an existing item if it has certain attribute values. You can return the item's attribute values in the same operation, using the <code>ReturnValues</code> parameter.</p> <p>When you add an item, the primary key attributes are the only required attributes. </p> <p>Empty String and Binary attribute values are allowed. Attribute values of type String and Binary must have a length greater than zero if the attribute is used as a key attribute for a table or index. Set type attributes cannot be empty. </p> <p>Invalid Requests with empty values will be rejected with a <code>ValidationException</code> exception.</p> <note> <p>To prevent a new item from replacing an existing item, use a conditional expression that contains the <code>attribute_not_exists</code> function with the name of the attribute being used as the partition key for the table. Since every record must contain that attribute, the <code>attribute_not_exists</code> function will only succeed if no matching item exists.</p> </note> <p>For more information about <code>PutItem</code>, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html">Working with Items</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
		/// PutItem #X-Amz-Target=DynamoDB_20120810.PutItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<PutItemOutput> PutItemAsync(PutItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.PutItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>You must provide the name of the partition key attribute and a single value for that attribute. <code>Query</code> returns all items with that partition key value. Optionally, you can provide a sort key attribute and use a comparison operator to refine the search results.</p> <p>Use the <code>KeyConditionExpression</code> parameter to provide a specific value for the partition key. The <code>Query</code> operation will return all of the items from the table or index with that partition key value. You can optionally narrow the scope of the <code>Query</code> operation by specifying a sort key value and a comparison operator in <code>KeyConditionExpression</code>. To further refine the <code>Query</code> results, you can optionally provide a <code>FilterExpression</code>. A <code>FilterExpression</code> determines which items within the results should be returned to you. All of the other results are discarded. </p> <p> A <code>Query</code> operation always returns a result set. If no matching items are found, the result set will be empty. Queries that do not return results consume the minimum number of read capacity units for that type of read operation. </p> <note> <p> DynamoDB calculates the number of read capacity units consumed based on item size, not on the amount of data that is returned to an application. The number of capacity units consumed will be the same whether you request all of the attributes (the default behavior) or just some of them (using a projection expression). The number will also be the same whether or not you use a <code>FilterExpression</code>. </p> </note> <p> <code>Query</code> results are always sorted by the sort key value. If the data type of the sort key is Number, the results are returned in numeric order; otherwise, the results are returned in order of UTF-8 bytes. By default, the sort order is ascending. To reverse the order, set the <code>ScanIndexForward</code> parameter to false. </p> <p> A single <code>Query</code> operation will read up to the maximum number of items set (if using the <code>Limit</code> parameter) or a maximum of 1 MB of data and then apply any filtering to the results using <code>FilterExpression</code>. If <code>LastEvaluatedKey</code> is present in the response, you will need to paginate the result set. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.Pagination">Paginating the Results</a> in the <i>Amazon DynamoDB Developer Guide</i>. </p> <p> <code>FilterExpression</code> is applied after a <code>Query</code> finishes, but before the results are returned. A <code>FilterExpression</code> cannot contain partition key or sort key attributes. You need to specify those attributes in the <code>KeyConditionExpression</code>. </p> <note> <p> A <code>Query</code> operation can return an empty result set and a <code>LastEvaluatedKey</code> if all the items read for the page of results are filtered out. </p> </note> <p>You can query a table, a local secondary index, or a global secondary index. For a query on a table or on a local secondary index, you can set the <code>ConsistentRead</code> parameter to <code>true</code> and obtain a strongly consistent result. Global secondary indexes support eventually consistent reads only, so do not specify <code>ConsistentRead</code> when querying a global secondary index.</p>
		/// Query #X-Amz-Target=DynamoDB_20120810.Query
		/// </summary>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="ExclusiveStartKey">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<QueryOutput> QueryAsync(string Limit, string ExclusiveStartKey, QueryInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.Query?Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&ExclusiveStartKey=" + (ExclusiveStartKey==null? "" : System.Uri.EscapeDataString(ExclusiveStartKey));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<QueryOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a new table from an existing backup. Any number of users can execute up to 50 concurrent restores (any type of restore) in a given account. </p> <p>You can call <code>RestoreTableFromBackup</code> at a maximum rate of 10 times per second.</p> <p>You must manually set up the following on the restored table:</p> <ul> <li> <p>Auto scaling policies</p> </li> <li> <p>IAM policies</p> </li> <li> <p>Amazon CloudWatch metrics and alarms</p> </li> <li> <p>Tags</p> </li> <li> <p>Stream settings</p> </li> <li> <p>Time to Live (TTL) settings</p> </li> </ul>
		/// RestoreTableFromBackup #X-Amz-Target=DynamoDB_20120810.RestoreTableFromBackup
		/// </summary>
		/// <returns>Success</returns>
		public async Task<RestoreTableFromBackupOutput> RestoreTableFromBackupAsync(RestoreTableFromBackupInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.RestoreTableFromBackup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RestoreTableFromBackupOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Restores the specified table to the specified point in time within <code>EarliestRestorableDateTime</code> and <code>LatestRestorableDateTime</code>. You can restore your table to any point in time during the last 35 days. Any number of users can execute up to 4 concurrent restores (any type of restore) in a given account. </p> <p> When you restore using point in time recovery, DynamoDB restores your table data to the state based on the selected date and time (day:hour:minute:second) to a new table. </p> <p> Along with data, the following are also included on the new restored table using point in time recovery: </p> <ul> <li> <p>Global secondary indexes (GSIs)</p> </li> <li> <p>Local secondary indexes (LSIs)</p> </li> <li> <p>Provisioned read and write capacity</p> </li> <li> <p>Encryption settings</p> <important> <p> All these settings come from the current settings of the source table at the time of restore. </p> </important> </li> </ul> <p>You must manually set up the following on the restored table:</p> <ul> <li> <p>Auto scaling policies</p> </li> <li> <p>IAM policies</p> </li> <li> <p>Amazon CloudWatch metrics and alarms</p> </li> <li> <p>Tags</p> </li> <li> <p>Stream settings</p> </li> <li> <p>Time to Live (TTL) settings</p> </li> <li> <p>Point in time recovery settings</p> </li> </ul>
		/// RestoreTableToPointInTime #X-Amz-Target=DynamoDB_20120810.RestoreTableToPointInTime
		/// </summary>
		/// <returns>Success</returns>
		public async Task<RestoreTableToPointInTimeOutput> RestoreTableToPointInTimeAsync(RestoreTableToPointInTimeInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.RestoreTableToPointInTime";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RestoreTableToPointInTimeOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>The <code>Scan</code> operation returns one or more items and item attributes by accessing every item in a table or a secondary index. To have DynamoDB return fewer items, you can provide a <code>FilterExpression</code> operation.</p> <p>If the total size of scanned items exceeds the maximum dataset size limit of 1 MB, the scan completes and results are returned to the user. The <code>LastEvaluatedKey</code> value is also returned and the requestor can use the <code>LastEvaluatedKey</code> to continue the scan in a subsequent operation. Each scan response also includes number of items that were scanned (ScannedCount) as part of the request. If using a <code>FilterExpression</code>, a scan result can result in no items meeting the criteria and the <code>Count</code> will result in zero. If you did not use a <code>FilterExpression</code> in the scan request, then <code>Count</code> is the same as <code>ScannedCount</code>.</p> <note> <p> <code>Count</code> and <code>ScannedCount</code> only return the count of items specific to a single scan request and, unless the table is less than 1MB, do not represent the total number of items in the table. </p> </note> <p>A single <code>Scan</code> operation first reads up to the maximum number of items set (if using the <code>Limit</code> parameter) or a maximum of 1 MB of data and then applies any filtering to the results if a <code>FilterExpression</code> is provided. If <code>LastEvaluatedKey</code> is present in the response, pagination is required to complete the full table scan. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.Pagination">Paginating the Results</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p> <p> <code>Scan</code> operations proceed sequentially; however, for faster performance on a large table or secondary index, applications can request a parallel <code>Scan</code> operation by providing the <code>Segment</code> and <code>TotalSegments</code> parameters. For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.ParallelScan">Parallel Scan</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p> <p>By default, a <code>Scan</code> uses eventually consistent reads when accessing the items in a table. Therefore, the results from an eventually consistent <code>Scan</code> may not include the latest item changes at the time the scan iterates through each item in the table. If you require a strongly consistent read of each item as the scan iterates through the items in the table, you can set the <code>ConsistentRead</code> parameter to true. Strong consistency only relates to the consistency of the read at the item level.</p> <note> <p> DynamoDB does not provide snapshot isolation for a scan operation when the <code>ConsistentRead</code> parameter is set to true. Thus, a DynamoDB scan operation does not guarantee that all reads in a scan see a consistent snapshot of the table when the scan operation was requested. </p> </note>
		/// Scan #X-Amz-Target=DynamoDB_20120810.Scan
		/// </summary>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="ExclusiveStartKey">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ScanOutput> ScanAsync(string Limit, string ExclusiveStartKey, ScanInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.Scan?Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&ExclusiveStartKey=" + (ExclusiveStartKey==null? "" : System.Uri.EscapeDataString(ExclusiveStartKey));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScanOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Associate a set of tags with an Amazon DynamoDB resource. You can then activate these user-defined tags so that they appear on the Billing and Cost Management console for cost allocation tracking. You can call TagResource up to five times per second, per account. </p> <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
		/// TagResource #X-Amz-Target=DynamoDB_20120810.TagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task TagResourceAsync(TagResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.TagResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p> <code>TransactGetItems</code> is a synchronous operation that atomically retrieves multiple items from one or more tables (but not from indexes) in a single account and Region. A <code>TransactGetItems</code> call can contain up to 100 <code>TransactGetItem</code> objects, each of which contains a <code>Get</code> structure that specifies an item to retrieve from a table in the account and Region. A call to <code>TransactGetItems</code> cannot retrieve items from tables in more than one Amazon Web Services account or Region. The aggregate size of the items in the transaction cannot exceed 4 MB.</p> <p>DynamoDB rejects the entire <code>TransactGetItems</code> request if any of the following is true:</p> <ul> <li> <p>A conflicting operation is in the process of updating an item to be read.</p> </li> <li> <p>There is insufficient provisioned capacity for the transaction to be completed.</p> </li> <li> <p>There is a user error, such as an invalid data format.</p> </li> <li> <p>The aggregate size of the items in the transaction exceeded 4 MB.</p> </li> </ul>
		/// TransactGetItems #X-Amz-Target=DynamoDB_20120810.TransactGetItems
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TransactGetItemsOutput> TransactGetItemsAsync(TransactGetItemsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.TransactGetItems";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TransactGetItemsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p> <code>TransactWriteItems</code> is a synchronous write operation that groups up to 100 action requests. These actions can target items in different tables, but not in different Amazon Web Services accounts or Regions, and no two actions can target the same item. For example, you cannot both <code>ConditionCheck</code> and <code>Update</code> the same item. The aggregate size of the items in the transaction cannot exceed 4 MB.</p> <p>The actions are completed atomically so that either all of them succeed, or all of them fail. They are defined by the following objects:</p> <ul> <li> <p> <code>Put</code>   Initiates a <code>PutItem</code> operation to write a new item. This structure specifies the primary key of the item to be written, the name of the table to write it in, an optional condition expression that must be satisfied for the write to succeed, a list of the item's attributes, and a field indicating whether to retrieve the item's attributes if the condition is not met.</p> </li> <li> <p> <code>Update</code>   Initiates an <code>UpdateItem</code> operation to update an existing item. This structure specifies the primary key of the item to be updated, the name of the table where it resides, an optional condition expression that must be satisfied for the update to succeed, an expression that defines one or more attributes to be updated, and a field indicating whether to retrieve the item's attributes if the condition is not met.</p> </li> <li> <p> <code>Delete</code>   Initiates a <code>DeleteItem</code> operation to delete an existing item. This structure specifies the primary key of the item to be deleted, the name of the table where it resides, an optional condition expression that must be satisfied for the deletion to succeed, and a field indicating whether to retrieve the item's attributes if the condition is not met.</p> </li> <li> <p> <code>ConditionCheck</code>   Applies a condition to an item that is not being modified by the transaction. This structure specifies the primary key of the item to be checked, the name of the table where it resides, a condition expression that must be satisfied for the transaction to succeed, and a field indicating whether to retrieve the item's attributes if the condition is not met.</p> </li> </ul> <p>DynamoDB rejects the entire <code>TransactWriteItems</code> request if any of the following is true:</p> <ul> <li> <p>A condition in one of the condition expressions is not met.</p> </li> <li> <p>An ongoing operation is in the process of updating the same item.</p> </li> <li> <p>There is insufficient provisioned capacity for the transaction to be completed.</p> </li> <li> <p>An item size becomes too large (bigger than 400 KB), a local secondary index (LSI) becomes too large, or a similar validation error occurs because of changes made by the transaction.</p> </li> <li> <p>The aggregate size of the items in the transaction exceeds 4 MB.</p> </li> <li> <p>There is a user error, such as an invalid data format.</p> </li> </ul>
		/// TransactWriteItems #X-Amz-Target=DynamoDB_20120810.TransactWriteItems
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TransactWriteItemsOutput> TransactWriteItemsAsync(TransactWriteItemsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.TransactWriteItems";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TransactWriteItemsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Removes the association of tags from an Amazon DynamoDB resource. You can call <code>UntagResource</code> up to five times per second, per account. </p> <p>For an overview on tagging DynamoDB resources, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html">Tagging for DynamoDB</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
		/// UntagResource #X-Amz-Target=DynamoDB_20120810.UntagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task UntagResourceAsync(UntagResourceInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UntagResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p> <code>UpdateContinuousBackups</code> enables or disables point in time recovery for the specified table. A successful <code>UpdateContinuousBackups</code> call returns the current <code>ContinuousBackupsDescription</code>. Continuous backups are <code>ENABLED</code> on all tables at table creation. If point in time recovery is enabled, <code>PointInTimeRecoveryStatus</code> will be set to ENABLED.</p> <p> Once continuous backups and point in time recovery are enabled, you can restore to any point in time within <code>EarliestRestorableDateTime</code> and <code>LatestRestorableDateTime</code>. </p> <p> <code>LatestRestorableDateTime</code> is typically 5 minutes before the current time. You can restore your table to any point in time during the last 35 days. </p>
		/// UpdateContinuousBackups #X-Amz-Target=DynamoDB_20120810.UpdateContinuousBackups
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateContinuousBackupsOutput> UpdateContinuousBackupsAsync(UpdateContinuousBackupsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UpdateContinuousBackups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateContinuousBackupsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the status for contributor insights for a specific table or index. CloudWatch Contributor Insights for DynamoDB graphs display the partition key and (if applicable) sort key of frequently accessed items and frequently throttled items in plaintext. If you require the use of Amazon Web Services Key Management Service (KMS) to encrypt this tables partition key and sort key data with an Amazon Web Services managed key or customer managed key, you should not enable CloudWatch Contributor Insights for DynamoDB for this table.
		/// UpdateContributorInsights #X-Amz-Target=DynamoDB_20120810.UpdateContributorInsights
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateContributorInsightsOutput> UpdateContributorInsightsAsync(UpdateContributorInsightsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UpdateContributorInsights";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateContributorInsightsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Adds or removes replicas in the specified global table. The global table must already exist to be able to use this operation. Any replica to be added must be empty, have the same name as the global table, have the same key schema, have DynamoDB Streams enabled, and have the same provisioned and maximum write capacity units.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version 2017.11.29 (Legacy)</a> of global tables. We recommend using <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> when creating new global tables, as it provides greater flexibility, higher efficiency and consumes less write capacity than 2017.11.29 (Legacy). To determine which version you are using, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.DetermineVersion.html">Determining the version</a>. To update existing global tables from version 2017.11.29 (Legacy) to version 2019.11.21 (Current), see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_upgrade.html"> Updating global tables</a>. </p> </important> <note> <p> This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version 2017.11.29</a> of global tables. If you are using global tables <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21</a> you can use <a href="https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_DescribeTable.html">DescribeTable</a> instead. </p> <p> Although you can use <code>UpdateGlobalTable</code> to add replicas and remove replicas in a single request, for simplicity we recommend that you issue separate requests for adding or removing replicas. </p> </note> <p> If global secondary indexes are specified, then the following conditions must also be met: </p> <ul> <li> <p> The global secondary indexes must have the same name. </p> </li> <li> <p> The global secondary indexes must have the same hash key and sort key (if present). </p> </li> <li> <p> The global secondary indexes must have the same provisioned and maximum write capacity units. </p> </li> </ul>
		/// UpdateGlobalTable #X-Amz-Target=DynamoDB_20120810.UpdateGlobalTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateGlobalTableOutput> UpdateGlobalTableAsync(UpdateGlobalTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UpdateGlobalTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateGlobalTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Updates settings for a global table.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V1.html">Version 2017.11.29 (Legacy)</a> of global tables. We recommend using <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> when creating new global tables, as it provides greater flexibility, higher efficiency and consumes less write capacity than 2017.11.29 (Legacy). To determine which version you are using, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.DetermineVersion.html">Determining the version</a>. To update existing global tables from version 2017.11.29 (Legacy) to version 2019.11.21 (Current), see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_upgrade.html"> Updating global tables</a>. </p> </important>
		/// UpdateGlobalTableSettings #X-Amz-Target=DynamoDB_20120810.UpdateGlobalTableSettings
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateGlobalTableSettingsOutput> UpdateGlobalTableSettingsAsync(UpdateGlobalTableSettingsInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UpdateGlobalTableSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateGlobalTableSettingsOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Edits an existing item's attributes, or adds a new item to the table if it does not already exist. You can put, delete, or add attribute values. You can also perform a conditional update on an existing item (insert a new attribute name-value pair if it doesn't exist, or replace an existing name-value pair if it has certain expected attribute values).</p> <p>You can also return the item's attribute values in the same <code>UpdateItem</code> operation using the <code>ReturnValues</code> parameter.</p>
		/// UpdateItem #X-Amz-Target=DynamoDB_20120810.UpdateItem
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateItemOutput> UpdateItemAsync(UpdateItemInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UpdateItem";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateItemOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Modifies the provisioned throughput settings, global secondary indexes, or DynamoDB Streams settings for a given table.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> of global tables. </p> </important> <p>You can only perform one of the following operations at once:</p> <ul> <li> <p>Modify the provisioned throughput settings of the table.</p> </li> <li> <p>Remove a global secondary index from the table.</p> </li> <li> <p>Create a new global secondary index on the table. After the index begins backfilling, you can use <code>UpdateTable</code> to perform other operations.</p> </li> </ul> <p> <code>UpdateTable</code> is an asynchronous operation; while it is executing, the table status changes from <code>ACTIVE</code> to <code>UPDATING</code>. While it is <code>UPDATING</code>, you cannot issue another <code>UpdateTable</code> request. When the table returns to the <code>ACTIVE</code> state, the <code>UpdateTable</code> operation is complete.</p>
		/// UpdateTable #X-Amz-Target=DynamoDB_20120810.UpdateTable
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateTableOutput> UpdateTableAsync(UpdateTableInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UpdateTable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateTableOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Updates auto scaling settings on your global tables at once.</p> <important> <p>This operation only applies to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/globaltables.V2.html">Version 2019.11.21 (Current)</a> of global tables. </p> </important>
		/// UpdateTableReplicaAutoScaling #X-Amz-Target=DynamoDB_20120810.UpdateTableReplicaAutoScaling
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateTableReplicaAutoScalingOutput> UpdateTableReplicaAutoScalingAsync(UpdateTableReplicaAutoScalingInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UpdateTableReplicaAutoScaling";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateTableReplicaAutoScalingOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>The <code>UpdateTimeToLive</code> method enables or disables Time to Live (TTL) for the specified table. A successful <code>UpdateTimeToLive</code> call returns the current <code>TimeToLiveSpecification</code>. It can take up to one hour for the change to fully process. Any additional <code>UpdateTimeToLive</code> calls for the same table during this one hour duration result in a <code>ValidationException</code>. </p> <p>TTL compares the current time in epoch time format to the time stored in the TTL attribute of an item. If the epoch time value stored in the attribute is less than the current time, the item is marked as expired and subsequently deleted.</p> <note> <p> The epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC. </p> </note> <p>DynamoDB deletes expired items on a best-effort basis to ensure availability of throughput for other data operations. </p> <important> <p>DynamoDB typically deletes expired items within two days of expiration. The exact duration within which an item gets deleted after expiration is specific to the nature of the workload. Items that have expired and not been deleted will still show up in reads, queries, and scans.</p> </important> <p>As items are deleted, they are removed from any local secondary index and global secondary index immediately in the same eventually consistent way as a standard delete operation.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html">Time To Live</a> in the Amazon DynamoDB Developer Guide. </p>
		/// UpdateTimeToLive #X-Amz-Target=DynamoDB_20120810.UpdateTimeToLive
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateTimeToLiveOutput> UpdateTimeToLiveAsync(UpdateTimeToLiveInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=DynamoDB_20120810.UpdateTimeToLive";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateTimeToLiveOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum BatchExecuteStatementX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.BatchExecuteStatement")]
		DynamoDB_20120810_BatchExecuteStatement = 0,
	}
	
	public enum BatchGetItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.BatchGetItem")]
		DynamoDB_20120810_BatchGetItem = 0,
	}
	
	public enum BatchWriteItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.BatchWriteItem")]
		DynamoDB_20120810_BatchWriteItem = 0,
	}
	
	public enum CreateBackupX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.CreateBackup")]
		DynamoDB_20120810_CreateBackup = 0,
	}
	
	public enum CreateGlobalTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.CreateGlobalTable")]
		DynamoDB_20120810_CreateGlobalTable = 0,
	}
	
	public enum CreateTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.CreateTable")]
		DynamoDB_20120810_CreateTable = 0,
	}
	
	public enum DeleteBackupX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DeleteBackup")]
		DynamoDB_20120810_DeleteBackup = 0,
	}
	
	public enum DeleteItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DeleteItem")]
		DynamoDB_20120810_DeleteItem = 0,
	}
	
	public enum DeleteTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DeleteTable")]
		DynamoDB_20120810_DeleteTable = 0,
	}
	
	public enum DescribeBackupX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeBackup")]
		DynamoDB_20120810_DescribeBackup = 0,
	}
	
	public enum DescribeContinuousBackupsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeContinuousBackups")]
		DynamoDB_20120810_DescribeContinuousBackups = 0,
	}
	
	public enum DescribeContributorInsightsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeContributorInsights")]
		DynamoDB_20120810_DescribeContributorInsights = 0,
	}
	
	public enum DescribeEndpointsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeEndpoints")]
		DynamoDB_20120810_DescribeEndpoints = 0,
	}
	
	public enum DescribeExportX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeExport")]
		DynamoDB_20120810_DescribeExport = 0,
	}
	
	public enum DescribeGlobalTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeGlobalTable")]
		DynamoDB_20120810_DescribeGlobalTable = 0,
	}
	
	public enum DescribeGlobalTableSettingsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeGlobalTableSettings")]
		DynamoDB_20120810_DescribeGlobalTableSettings = 0,
	}
	
	public enum DescribeImportX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeImport")]
		DynamoDB_20120810_DescribeImport = 0,
	}
	
	public enum DescribeKinesisStreamingDestinationX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeKinesisStreamingDestination")]
		DynamoDB_20120810_DescribeKinesisStreamingDestination = 0,
	}
	
	public enum DescribeLimitsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeLimits")]
		DynamoDB_20120810_DescribeLimits = 0,
	}
	
	public enum DescribeTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeTable")]
		DynamoDB_20120810_DescribeTable = 0,
	}
	
	public enum DescribeTableReplicaAutoScalingX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeTableReplicaAutoScaling")]
		DynamoDB_20120810_DescribeTableReplicaAutoScaling = 0,
	}
	
	public enum DescribeTimeToLiveX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DescribeTimeToLive")]
		DynamoDB_20120810_DescribeTimeToLive = 0,
	}
	
	public enum DisableKinesisStreamingDestinationX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.DisableKinesisStreamingDestination")]
		DynamoDB_20120810_DisableKinesisStreamingDestination = 0,
	}
	
	public enum EnableKinesisStreamingDestinationX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.EnableKinesisStreamingDestination")]
		DynamoDB_20120810_EnableKinesisStreamingDestination = 0,
	}
	
	public enum ExecuteStatementX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ExecuteStatement")]
		DynamoDB_20120810_ExecuteStatement = 0,
	}
	
	public enum ExecuteTransactionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ExecuteTransaction")]
		DynamoDB_20120810_ExecuteTransaction = 0,
	}
	
	public enum ExportTableToPointInTimeX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ExportTableToPointInTime")]
		DynamoDB_20120810_ExportTableToPointInTime = 0,
	}
	
	public enum GetItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.GetItem")]
		DynamoDB_20120810_GetItem = 0,
	}
	
	public enum ImportTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ImportTable")]
		DynamoDB_20120810_ImportTable = 0,
	}
	
	public enum ListBackupsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ListBackups")]
		DynamoDB_20120810_ListBackups = 0,
	}
	
	public enum ListContributorInsightsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ListContributorInsights")]
		DynamoDB_20120810_ListContributorInsights = 0,
	}
	
	public enum ListExportsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ListExports")]
		DynamoDB_20120810_ListExports = 0,
	}
	
	public enum ListGlobalTablesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ListGlobalTables")]
		DynamoDB_20120810_ListGlobalTables = 0,
	}
	
	public enum ListImportsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ListImports")]
		DynamoDB_20120810_ListImports = 0,
	}
	
	public enum ListTablesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ListTables")]
		DynamoDB_20120810_ListTables = 0,
	}
	
	public enum ListTagsOfResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.ListTagsOfResource")]
		DynamoDB_20120810_ListTagsOfResource = 0,
	}
	
	public enum PutItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.PutItem")]
		DynamoDB_20120810_PutItem = 0,
	}
	
	public enum QueryX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.Query")]
		DynamoDB_20120810_Query = 0,
	}
	
	public enum RestoreTableFromBackupX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.RestoreTableFromBackup")]
		DynamoDB_20120810_RestoreTableFromBackup = 0,
	}
	
	public enum RestoreTableToPointInTimeX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.RestoreTableToPointInTime")]
		DynamoDB_20120810_RestoreTableToPointInTime = 0,
	}
	
	public enum ScanX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.Scan")]
		DynamoDB_20120810_Scan = 0,
	}
	
	public enum TagResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.TagResource")]
		DynamoDB_20120810_TagResource = 0,
	}
	
	public enum TransactGetItemsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.TransactGetItems")]
		DynamoDB_20120810_TransactGetItems = 0,
	}
	
	public enum TransactWriteItemsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.TransactWriteItems")]
		DynamoDB_20120810_TransactWriteItems = 0,
	}
	
	public enum UntagResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UntagResource")]
		DynamoDB_20120810_UntagResource = 0,
	}
	
	public enum UpdateContinuousBackupsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UpdateContinuousBackups")]
		DynamoDB_20120810_UpdateContinuousBackups = 0,
	}
	
	public enum UpdateContributorInsightsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UpdateContributorInsights")]
		DynamoDB_20120810_UpdateContributorInsights = 0,
	}
	
	public enum UpdateGlobalTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UpdateGlobalTable")]
		DynamoDB_20120810_UpdateGlobalTable = 0,
	}
	
	public enum UpdateGlobalTableSettingsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UpdateGlobalTableSettings")]
		DynamoDB_20120810_UpdateGlobalTableSettings = 0,
	}
	
	public enum UpdateItemX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UpdateItem")]
		DynamoDB_20120810_UpdateItem = 0,
	}
	
	public enum UpdateTableX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UpdateTable")]
		DynamoDB_20120810_UpdateTable = 0,
	}
	
	public enum UpdateTableReplicaAutoScalingX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UpdateTableReplicaAutoScaling")]
		DynamoDB_20120810_UpdateTableReplicaAutoScaling = 0,
	}
	
	public enum UpdateTimeToLiveX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DynamoDB_20120810.UpdateTimeToLive")]
		DynamoDB_20120810_UpdateTimeToLive = 0,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
