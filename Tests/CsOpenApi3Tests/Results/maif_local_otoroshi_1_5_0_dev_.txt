//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// An Otoroshi Api Key. An Api Key is defined for a group of services to allow usage of the same Api Key for multiple services.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ApiKey
	{
		
		/// <summary>
		/// The group/service ids (prefixed by group_ or service_ on which the key is authorized
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizedEntities")]
		public string[] AuthorizedEntities { get; set; }
		
		/// <summary>
		/// The unique id of the Api Key. Usually 16 random alpha numerical characters, but can be anything
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// The name of the api key, for humans ;-)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientName")]
		public string ClientName { get; set; }
		
		/// <summary>
		/// The secret of the Api Key. Usually 64 random alpha numerical characters, but can be anything
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientSecret")]
		public string ClientSecret { get; set; }
		
		/// <summary>
		/// Authorized number of calls per day
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dailyQuota")]
		public System.Nullable<System.Int64> DailyQuota { get; set; }
		
		/// <summary>
		/// Whether or not the key is enabled. If disabled, resources won't be available to calls using this key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Bunch of metadata for the key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// Authorized number of calls per month
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyQuota")]
		public System.Nullable<System.Int64> MonthlyQuota { get; set; }
		
		/// <summary>
		/// Authorized number of calls per second, measured on 10 seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="throttlingQuota")]
		public System.Nullable<System.Int64> ThrottlingQuota { get; set; }
	}
	
	/// <summary>
	/// Configuration for Auth0 domain
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Auth0Config
	{
		
		/// <summary>
		/// Auth0 callback URL
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="callbackUrl")]
		public string CallbackUrl { get; set; }
		
		/// <summary>
		/// Auth0 client id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Auth0 client secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientSecret")]
		public string ClientSecret { get; set; }
		
		/// <summary>
		/// Auth0 domain
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
	}
	
	/// <summary>
	/// An HTTP response that is not supposed to be returned by a service
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BadResponse
	{
		
		/// <summary>
		/// The body of the HTTP response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The HTTP headers of the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// The HTTP status for the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public int Status { get; set; }
	}
	
	/// <summary>
	/// Config for bad requests injection fault
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BadResponsesFaultConfig
	{
		
		/// <summary>
		/// The percentage of requests affected by this fault. Value should be between 0.0 and 1.0
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ratio")]
		public double Ratio { get; set; }
		
		/// <summary>
		/// The possibles responses
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public BadResponse[] Responses { get; set; }
	}
	
	/// <summary>
	/// The configuration of the canary mode for a service descriptor
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Canary
	{
		
		/// <summary>
		/// Use canary mode for this service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="root")]
		public string Root { get; set; }
		
		/// <summary>
		/// The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Target[] Targets { get; set; }
		
		/// <summary>
		/// Ratio of traffic that will be sent to canary targets.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="traffic")]
		public int Traffic { get; set; }
	}
	
	/// <summary>
	/// A Target is where an HTTP call will be forwarded in the end from a service domain
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Target
	{
		
		/// <summary>
		/// The host on which the HTTP call will be forwarded. Can be a domain name, or an IP address. Can also have a port
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The protocol used for communication. Can be http or https
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheme")]
		public string Scheme { get; set; }
	}
	
	/// <summary>
	/// A SSL/TLS X509 certificate
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Certificate
	{
		
		/// <summary>
		/// Allow Otoroshi to renew the certificate (if self signed)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="autoRenew")]
		public string AutoRenew { get; set; }
		
		/// <summary>
		/// Certificate is a CA (read only)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ca")]
		public string Ca { get; set; }
		
		/// <summary>
		/// Reference for a CA certificate in otoroshi
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="caRef")]
		public string CaRef { get; set; }
		
		/// <summary>
		/// Certificate chain of trust in PEM format
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="chain")]
		public string Chain { get; set; }
		
		/// <summary>
		/// Domain of the certificate (read only)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Start date of validity
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// Id of the certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// PKCS8 private key in PEM format
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
		
		/// <summary>
		/// Certificate is self signed  read only)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selfSigned")]
		public string SelfSigned { get; set; }
		
		/// <summary>
		/// Subject of the certificate (read only)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public string Subject { get; set; }
		
		/// <summary>
		/// End date of validity
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
		
		/// <summary>
		/// Certificate is valid (read only)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="valid")]
		public string Valid { get; set; }
	}
	
	/// <summary>
	/// Configuration for the faults that can be injected in requests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ChaosConfig
	{
		
		/// <summary>
		/// Config for bad requests injection fault
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="badResponsesFaultConfig")]
		public BadResponsesFaultConfig BadResponsesFaultConfig { get; set; }
		
		/// <summary>
		/// Whether or not this config is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Config for large request injection fault
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="largeRequestFaultConfig")]
		public LargeRequestFaultConfig LargeRequestFaultConfig { get; set; }
		
		/// <summary>
		/// Config for large response injection fault
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="largeResponseFaultConfig")]
		public LargeResponseFaultConfig LargeResponseFaultConfig { get; set; }
		
		/// <summary>
		/// Config for large latency injection fault
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latencyInjectionFaultConfig")]
		public LatencyInjectionFaultConfig LatencyInjectionFaultConfig { get; set; }
	}
	
	/// <summary>
	/// Config for large request injection fault
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LargeRequestFaultConfig
	{
		
		/// <summary>
		/// The size added to the request body in bytes. Added payload will be spaces only.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="additionalRequestSize")]
		public int AdditionalRequestSize { get; set; }
		
		/// <summary>
		/// The percentage of requests affected by this fault. Value should be between 0.0 and 1.0
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ratio")]
		public double Ratio { get; set; }
	}
	
	/// <summary>
	/// Config for large response injection fault
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LargeResponseFaultConfig
	{
		
		/// <summary>
		/// The size added to the response body in bytes. Added payload will be spaces only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalRequestSize")]
		public System.Nullable<System.Int32> AdditionalRequestSize { get; set; }
		
		/// <summary>
		/// The percentage of requests affected by this fault. Value should be between 0.0 and 1.0
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ratio")]
		public double Ratio { get; set; }
	}
	
	/// <summary>
	/// Config for large latency injection fault
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LatencyInjectionFaultConfig
	{
		
		/// <summary>
		/// The start range of latency added to the request
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public int From { get; set; }
		
		/// <summary>
		/// The percentage of requests affected by this fault. Value should be between 0.0 and 1.0
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ratio")]
		public double Ratio { get; set; }
		
		/// <summary>
		/// The end range of latency added to the request
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public int To { get; set; }
	}
	
	/// <summary>
	/// Configuration for CleverCloud client
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CleverSettings
	{
		
		/// <summary>
		/// CleverCloud consumer key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="consumerKey")]
		public string ConsumerKey { get; set; }
		
		/// <summary>
		/// CleverCloud consumer token
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="consumerSecret")]
		public string ConsumerSecret { get; set; }
		
		/// <summary>
		/// CleverCloud organization id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="orgaId")]
		public string OrgaId { get; set; }
		
		/// <summary>
		/// CleverCloud oauth secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// CleverCloud oauth token
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// The configuration of the circuit breaker for a service descriptor
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClientConfig
	{
		
		/// <summary>
		/// Specify the factor to multiply the delay for each retry
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backoffFactor")]
		public int BackoffFactor { get; set; }
		
		/// <summary>
		/// Specify how long each call should last at most in milliseconds
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="callTimeout")]
		public int CallTimeout { get; set; }
		
		/// <summary>
		/// Specify how long the global call (with retries) should last at most in milliseconds
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalTimeout")]
		public int GlobalTimeout { get; set; }
		
		/// <summary>
		/// Specify how many errors can pass before opening the circuit breaker
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxErrors")]
		public int MaxErrors { get; set; }
		
		/// <summary>
		/// Specify how many times the client will try to fetch the result of the request after an error before giving up.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public int Retries { get; set; }
		
		/// <summary>
		/// Specify the delay between two retries. Each retry, the delay is multiplied by the backoff factor
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retryInitialDelay")]
		public int RetryInitialDelay { get; set; }
		
		/// <summary>
		/// Specify the sliding window time for the circuit breaker in milliseconds, after this time, error count will be reseted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sampleInterval")]
		public int SampleInterval { get; set; }
		
		/// <summary>
		/// Use a circuit breaker to avoid cascading failure when calling chains of services. Highly recommended !
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="useCircuitBreaker")]
		public bool UseCircuitBreaker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConsoleDataExporterConfig
	{
	}
	
	/// <summary>
	/// The configuration for cors support
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CorsSettings
	{
		
		/// <summary>
		/// Allow to pass credentials
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowCredentials")]
		public bool AllowCredentials { get; set; }
		
		/// <summary>
		/// The cors allowed headers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowHeaders")]
		public string[] AllowHeaders { get; set; }
		
		/// <summary>
		/// The cors allowed methods
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowMethods")]
		public string[] AllowMethods { get; set; }
		
		/// <summary>
		/// The cors allowed origin
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="allowOrigin")]
		public string AllowOrigin { get; set; }
		
		/// <summary>
		/// Whether or not cors is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// The cors excluded patterns
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="excludedPatterns")]
		public string[] ExcludedPatterns { get; set; }
		
		/// <summary>
		/// The cors exposed header
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exposeHeaders")]
		public string[] ExposeHeaders { get; set; }
		
		/// <summary>
		/// Cors max age
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxAge")]
		public int MaxAge { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomDataExporterConfig
	{
		
		/// <summary>
		/// Custom data exporter config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public System.Collections.Generic.Dictionary<string, string> Config { get; set; }
		
		/// <summary>
		/// Script Ref
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ref")]
		public string Ref { get; set; }
	}
	
	/// <summary>
	/// Settings to export Otorshi events
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DataExporterConfig
	{
		
		/// <summary>
		/// buffer size
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bufferSize")]
		public System.Nullable<System.Int32> BufferSize { get; set; }
		
		/// <summary>
		/// Data Exporter config
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config")]
		public ElasticConfig Config { get; set; }
		
		/// <summary>
		/// Description
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="desc")]
		public string Desc { get; set; }
		
		/// <summary>
		/// Boolean
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public string Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="filtering")]
		public Filtering Filtering { get; set; }
		
		/// <summary>
		/// duration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupDuration")]
		public System.Nullable<System.Int64> GroupDuration { get; set; }
		
		/// <summary>
		/// Group size
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupSize")]
		public System.Nullable<System.Int32> GroupSize { get; set; }
		
		/// <summary>
		/// Id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// nb workers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jsonWorkers")]
		public System.Nullable<System.Int32> JsonWorkers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Location Location { get; set; }
		
		/// <summary>
		/// Metadata
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// Name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// projection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projection")]
		public System.Collections.Generic.Dictionary<string, string> Projection { get; set; }
		
		/// <summary>
		/// send workers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sendWorkers")]
		public System.Nullable<System.Int32> SendWorkers { get; set; }
		
		/// <summary>
		/// Type of data exporter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="typ")]
		public System.Nullable<DataExporterConfigTyp> Typ { get; set; }
	}
	
	/// <summary>
	/// The configuration for elastic access
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ElasticConfig
	{
		
		/// <summary>
		/// URL of the elastic cluster
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clusterUri")]
		public string ClusterUri { get; set; }
		
		/// <summary>
		/// Additionnal http headers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// Index for events. Default is otoroshi-events
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="index")]
		public string Index { get; set; }
		
		/// <summary>
		/// Optional password
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Type of events. Default is event
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Optional user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Filtering
	{
		
		/// <summary>
		/// Excluding pattern
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude")]
		public string[] Exclude { get; set; }
		
		/// <summary>
		/// Including pattern
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="include")]
		public string[] Include { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Location
	{
		
		/// <summary>
		/// Team ids
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="teams")]
		public string[] Teams { get; set; }
		
		/// <summary>
		/// Tenant id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tenant")]
		public string Tenant { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DataExporterConfigTyp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		kafka = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pulsar = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		file = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mailer = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		elastic = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		console = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Deleted
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public bool Deleted1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Done
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="done")]
		public bool Done1 { get; set; }
	}
	
	/// <summary>
	/// Settings for an EC + SHA signing algorithm
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ESAlgoSettings
	{
		
		/// <summary>
		/// The private key for the RSA function
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
		
		/// <summary>
		/// The public key for the RSA function
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicKey")]
		public string PublicKey { get; set; }
		
		/// <summary>
		/// Size for SHA function. can be 256, 384 or 512
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// String with value ESAlgoSettings
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Error templates for a service descriptor
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ErrorTemplate
	{
		
		/// <summary>
		/// Map for custom messages
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="messages")]
		public System.Collections.Generic.Dictionary<string, string> Messages { get; set; }
		
		/// <summary>
		/// The Id of the service for which the error template is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceId")]
		public string ServiceId { get; set; }
		
		/// <summary>
		/// The html template for 40x errors
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="template40x")]
		public string Template40x { get; set; }
		
		/// <summary>
		/// The html template for 50x errors
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="template50x")]
		public string Template50x { get; set; }
		
		/// <summary>
		/// The html template for build page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="templateBuild")]
		public string TemplateBuild { get; set; }
		
		/// <summary>
		/// The html template for maintenance page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="templateMaintenance")]
		public string TemplateMaintenance { get; set; }
	}
	
	/// <summary>
	/// The Open API configuration for your service (if one)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExposedApi
	{
		
		/// <summary>
		/// Whether or not the current service expose an API with an Open API descriptor
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="exposeApi")]
		public bool ExposeApi { get; set; }
		
		/// <summary>
		/// The URL of the Open API descriptor
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openApiDescriptorUrl")]
		public string OpenApiDescriptorUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FileDataExporterConfig
	{
		
		/// <summary>
		/// Path to file
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// Settings to authenticate users using a generic OAuth2 provider
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GenericOauth2ModuleConfig
	{
		
		/// <summary>
		/// Field name to get access token
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accessTokenField")]
		public string AccessTokenField { get; set; }
		
		/// <summary>
		/// OAuth authorize URL
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizeUrl")]
		public string AuthorizeUrl { get; set; }
		
		/// <summary>
		/// Otoroshi callback URL
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="callbackUrl")]
		public string CallbackUrl { get; set; }
		
		/// <summary>
		/// The claims of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="claims")]
		public string Claims { get; set; }
		
		/// <summary>
		/// OAuth Client id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// OAuth Client secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientSecret")]
		public string ClientSecret { get; set; }
		
		/// <summary>
		/// Description of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="desc")]
		public string Desc { get; set; }
		
		/// <summary>
		/// Field name to get email from user profile
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emailField")]
		public string EmailField { get; set; }
		
		/// <summary>
		/// Unique id of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Algo. settings to verify JWT token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jwtVerifier")]
		public HSAlgoSettings JwtVerifier { get; set; }
		
		/// <summary>
		/// OAuth login URL
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="loginUrl")]
		public string LoginUrl { get; set; }
		
		/// <summary>
		/// OAuth logout URL
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logoutUrl")]
		public string LogoutUrl { get; set; }
		
		/// <summary>
		/// Name of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Field name to get name from user profile
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nameField")]
		public string NameField { get; set; }
		
		/// <summary>
		/// URL of the OIDC config. file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oidConfig")]
		public string OidConfig { get; set; }
		
		/// <summary>
		/// Field name to get otoroshi metadata from. You can specify sub fields using | as separator
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="otoroshiDataField")]
		public string OtoroshiDataField { get; set; }
		
		/// <summary>
		/// The user profile will be read from the JWT token in id_token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="readProfileFromToken")]
		public System.Nullable<System.Boolean> ReadProfileFromToken { get; set; }
		
		/// <summary>
		/// The scope of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
		
		/// <summary>
		/// Max age of the session
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sessionMaxAge")]
		public int SessionMaxAge { get; set; }
		
		/// <summary>
		/// OAuth token URL
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tokenUrl")]
		public string TokenUrl { get; set; }
		
		/// <summary>
		/// Type of settings. value is oauth2
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Use for redirection to actual service
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useCookies")]
		public System.Nullable<System.Boolean> UseCookies { get; set; }
		
		/// <summary>
		/// Use JSON or URL Form Encoded as payload with the OAuth provider
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useJson")]
		public System.Nullable<System.Boolean> UseJson { get; set; }
		
		/// <summary>
		/// OAuth userinfo to get user profile
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="userInfoUrl")]
		public string UserInfoUrl { get; set; }
	}
	
	/// <summary>
	/// Settings for an HMAC + SHA signing algorithm
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HSAlgoSettings
	{
		
		/// <summary>
		/// The secret value for the HMAC function
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secret")]
		public string Secret { get; set; }
		
		/// <summary>
		/// Size for SHA function. can be 256, 384 or 512
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// String with value HSAlgoSettings
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// The global config object of Otoroshi, used to customize settings of the current Otoroshi instance
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GlobalConfig
	{
		
		/// <summary>
		/// Email addresses that will receive all Otoroshi alert events
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alertsEmails")]
		public string[] AlertsEmails { get; set; }
		
		/// <summary>
		/// Webhook that will receive all Otoroshi alert events
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alertsWebhooks")]
		public Webhook[] AlertsWebhooks { get; set; }
		
		/// <summary>
		/// Webhook that will receive all internal Otoroshi events
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="analyticsWebhooks")]
		public Webhook[] AnalyticsWebhooks { get; set; }
		
		/// <summary>
		/// If enabled, Admin API won't be able to write/update/delete entities
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiReadOnly")]
		public bool ApiReadOnly { get; set; }
		
		/// <summary>
		/// If not defined, every new service descriptor will be added to the default group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="autoLinkToDefaultGroup")]
		public bool AutoLinkToDefaultGroup { get; set; }
		
		/// <summary>
		/// Configuration for Auth0 domain
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backofficeAuth0Config")]
		public Auth0Config BackofficeAuth0Config { get; set; }
		
		/// <summary>
		/// Configuration for CleverCloud client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cleverSettings")]
		public CleverSettings CleverSettings { get; set; }
		
		/// <summary>
		/// The configuration for elastic access
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="elasticReadsConfig")]
		public ElasticConfig ElasticReadsConfig { get; set; }
		
		/// <summary>
		/// Configs. for Elastic writes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="elasticWritesConfigs")]
		public ElasticConfig[] ElasticWritesConfigs { get; set; }
		
		/// <summary>
		/// IP addresses for which any request to Otoroshi will respond with 128 Gb of zeros
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endlessIpAddresses")]
		public string[] EndlessIpAddresses { get; set; }
		
		/// <summary>
		/// The filtering configuration block for a service of globally.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipFiltering")]
		public IpFiltering IpFiltering { get; set; }
		
		/// <summary>
		/// If enabled, Otoroshi will reject new request if too much at the same time
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="limitConcurrentRequests")]
		public bool LimitConcurrentRequests { get; set; }
		
		/// <summary>
		/// Possibles lines for Otoroshi
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lines")]
		public string[] Lines { get; set; }
		
		/// <summary>
		/// Configuration for mailgun api client
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mailerSettings")]
		public MailerSettings MailerSettings { get; set; }
		
		/// <summary>
		/// The number of authorized request processed at the same time
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxConcurrentRequests")]
		public long MaxConcurrentRequests { get; set; }
		
		/// <summary>
		/// The max size in bytes of an HTTP 1.0 response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxHttp10ResponseSize")]
		public System.Nullable<System.Int64> MaxHttp10ResponseSize { get; set; }
		
		/// <summary>
		/// Number of events kept locally
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLogsSize")]
		public System.Nullable<System.Int32> MaxLogsSize { get; set; }
		
		/// <summary>
		/// Use middle finger emoji as a response character for endless HTTP responses
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="middleFingers")]
		public System.Nullable<System.Boolean> MiddleFingers { get; set; }
		
		/// <summary>
		/// Authorized number of calls per second globally per IP address, measured on 10 seconds
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="perIpThrottlingQuota")]
		public long PerIpThrottlingQuota { get; set; }
		
		/// <summary>
		/// Configuration for Auth0 domain
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateAppsAuth0Config")]
		public Auth0Config PrivateAppsAuth0Config { get; set; }
		
		/// <summary>
		/// HTTP will be streamed only. Doesn't work with old browsers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamEntityOnly")]
		public bool StreamEntityOnly { get; set; }
		
		/// <summary>
		/// Authorized number of calls per second globally, measured on 10 seconds
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="throttlingQuota")]
		public long ThrottlingQuota { get; set; }
		
		/// <summary>
		/// If enabled, login to backoffice through Auth0 will be disabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="u2fLoginOnly")]
		public bool U2fLoginOnly { get; set; }
		
		/// <summary>
		/// If enabled, services will be authorized to use circuit breakers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="useCircuitBreakers")]
		public bool UseCircuitBreakers { get; set; }
	}
	
	/// <summary>
	/// A callback URL where events are posted
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Webhook
	{
		
		/// <summary>
		/// Headers to authorize the call or whatever
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// The URL where events are posted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The filtering configuration block for a service of globally.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IpFiltering
	{
		
		/// <summary>
		/// Blacklisted IP addresses
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blacklist")]
		public string[] Blacklist { get; set; }
		
		/// <summary>
		/// Whitelisted IP addresses
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="whitelist")]
		public string[] Whitelist { get; set; }
	}
	
	/// <summary>
	/// Configuration for mailgun api client
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailerSettings
	{
		
		/// <summary>
		/// Mailgun mailer api key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiKey")]
		public string ApiKey { get; set; }
		
		/// <summary>
		/// Mailjet mailer private api key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiKeyPrivate")]
		public string ApiKeyPrivate { get; set; }
		
		/// <summary>
		/// Mailjet mailer public api key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiKeyPublic")]
		public string ApiKeyPublic { get; set; }
		
		/// <summary>
		/// Mailgun mailer domain
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Mailgun mailer, use EU tenant api
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eu")]
		public System.Nullable<System.Boolean> Eu { get; set; }
		
		/// <summary>
		/// Generic mailer headers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="header")]
		public System.Collections.Generic.Dictionary<string, string> Header { get; set; }
		
		/// <summary>
		/// Type of the mailer: console, generic, mailgun, mailjet
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Generic mailer url
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A JWT verifier used by multiple service descriptor
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GlobalJwtVerifier
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algoSettings")]
		public HSAlgoSettings AlgoSettings { get; set; }
		
		/// <summary>
		/// Verifier description
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="desc")]
		public string Desc { get; set; }
		
		/// <summary>
		/// Is it enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Verifier id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Verifier name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public InQueryParam Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="strategy")]
		public PassThrough Strategy { get; set; }
		
		/// <summary>
		/// Does it fail if JWT not found
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="strict")]
		public bool Strict { get; set; }
	}
	
	/// <summary>
	/// JWT location in a query param
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InQueryParam
	{
		
		/// <summary>
		/// Name of the query param
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// String with value InQueryParam
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Strategy where only signature and field values are verified
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PassThrough
	{
		
		/// <summary>
		/// String with value PassThrough
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Settings to verify the value of JWT token fields
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verificationSettings")]
		public VerificationSettings VerificationSettings { get; set; }
	}
	
	/// <summary>
	/// Settings to verify the value of JWT token fields
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VerificationSettings
	{
		
		/// <summary>
		/// Fields to verify with their values
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public System.Collections.Generic.Dictionary<string, string> Fields { get; set; }
		
		/// <summary>
		/// Settings to change fields of a JWT token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mappingSettings")]
		public MappingSettings MappingSettings { get; set; }
	}
	
	/// <summary>
	/// Settings to change fields of a JWT token
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MappingSettings
	{
		
		/// <summary>
		/// Fields to rename
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="map")]
		public System.Collections.Generic.Dictionary<string, string> Map { get; set; }
		
		/// <summary>
		/// Fields to remove
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remove")]
		public string[] Remove { get; set; }
		
		/// <summary>
		/// Fields to set
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="values")]
		public System.Collections.Generic.Dictionary<string, string> Values { get; set; }
	}
	
	/// <summary>
	/// An Otoroshi service group is just a group of service descriptor. It is useful to be able to define Api Keys for the whole group
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Group
	{
		
		/// <summary>
		/// The descriptoin of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The unique id of the group. Usually 64 random alpha numerical characters, but can be anything
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Configuration for gzip of service responses
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Gzip
	{
		
		/// <summary>
		/// Blacklisted mime types. Wildcard supported
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blackList")]
		public string[] BlackList { get; set; }
		
		/// <summary>
		/// Size of the GZip buffer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bufferSize")]
		public long BufferSize { get; set; }
		
		/// <summary>
		/// Threshold for chunking data
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="chunkedThreshold")]
		public long ChunkedThreshold { get; set; }
		
		/// <summary>
		/// Compression level. From 0 to 9
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="compressionLevel")]
		public int CompressionLevel { get; set; }
		
		/// <summary>
		/// Whether gzip compression is enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Patterns that are excluded from gzipping
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="excludedPatterns")]
		public string[] ExcludedPatterns { get; set; }
		
		/// <summary>
		/// Whitelisted mime types. Wildcard supported
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="whiteList")]
		public string[] WhiteList { get; set; }
	}
	
	/// <summary>
	/// The configuration for checking health of a service. Otoroshi will perform GET call on the URL to check if the service is still alive
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HealthCheck
	{
		
		/// <summary>
		/// Whether or not healthcheck is enabled on the current service descriptor
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// The URL to check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The structure that can be imported to or exported from Otoroshi. It represent the memory state of Otoroshi
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportExport
	{
		
		/// <summary>
		/// Current U2F admin at the time of export
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="admins")]
		public ImportExportAdmins[] ImportExportAdmins { get; set; }
		
		/// <summary>
		/// Current apik keys at the time of export
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiKeys")]
		public ImportExportApiKeys[] ImportExportApiKeys { get; set; }
		
		/// <summary>
		/// Current env variables at the time of export
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appConfig")]
		public System.Collections.Generic.Dictionary<string, string> AppConfig { get; set; }
		
		/// <summary>
		/// The global config object of Otoroshi, used to customize settings of the current Otoroshi instance
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public GlobalConfig Config { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public System.DateTimeOffset Date { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dateRaw")]
		public long DateRaw { get; set; }
		
		/// <summary>
		/// Current error templates at the time of export
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="errorTemplates")]
		public ImportExportErrorTemplates[] ImportExportErrorTemplates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Current service descriptors at the time of export
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceDescriptors")]
		public ImportExportServiceDescriptors[] ImportExportServiceDescriptors { get; set; }
		
		/// <summary>
		/// Current service groups at the time of export
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceGroups")]
		public ImportExportServiceGroups[] ImportExportServiceGroups { get; set; }
		
		/// <summary>
		/// Current simple admins at the time of export
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="simpleAdmins")]
		public ImportExportSimpleAdmins[] ImportExportSimpleAdmins { get; set; }
		
		/// <summary>
		/// Global stats for the current Otoroshi instances
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stats")]
		public ImportExportStats Stats { get; set; }
	}
	
	public class ImportExportAdmins
	{
		
		/// <summary>
		/// The creation date of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public long CreatedAt { get; set; }
		
		/// <summary>
		/// The label for the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The hashed password of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The U2F registration slug
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="registration")]
		public System.Collections.Generic.Dictionary<string, string> Registration { get; set; }
		
		/// <summary>
		/// The email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	public class ImportExportApiKeys
	{
		
		/// <summary>
		/// The group/service ids (prefixed by group_ or service_ on which the key is authorized
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizedEntities")]
		public string[] AuthorizedEntities { get; set; }
		
		/// <summary>
		/// The unique id of the Api Key. Usually 16 random alpha numerical characters, but can be anything
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// The name of the api key, for humans ;-)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientName")]
		public string ClientName { get; set; }
		
		/// <summary>
		/// The secret of the Api Key. Usually 64 random alpha numerical characters, but can be anything
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientSecret")]
		public string ClientSecret { get; set; }
		
		/// <summary>
		/// Authorized number of calls per day
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dailyQuota")]
		public System.Nullable<System.Int64> DailyQuota { get; set; }
		
		/// <summary>
		/// Whether or not the key is enabled. If disabled, resources won't be available to calls using this key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Bunch of metadata for the key
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// Authorized number of calls per month
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="monthlyQuota")]
		public System.Nullable<System.Int64> MonthlyQuota { get; set; }
		
		/// <summary>
		/// Authorized number of calls per second, measured on 10 seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="throttlingQuota")]
		public System.Nullable<System.Int64> ThrottlingQuota { get; set; }
	}
	
	public class ImportExportErrorTemplates
	{
		
		/// <summary>
		/// Map for custom messages
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="messages")]
		public System.Collections.Generic.Dictionary<string, string> Messages { get; set; }
		
		/// <summary>
		/// The Id of the service for which the error template is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceId")]
		public string ServiceId { get; set; }
		
		/// <summary>
		/// The html template for 40x errors
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="template40x")]
		public string Template40x { get; set; }
		
		/// <summary>
		/// The html template for 50x errors
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="template50x")]
		public string Template50x { get; set; }
		
		/// <summary>
		/// The html template for build page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="templateBuild")]
		public string TemplateBuild { get; set; }
		
		/// <summary>
		/// The html template for maintenance page
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="templateMaintenance")]
		public string TemplateMaintenance { get; set; }
	}
	
	public class ImportExportServiceDescriptors
	{
		
		/// <summary>
		/// The configuration of the canary mode for a service descriptor
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Canary Canary { get; set; }
		
		/// <summary>
		/// Specify headers that will be added to each client request. Useful to add authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalHeaders")]
		public System.Collections.Generic.Dictionary<string, string> AdditionalHeaders { get; set; }
		
		/// <summary>
		/// The Open API configuration for your service (if one)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api")]
		public ExposedApi Api { get; set; }
		
		/// <summary>
		/// A reference to a global auth module config
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authConfigRef")]
		public string AuthConfigRef { get; set; }
		
		/// <summary>
		/// Display a construction page when a user try to use the service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="buildMode")]
		public bool BuildMode { get; set; }
		
		/// <summary>
		/// Configuration for the faults that can be injected in requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chaosConfig")]
		public ChaosConfig ChaosConfig { get; set; }
		
		/// <summary>
		/// The configuration of the circuit breaker for a service descriptor
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientConfig")]
		public ClientConfig ClientConfig { get; set; }
		
		/// <summary>
		/// A reference to validation authority
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientValidatorRef")]
		public string ClientValidatorRef { get; set; }
		
		/// <summary>
		/// The configuration for cors support
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cors")]
		public CorsSettings Cors { get; set; }
		
		/// <summary>
		/// The domain on which the service is available.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enforceSecureCommunication")]
		public bool EnforceSecureCommunication { get; set; }
		
		/// <summary>
		/// The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="env")]
		public string Env { get; set; }
		
		/// <summary>
		/// Will force redirection to https:// if not present
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forceHttps")]
		public bool ForceHttps { get; set; }
		
		/// <summary>
		/// Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public string[] Groups { get; set; }
		
		/// <summary>
		/// Configuration for gzip of service responses
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gzip")]
		public Gzip Gzip { get; set; }
		
		/// <summary>
		/// Specify headers that will be verified after routing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headersVerification")]
		public System.Collections.Generic.Dictionary<string, string> HeadersVerification { get; set; }
		
		/// <summary>
		/// The configuration for checking health of a service. Otoroshi will perform GET call on the URL to check if the service is still alive
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthCheck")]
		public HealthCheck HealthCheck { get; set; }
		
		/// <summary>
		/// A unique random string to identify your service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The filtering configuration block for a service of globally.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipFiltering")]
		public IpFiltering IpFiltering { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="jwtVerifier")]
		public LocalJwtVerifier JwtVerifier { get; set; }
		
		/// <summary>
		/// The host used localy, mainly localhost:xxxx
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localHost")]
		public string LocalHost { get; set; }
		
		/// <summary>
		/// The scheme used localy, mainly http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localScheme")]
		public string LocalScheme { get; set; }
		
		/// <summary>
		/// Display a maintainance page when a user try to use the service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maintenanceMode")]
		public bool MaintenanceMode { get; set; }
		
		/// <summary>
		/// Specify headers that MUST be present on client request to route it. Useful to implement versioning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matchingHeaders")]
		public System.Collections.Generic.Dictionary<string, string> MatchingHeaders { get; set; }
		
		/// <summary>
		/// The root path on which the service is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matchingRoot")]
		public string MatchingRoot { get; set; }
		
		/// <summary>
		/// Just a bunch of random properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// The name of your service. Only for debug and human readability purposes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Host header will be overriden with Host of the target
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overrideHost")]
		public System.Nullable<System.Boolean> OverrideHost { get; set; }
		
		/// <summary>
		/// When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="privateApp")]
		public bool PrivateApp { get; set; }
		
		/// <summary>
		/// If you define a public pattern that is a little bit too much, you can make some of public URL private again
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privatePatterns")]
		public string[] PrivatePatterns { get; set; }
		
		/// <summary>
		/// By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicPatterns")]
		public string[] PublicPatterns { get; set; }
		
		/// <summary>
		/// If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectToLocal")]
		public System.Nullable<System.Boolean> RedirectToLocal { get; set; }
		
		/// <summary>
		/// The configuration for redirection per service
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirection")]
		public RedirectionSettings Redirection { get; set; }
		
		/// <summary>
		/// Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="root")]
		public string Root { get; set; }
		
		/// <summary>
		/// URI patterns excluded from secured communications
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secComExcludedPatterns")]
		public string[] SecComExcludedPatterns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secComSettings")]
		public HSAlgoSettings SecComSettings { get; set; }
		
		/// <summary>
		/// When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sendOtoroshiHeadersBack")]
		public System.Nullable<System.Boolean> SendOtoroshiHeadersBack { get; set; }
		
		/// <summary>
		/// The configuration for statsd metrics push
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statsdConfig")]
		public StatsdConfig StatsdConfig { get; set; }
		
		/// <summary>
		/// The subdomain on which the service is available
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subdomain")]
		public string Subdomain { get; set; }
		
		/// <summary>
		/// The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Target[] Targets { get; set; }
		
		/// <summary>
		/// A reference to a request transformer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transformerRef")]
		public string TransformerRef { get; set; }
		
		/// <summary>
		/// The fact that this service will be seen by users and cannot be impacted by the Snow Monkey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userFacing")]
		public System.Nullable<System.Boolean> UserFacing { get; set; }
		
		/// <summary>
		/// Send X-Forwarded-* headers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xForwardedHeaders")]
		public System.Nullable<System.Boolean> XForwardedHeaders { get; set; }
	}
	
	/// <summary>
	/// A JWT verifier used only for the current service descriptor
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LocalJwtVerifier
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algoSettings")]
		public HSAlgoSettings AlgoSettings { get; set; }
		
		/// <summary>
		/// Is it enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public InQueryParam Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="strategy")]
		public PassThrough Strategy { get; set; }
		
		/// <summary>
		/// Does it fail if JWT not found
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="strict")]
		public bool Strict { get; set; }
		
		/// <summary>
		/// A string with value 'local'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// The configuration for redirection per service
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RedirectionSettings
	{
		
		/// <summary>
		/// The http redirect code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public int Code { get; set; }
		
		/// <summary>
		/// Whether or not redirection is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// The location for redirection
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	/// <summary>
	/// The configuration for statsd metrics push
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StatsdConfig
	{
		
		/// <summary>
		/// Datadog agent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datadog")]
		public bool Datadog { get; set; }
		
		/// <summary>
		/// The host of the StatsD agent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The port of the StatsD agent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
	}
	
	public class ImportExportServiceGroups
	{
		
		/// <summary>
		/// The descriptoin of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The unique id of the group. Usually 64 random alpha numerical characters, but can be anything
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ImportExportSimpleAdmins
	{
		
		/// <summary>
		/// The creation date of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public long CreatedAt { get; set; }
		
		/// <summary>
		/// The label for the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The hashed password of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Global stats for the current Otoroshi instances
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportExportStats
	{
		
		/// <summary>
		/// Number of calls to Otoroshi globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="calls")]
		public long Calls { get; set; }
		
		/// <summary>
		/// The amount of data sent to Otoroshi globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataIn")]
		public long DataIn { get; set; }
		
		/// <summary>
		/// The amount of data sent from Otoroshi globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataOut")]
		public long DataOut { get; set; }
	}
	
	/// <summary>
	/// JWT location in a cookie
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InCookie
	{
		
		/// <summary>
		/// Name of the cookie
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// String with value InCookie
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// JWT location in a header
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InHeader
	{
		
		/// <summary>
		/// Name of the header
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Remove regex inside the value, like 'Bearer '
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remove")]
		public string Remove { get; set; }
		
		/// <summary>
		/// String with value InHeader
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Settings to authenticate users using the in memory user store
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InMemoryAuthModuleConfig
	{
		
		/// <summary>
		/// Description of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="desc")]
		public string Desc { get; set; }
		
		/// <summary>
		/// Unique id of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Max age of the session
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sessionMaxAge")]
		public string SessionMaxAge { get; set; }
		
		/// <summary>
		/// Type of settings. value is basic
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// List of users
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="users")]
		public InMemoryUser[] Users { get; set; }
	}
	
	/// <summary>
	/// A user
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InMemoryUser
	{
		
		/// <summary>
		/// Email of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Metadata of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// Name of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Password of the user (BCrypt hash)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
	}
	
	/// <summary>
	/// Settings for a JWK set
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JWKSAlgoSettings
	{
		
		/// <summary>
		/// The headers for the http call
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// The type of key: RSA or EC
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kty")]
		public string Kty { get; set; }
		
		/// <summary>
		/// The timeout of the http call
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int64> Timeout { get; set; }
		
		/// <summary>
		/// The ttl of the keyset
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int64> Ttl { get; set; }
		
		/// <summary>
		/// String with value JWKSAlgoSettings
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The url for the http call
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The configuration for kafka access
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class KafkaConfig
	{
		
		/// <summary>
		/// Optional keypass
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyPass")]
		public string KeyPass { get; set; }
		
		/// <summary>
		/// Optional path to keystore
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyStore")]
		public string KeyStore { get; set; }
		
		/// <summary>
		/// URLs of the kafka servers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public string[] Servers { get; set; }
		
		/// <summary>
		/// Optional kafka topic (otoroshi-events by default)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topic")]
		public string Topic { get; set; }
		
		/// <summary>
		/// Optional path to trustore
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trustore")]
		public string Trustore { get; set; }
	}
	
	/// <summary>
	/// Settings to authenticate users using a generic OAuth2 provider
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LdapAuthModuleConfig
	{
		
		/// <summary>
		/// The admin password
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="adminPassword")]
		public string AdminPassword { get; set; }
		
		/// <summary>
		/// The admin username
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="adminUsername")]
		public string AdminUsername { get; set; }
		
		/// <summary>
		/// Description of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="desc")]
		public string Desc { get; set; }
		
		/// <summary>
		/// Field name to get email from user profile
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="emailField")]
		public string EmailField { get; set; }
		
		/// <summary>
		/// Filter for groups
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groupFilter")]
		public string GroupFilter { get; set; }
		
		/// <summary>
		/// Unique id of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Field name to get name from user profile
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nameField")]
		public string NameField { get; set; }
		
		/// <summary>
		/// Field name to get otoroshi metadata from. You can specify sub fields using | as separator
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="otoroshiDataField")]
		public string OtoroshiDataField { get; set; }
		
		/// <summary>
		/// LDAP search base
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="searchBase")]
		public string SearchBase { get; set; }
		
		/// <summary>
		/// Filter for users
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="searchFilter")]
		public string SearchFilter { get; set; }
		
		/// <summary>
		/// URL of the ldap server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serverUrl")]
		public string ServerUrl { get; set; }
		
		/// <summary>
		/// Max age of the session
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sessionMaxAge")]
		public int SessionMaxAge { get; set; }
		
		/// <summary>
		/// Type of settings. value is ldap
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// LDAP user base DN
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="userBase")]
		public string UserBase { get; set; }
	}
	
	/// <summary>
	/// A user
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LdapUser
	{
		
		/// <summary>
		/// Email of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Metadata of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// Name of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailerConsoleExporterConfig
	{
		
		/// <summary>
		/// Type of mailer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<MailerConsoleExporterConfigType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MailerConsoleExporterConfigType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		generic = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailerGenericExporterConfig
	{
		
		/// <summary>
		/// Optional headers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// Email adresses of recipents
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string[] To { get; set; }
		
		/// <summary>
		/// Type of mailer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public MailerConsoleExporterConfigType Type { get; set; }
		
		/// <summary>
		/// Url of mailer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailerMailgunExporterConfig
	{
		
		/// <summary>
		/// Mailgun apiKey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiKey")]
		public string ApiKey { get; set; }
		
		/// <summary>
		/// Mailgun domain
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Whether the mailgun server is european
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eu")]
		public System.Nullable<System.Boolean> Eu { get; set; }
		
		/// <summary>
		/// Email adresses of recipents
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string[] To { get; set; }
		
		/// <summary>
		/// Type of mailer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public MailerMailgunExporterConfigType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MailerMailgunExporterConfigType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mailgun = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailerMailjetExporterConfig
	{
		
		/// <summary>
		/// Mailjet private apiKey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiKeyPrivate")]
		public string ApiKeyPrivate { get; set; }
		
		/// <summary>
		/// Mailjet public apiKey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiKeyPublic")]
		public string ApiKeyPublic { get; set; }
		
		/// <summary>
		/// Email adresses of recipents
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string[] To { get; set; }
		
		/// <summary>
		/// Type of mailer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public MailerMailjetExporterConfigType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MailerMailjetExporterConfigType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mailjet = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailerSendgridExporterConfig
	{
		
		/// <summary>
		/// Sendgrid apiKey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiKeyPublic")]
		public string ApiKeyPublic { get; set; }
		
		/// <summary>
		/// Email adresses of recipents
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string[] To { get; set; }
		
		/// <summary>
		/// Type of mailer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public MailerSendgridExporterConfigType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MailerSendgridExporterConfigType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sendgrid = 0,
	}
	
	/// <summary>
	/// The structure that represent current Otoroshi health
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OtoroshiHealth
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datastore")]
		public OtoroshiHealthDatastore Datastore { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="otoroshi")]
		public OtoroshiHealthOtoroshi Otoroshi { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OtoroshiHealthDatastore
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		healthy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unhealthy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unreachable = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OtoroshiHealthOtoroshi
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		healthy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unhealthy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		down = 2,
	}
	
	/// <summary>
	/// An outage by the Snow Monkey on a service
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Outage
	{
		
		/// <summary>
		/// The service impacted by outage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="descriptorId")]
		public string DescriptorId { get; set; }
		
		/// <summary>
		/// The name of service impacted by outage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="descriptorName")]
		public string DescriptorName { get; set; }
		
		/// <summary>
		/// The duration of the outage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public int Duration { get; set; }
		
		/// <summary>
		/// The end of the outage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="until")]
		public string Until { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OutageStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OneServicePerGroup = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AllServicesPerGroup = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PatchElement
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PatchElementOp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		add = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replace = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		remove = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		copy = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		test = 4,
	}
	
	/// <summary>
	/// The configuration for kafka access
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PulsarDataExporterConfig
	{
		
		/// <summary>
		/// Namespace
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
		
		/// <summary>
		/// Tenant
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tenant")]
		public string Tenant { get; set; }
		
		/// <summary>
		/// Topic
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="topic")]
		public string Topic { get; set; }
		
		/// <summary>
		/// URI of the pulsar server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string[] Uri { get; set; }
	}
	
	/// <summary>
	/// Quotas state for an api key on a service group
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Quotas
	{
		
		/// <summary>
		/// The number of authorized calls per day
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizedCallsPerDay")]
		public long AuthorizedCallsPerDay { get; set; }
		
		/// <summary>
		/// The number of authorized calls per month
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizedCallsPerMonth")]
		public long AuthorizedCallsPerMonth { get; set; }
		
		/// <summary>
		/// The number of authorized calls per second
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizedCallsPerSec")]
		public long AuthorizedCallsPerSec { get; set; }
		
		/// <summary>
		/// The current number of calls per day
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentCallsPerDay")]
		public long CurrentCallsPerDay { get; set; }
		
		/// <summary>
		/// The current number of calls per month
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentCallsPerMonth")]
		public long CurrentCallsPerMonth { get; set; }
		
		/// <summary>
		/// The current number of calls per second
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentCallsPerSec")]
		public long CurrentCallsPerSec { get; set; }
		
		/// <summary>
		/// The remaining number of calls per day
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remainingCallsPerDay")]
		public long RemainingCallsPerDay { get; set; }
		
		/// <summary>
		/// The number of authorized calls per month
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remainingCallsPerMonth")]
		public long RemainingCallsPerMonth { get; set; }
		
		/// <summary>
		/// The remaining number of calls per second
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remainingCallsPerSec")]
		public long RemainingCallsPerSec { get; set; }
	}
	
	/// <summary>
	/// Settings for an HMAC + SHA signing algorithm
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RSAlgoSettings
	{
		
		/// <summary>
		/// The private key for the RSA function
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
		
		/// <summary>
		/// The public key for the RSA function
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="publicKey")]
		public string PublicKey { get; set; }
		
		/// <summary>
		/// Size for SHA function. can be 256, 384 or 512
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// String with value RSAlgoSettings
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Reference to a global JWT verifier
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RefJwtVerifier
	{
		
		/// <summary>
		/// Is it enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// The id of the GlobalJWTVerifier
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A string with value 'ref'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A script to transformer otoroshi requests 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Script
	{
		
		/// <summary>
		/// The code of the script
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Collections.Generic.Dictionary<string, string> Code { get; set; }
		
		/// <summary>
		/// The description of the script
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="desc")]
		public System.Collections.Generic.Dictionary<string, string> Desc { get; set; }
		
		/// <summary>
		/// The id of the script
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the script
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The error of the compilation of a Script
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScriptCompilationError
	{
		
		/// <summary>
		/// The column of the error
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="column")]
		public string Column { get; set; }
		
		/// <summary>
		/// The file where the error is located
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="file")]
		public System.Collections.Generic.Dictionary<string, string> File { get; set; }
		
		/// <summary>
		/// The line of the error
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="line")]
		public string Line { get; set; }
		
		/// <summary>
		/// The message to display for the error
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public System.Collections.Generic.Dictionary<string, string> Message { get; set; }
		
		/// <summary>
		/// The raw message from the compiler
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rawMessage")]
		public System.Collections.Generic.Dictionary<string, string> RawMessage { get; set; }
	}
	
	/// <summary>
	/// The result of the compilation of a Script
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScriptCompilationResult
	{
		
		/// <summary>
		/// Is the task done or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="done")]
		public bool Done { get; set; }
		
		/// <summary>
		/// The error of the compilation of a Script
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ScriptCompilationError Error { get; set; }
	}
	
	/// <summary>
	/// An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Service
	{
		
		/// <summary>
		/// The configuration of the canary mode for a service descriptor
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public Canary Canary { get; set; }
		
		/// <summary>
		/// Specify headers that will be added to each client request. Useful to add authentication
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalHeaders")]
		public System.Collections.Generic.Dictionary<string, string> AdditionalHeaders { get; set; }
		
		/// <summary>
		/// The Open API configuration for your service (if one)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api")]
		public ExposedApi Api { get; set; }
		
		/// <summary>
		/// A reference to a global auth module config
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authConfigRef")]
		public string AuthConfigRef { get; set; }
		
		/// <summary>
		/// Display a construction page when a user try to use the service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="buildMode")]
		public bool BuildMode { get; set; }
		
		/// <summary>
		/// Configuration for the faults that can be injected in requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chaosConfig")]
		public ChaosConfig ChaosConfig { get; set; }
		
		/// <summary>
		/// The configuration of the circuit breaker for a service descriptor
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientConfig")]
		public ClientConfig ClientConfig { get; set; }
		
		/// <summary>
		/// A reference to validation authority
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientValidatorRef")]
		public string ClientValidatorRef { get; set; }
		
		/// <summary>
		/// The configuration for cors support
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cors")]
		public CorsSettings Cors { get; set; }
		
		/// <summary>
		/// The domain on which the service is available.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enforceSecureCommunication")]
		public bool EnforceSecureCommunication { get; set; }
		
		/// <summary>
		/// The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="env")]
		public string Env { get; set; }
		
		/// <summary>
		/// Will force redirection to https:// if not present
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="forceHttps")]
		public bool ForceHttps { get; set; }
		
		/// <summary>
		/// Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public string[] Groups { get; set; }
		
		/// <summary>
		/// Configuration for gzip of service responses
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gzip")]
		public Gzip Gzip { get; set; }
		
		/// <summary>
		/// Specify headers that will be verified after routing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headersVerification")]
		public System.Collections.Generic.Dictionary<string, string> HeadersVerification { get; set; }
		
		/// <summary>
		/// The configuration for checking health of a service. Otoroshi will perform GET call on the URL to check if the service is still alive
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthCheck")]
		public HealthCheck HealthCheck { get; set; }
		
		/// <summary>
		/// A unique random string to identify your service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The filtering configuration block for a service of globally.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipFiltering")]
		public IpFiltering IpFiltering { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="jwtVerifier")]
		public LocalJwtVerifier JwtVerifier { get; set; }
		
		/// <summary>
		/// The host used localy, mainly localhost:xxxx
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localHost")]
		public string LocalHost { get; set; }
		
		/// <summary>
		/// The scheme used localy, mainly http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localScheme")]
		public string LocalScheme { get; set; }
		
		/// <summary>
		/// Display a maintainance page when a user try to use the service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maintenanceMode")]
		public bool MaintenanceMode { get; set; }
		
		/// <summary>
		/// Specify headers that MUST be present on client request to route it. Useful to implement versioning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matchingHeaders")]
		public System.Collections.Generic.Dictionary<string, string> MatchingHeaders { get; set; }
		
		/// <summary>
		/// The root path on which the service is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matchingRoot")]
		public string MatchingRoot { get; set; }
		
		/// <summary>
		/// Just a bunch of random properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// The name of your service. Only for debug and human readability purposes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Host header will be overriden with Host of the target
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overrideHost")]
		public System.Nullable<System.Boolean> OverrideHost { get; set; }
		
		/// <summary>
		/// When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="privateApp")]
		public bool PrivateApp { get; set; }
		
		/// <summary>
		/// If you define a public pattern that is a little bit too much, you can make some of public URL private again
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privatePatterns")]
		public string[] PrivatePatterns { get; set; }
		
		/// <summary>
		/// By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicPatterns")]
		public string[] PublicPatterns { get; set; }
		
		/// <summary>
		/// If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectToLocal")]
		public System.Nullable<System.Boolean> RedirectToLocal { get; set; }
		
		/// <summary>
		/// The configuration for redirection per service
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirection")]
		public RedirectionSettings Redirection { get; set; }
		
		/// <summary>
		/// Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="root")]
		public string Root { get; set; }
		
		/// <summary>
		/// URI patterns excluded from secured communications
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secComExcludedPatterns")]
		public string[] SecComExcludedPatterns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="secComSettings")]
		public HSAlgoSettings SecComSettings { get; set; }
		
		/// <summary>
		/// When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ...
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sendOtoroshiHeadersBack")]
		public System.Nullable<System.Boolean> SendOtoroshiHeadersBack { get; set; }
		
		/// <summary>
		/// The configuration for statsd metrics push
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statsdConfig")]
		public StatsdConfig StatsdConfig { get; set; }
		
		/// <summary>
		/// The subdomain on which the service is available
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subdomain")]
		public string Subdomain { get; set; }
		
		/// <summary>
		/// The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Target[] Targets { get; set; }
		
		/// <summary>
		/// A reference to a request transformer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transformerRef")]
		public string TransformerRef { get; set; }
		
		/// <summary>
		/// The fact that this service will be seen by users and cannot be impacted by the Snow Monkey
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userFacing")]
		public System.Nullable<System.Boolean> UserFacing { get; set; }
		
		/// <summary>
		/// Send X-Forwarded-* headers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xForwardedHeaders")]
		public System.Nullable<System.Boolean> XForwardedHeaders { get; set; }
	}
	
	/// <summary>
	/// Strategy where signature and field values are verified, and then token si re-signed
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Sign
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algoSettings")]
		public HSAlgoSettings AlgoSettings { get; set; }
		
		/// <summary>
		/// String with value Sign
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Settings to verify the value of JWT token fields
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verificationSettings")]
		public VerificationSettings VerificationSettings { get; set; }
	}
	
	/// <summary>
	/// Administrator using just login/password tuple to access Otoroshi
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SimpleAdmin
	{
		
		/// <summary>
		/// The creation date of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public long CreatedAt { get; set; }
		
		/// <summary>
		/// The label for the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The hashed password of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Configuration for the faults that can be injected in requests. The name Snow Monkey is an hommage to Netflix's Chaos Monkey 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SnowMonkeyConfig
	{
		
		/// <summary>
		/// Configuration for the faults that can be injected in requests
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="chaosConfig")]
		public ChaosConfig ChaosConfig { get; set; }
		
		/// <summary>
		/// Whether or not outages will actualy impact requests
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dryRun")]
		public bool DryRun { get; set; }
		
		/// <summary>
		/// Whether or not this config is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Whether or not user facing apps. will be impacted by Snow Monkey
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="includeUserFacingDescriptors")]
		public bool IncludeUserFacingDescriptors { get; set; }
		
		/// <summary>
		/// Start of outage duration range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outageDurationFrom")]
		public int OutageDurationFrom { get; set; }
		
		/// <summary>
		/// End of outage duration range
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outageDurationTo")]
		public int OutageDurationTo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outageStrategy")]
		public OutageStrategy OutageStrategy { get; set; }
		
		/// <summary>
		/// Start time of Snow Monkey each day
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// Stop time of Snow Monkey each day
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stopTime")]
		public string StopTime { get; set; }
		
		/// <summary>
		/// Groups impacted by Snow Monkey. If empty, all groups will be impacted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetGroups")]
		public string[] TargetGroups { get; set; }
		
		/// <summary>
		/// Number of time per day each service will be outage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timesPerDay")]
		public int TimesPerDay { get; set; }
	}
	
	/// <summary>
	/// Live stats for a service or globally
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Stats
	{
		
		/// <summary>
		/// Number of calls on the specified service or globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="calls")]
		public long Calls { get; set; }
		
		/// <summary>
		/// The number of concurrent request currently
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="concurrentHandledRequests")]
		public long ConcurrentHandledRequests { get; set; }
		
		/// <summary>
		/// The amount of data sent to the specified service or Otoroshi globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataIn")]
		public long DataIn { get; set; }
		
		/// <summary>
		/// The rate of data sent to the specified service or Otoroshi globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataInRate")]
		public double DataInRate { get; set; }
		
		/// <summary>
		/// The amount of data sent from the specified service or Otoroshi globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataOut")]
		public long DataOut { get; set; }
		
		/// <summary>
		/// The rate of data sent from the specified service or Otoroshi globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataOutRate")]
		public double DataOutRate { get; set; }
		
		/// <summary>
		/// The average duration for a call
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public double Duration { get; set; }
		
		/// <summary>
		/// The average overhead time induced by Otoroshi for each call
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="overhead")]
		public double Overhead { get; set; }
		
		/// <summary>
		/// The rate of data sent from and to the specified service or Otoroshi globally
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rate")]
		public double Rate { get; set; }
	}
	
	/// <summary>
	/// Strategy where signature and field values are verified, trasnformed and then token si re-signed
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Transform
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algoSettings")]
		public HSAlgoSettings AlgoSettings { get; set; }
		
		/// <summary>
		/// Settings to transform a JWT token and its location
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transformSettings")]
		public TransformSettings TransformSettings { get; set; }
		
		/// <summary>
		/// String with value Transform
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Settings to verify the value of JWT token fields
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="verificationSettings")]
		public VerificationSettings VerificationSettings { get; set; }
	}
	
	/// <summary>
	/// Settings to transform a JWT token and its location
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TransformSettings
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public InQueryParam Location { get; set; }
		
		/// <summary>
		/// Settings to change fields of a JWT token
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mappingSettings")]
		public MappingSettings MappingSettings { get; set; }
	}
	
	/// <summary>
	/// Administrator using FIDO U2F device to access Otoroshi
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class U2FAdmin
	{
		
		/// <summary>
		/// The creation date of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public long CreatedAt { get; set; }
		
		/// <summary>
		/// The label for the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// The hashed password of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The U2F registration slug
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="registration")]
		public System.Collections.Generic.Dictionary<string, string> Registration { get; set; }
		
		/// <summary>
		/// The email address of the user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Settings to access a validation authority server
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ValidationAuthority
	{
		
		/// <summary>
		/// Bypass http calls, every certificates are valids
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alwaysValid")]
		public bool AlwaysValid { get; set; }
		
		/// <summary>
		/// The TTL for invalid access response caching
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="badTtl")]
		public long BadTtl { get; set; }
		
		/// <summary>
		/// The description of the settings
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The TTL for valid access response caching
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="goodTtl")]
		public long GoodTtl { get; set; }
		
		/// <summary>
		/// HTTP call headers
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// The host of the server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The id of the settings
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The HTTP method
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// The name of the settings
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Avoid caching responses
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="noCache")]
		public bool NoCache { get; set; }
		
		/// <summary>
		/// The URL path
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The call timeout
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public long Timeout { get; set; }
		
		/// <summary>
		/// The URL of the server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// The configuration for webhook
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WhebhookConfig
	{
		
		/// <summary>
		/// Optional headers
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public System.Collections.Generic.Dictionary<string, string> Headers { get; set; }
		
		/// <summary>
		/// URLs of the webhook
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string[] Url { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get all api keys
		/// Get all api keys
		/// AllApiKeys api/apikeys
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey[]> AllApiKeysAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/apikeys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all global auth. module configs
		/// Get all global auth. module configs
		/// FindAllGlobalAuthModules api/auths
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string[]> FindAllGlobalAuthModulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/auths";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create one global auth. module config
		/// Create one global auth. module config
		/// CreateGlobalAuthModule api/auths
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<LdapAuthModuleConfig> CreateGlobalAuthModuleAsync(LdapAuthModuleConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/auths";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<LdapAuthModuleConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete one global auth. module config
		/// Delete one global auth. module config
		/// DeleteGlobalAuthModule api/auths/{id}
		/// </summary>
		/// <param name="id">The auth. config id id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteGlobalAuthModuleAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/auths/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get one global auth. module configs
		/// Get one global auth. module configs
		/// FindGlobalAuthModuleById api/auths/{id}
		/// </summary>
		/// <param name="id">The auth. config id</param>
		/// <returns>Successful operation</returns>
		public async Task<LdapAuthModuleConfig> FindGlobalAuthModuleByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/auths/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<LdapAuthModuleConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update one global auth. module config
		/// Update one global auth. module config
		/// PatchGlobalAuthModule api/auths/{id}
		/// </summary>
		/// <param name="id">The auth. config id</param>
		/// <returns>Successful operation</returns>
		public async Task<LdapAuthModuleConfig> PatchGlobalAuthModuleAsync(string id, PatchGlobalAuthModulePatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/auths/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<LdapAuthModuleConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update one global auth. module config
		/// Update one global auth. module config
		/// UpdateGlobalAuthModule api/auths/{id}
		/// </summary>
		/// <param name="id">The auth. config id</param>
		/// <returns>Successful operation</returns>
		public async Task<LdapAuthModuleConfig> UpdateGlobalAuthModuleAsync(string id, LdapAuthModuleConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/auths/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<LdapAuthModuleConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all certificates
		/// Get all certificates
		/// AllCerts api/certificates
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Certificate[]> AllCertsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/certificates";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Certificate[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create one certificate
		/// Create one certificate
		/// CreateCert api/certificates
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Certificate> CreateCertAsync(Certificate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/certificates";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Certificate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete one certificate by id
		/// Delete one certificate by id
		/// DeleteCert api/certificates/{id}
		/// </summary>
		/// <param name="id">The certificate id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteCertAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/certificates/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get one certificate by id
		/// Get one certificate by id
		/// OneCert api/certificates/{id}
		/// </summary>
		/// <param name="id">The auth. config id</param>
		/// <returns>Successful operation</returns>
		public async Task<Certificate> OneCertAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/certificates/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Certificate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update one certificate by id
		/// Update one certificate by id
		/// PatchCert api/certificates/{id}
		/// </summary>
		/// <param name="id">The certificate id</param>
		/// <returns>Successful operation</returns>
		public async Task<Certificate> PatchCertAsync(string id, PatchCertPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/certificates/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Certificate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update one certificate by id
		/// Update one certificate by id
		/// PutCert api/certificates/{id}
		/// </summary>
		/// <param name="id">The certificate id</param>
		/// <returns>Successful operation</returns>
		public async Task<Certificate> PutCertAsync(string id, Certificate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/certificates/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Certificate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all validation authoritiess
		/// Get all validation authoritiess
		/// FindAllClientValidators api/client-validators
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ValidationAuthority[]> FindAllClientValidatorsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/client-validators";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ValidationAuthority[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create one validation authorities
		/// Create one validation authorities
		/// CreateClientValidator api/client-validators
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ValidationAuthority> CreateClientValidatorAsync(ValidationAuthority requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/client-validators";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ValidationAuthority>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete one validation authorities by id
		/// Delete one validation authorities by id
		/// DeleteClientValidator api/client-validators/{id}
		/// </summary>
		/// <param name="id">The validation authorities id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteClientValidatorAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/client-validators/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get one validation authorities by id
		/// Get one validation authorities by id
		/// FindClientValidatorById api/client-validators/{id}
		/// </summary>
		/// <param name="id">The auth. config id</param>
		/// <returns>Successful operation</returns>
		public async Task<ValidationAuthority> FindClientValidatorByIdAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/client-validators/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ValidationAuthority>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update one validation authorities by id
		/// Update one validation authorities by id
		/// PatchClientValidator api/client-validators/{id}
		/// </summary>
		/// <param name="id">The validation authorities id</param>
		/// <returns>Successful operation</returns>
		public async Task<ValidationAuthority> PatchClientValidatorAsync(string id, PatchClientValidatorPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/client-validators/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ValidationAuthority>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update one validation authorities by id
		/// Update one validation authorities by id
		/// UpdateClientValidator api/client-validators/{id}
		/// </summary>
		/// <param name="id">The validation authorities id</param>
		/// <returns>Successful operation</returns>
		public async Task<ValidationAuthority> UpdateClientValidatorAsync(string id, ValidationAuthority requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/client-validators/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ValidationAuthority>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all data exporter configs
		/// Get all data exporter configs
		/// FindAllDataExporters api/data-exporter-configs
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DataExporterConfig[]> FindAllDataExportersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/data-exporter-configs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DataExporterConfig[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new data exporter config
		/// Create a new data exporter config
		/// CreateDataExporterConfig api/data-exporter-configs
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DataExporterConfig> CreateDataExporterConfigAsync(DataExporterConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/data-exporter-configs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DataExporterConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a data exporter config
		/// Delete a data exporter config
		/// DeletebulkDataExporterConfig api/data-exporter-configs/_bulk
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DeletebulkDataExporterConfigReturn[]> DeletebulkDataExporterConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/data-exporter-configs/_bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DeletebulkDataExporterConfigReturn[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all data exporter configs
		/// Get all data exporter configs
		/// DataExporterTemplate api/data-exporter-configs/_template
		/// </summary>
		/// <param name="type">The data exporter config type</param>
		/// <returns>Successful operation</returns>
		public async Task<DataExporterConfig> DataExporterTemplateAsync(string type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/data-exporter-configs/_template?type=" + (type==null? "" : System.Uri.EscapeDataString(type));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DataExporterConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a data exporter config
		/// Delete a data exporter config
		/// DeleteDataExporterConfig api/data-exporter-configs/{dataExporterConfigId}
		/// </summary>
		/// <param name="dataExporterConfigId">The data exporter config id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteDataExporterConfigAsync(string dataExporterConfigId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/data-exporter-configs/"+ (dataExporterConfigId==null? "" : System.Uri.EscapeDataString(dataExporterConfigId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a data exporter config
		/// Get a data exporter config
		/// FindDataExporterConfigById api/data-exporter-configs/{dataExporterConfigId}
		/// </summary>
		/// <param name="dataExporterConfigId">The data exporter config id</param>
		/// <returns>Successful operation</returns>
		public async Task<DataExporterConfig> FindDataExporterConfigByIdAsync(string dataExporterConfigId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/data-exporter-configs/"+ (dataExporterConfigId==null? "" : System.Uri.EscapeDataString(dataExporterConfigId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DataExporterConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a data exporter config with a diff
		/// Update a data exporter config with a diff
		/// PatchDataExporterConfig api/data-exporter-configs/{dataExporterConfigId}
		/// </summary>
		/// <param name="dataExporterConfigId">The data exporter config id</param>
		/// <returns>Successful operation</returns>
		public async Task<DataExporterConfig> PatchDataExporterConfigAsync(string dataExporterConfigId, PatchDataExporterConfigPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/data-exporter-configs/"+ (dataExporterConfigId==null? "" : System.Uri.EscapeDataString(dataExporterConfigId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DataExporterConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a data exporter config
		/// Update a data exporter config
		/// UpdateDataExporterConfig api/data-exporter-configs/{dataExporterConfigId}
		/// </summary>
		/// <param name="dataExporterConfigId">The data exporter config id</param>
		/// <returns>Successful operation</returns>
		public async Task<DataExporterConfig> UpdateDataExporterConfigAsync(string dataExporterConfigId, DataExporterConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/data-exporter-configs/"+ (dataExporterConfigId==null? "" : System.Uri.EscapeDataString(dataExporterConfigId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DataExporterConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the full configuration of Otoroshi
		/// Get the full configuration of Otoroshi
		/// GlobalConfig api/globalconfig
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GlobalConfig> GlobalConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/globalconfig";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GlobalConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the global configuration with a diff
		/// Update the global configuration with a diff
		/// PatchGlobalConfig api/globalconfig
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GlobalConfig> PatchGlobalConfigAsync(PatchGlobalConfigPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/globalconfig";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GlobalConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the global configuration
		/// Update the global configuration
		/// PutGlobalConfig api/globalconfig
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GlobalConfig> PutGlobalConfigAsync(GlobalConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/globalconfig";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GlobalConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all service groups
		/// Get all service groups
		/// AllServiceGroups api/groups
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Group[]> AllServiceGroupsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Group[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new service group
		/// Create a new service group
		/// CreateGroup api/groups
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Group> CreateGroupAsync(Group requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Group>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all api keys for the group of a service
		/// Get all api keys for the group of a service
		/// ApiKeysFromGroup api/groups/{groupId}/apikeys
		/// </summary>
		/// <param name="groupId">The api key group id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey[]> ApiKeysFromGroupAsync(string groupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"/apikeys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new api key for a group
		/// Create a new api key for a group
		/// CreateApiKeyFromGroup api/groups/{groupId}/apikeys
		/// </summary>
		/// <param name="groupId">The api key group id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> CreateApiKeyFromGroupAsync(string groupId, ApiKey requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"/apikeys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an api key
		/// Delete an api key for a specified service group
		/// DeleteApiKeyFromGroup api/groups/{groupId}/apikeys/{clientId}
		/// </summary>
		/// <param name="groupId">The api key group id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteApiKeyFromGroupAsync(string groupId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an api key
		/// Get an api key for a specified service group
		/// ApiKeyFromGroup api/groups/{groupId}/apikeys/{clientId}
		/// </summary>
		/// <param name="groupId">The api key group id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> ApiKeyFromGroupAsync(string groupId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an api key with a diff
		/// Update an api key for a specified service descriptor with a diff
		/// PatchApiKeyFromGroup api/groups/{groupId}/apikeys/{clientId}
		/// </summary>
		/// <param name="groupId">The api key group id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> PatchApiKeyFromGroupAsync(string groupId, string clientId, PatchApiKeyFromGroupPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an api key
		/// Update an api key for a specified service group
		/// UpdateApiKeyFromGroup api/groups/{groupId}/apikeys/{clientId}
		/// </summary>
		/// <param name="groupId">The api key group id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> UpdateApiKeyFromGroupAsync(string groupId, string clientId, ApiKey requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset the quota state of an api key
		/// Reset the quota state of an api key
		/// ResetApiKeyFromGroupQuotas api/groups/{groupId}/apikeys/{clientId}/quotas
		/// </summary>
		/// <param name="groupId">The api key group id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<Quotas> ResetApiKeyFromGroupQuotasAsync(string groupId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/quotas";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Quotas>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the quota state of an api key
		/// Get the quota state of an api key
		/// ApiKeyFromGroupQuotas api/groups/{groupId}/apikeys/{clientId}/quotas
		/// </summary>
		/// <param name="groupId">The api key group id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<Quotas> ApiKeyFromGroupQuotasAsync(string groupId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/quotas";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Quotas>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a service group
		/// Delete a service group
		/// DeleteGroup api/groups/{serviceGroupId}
		/// </summary>
		/// <param name="serviceGroupId">The service group id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteGroupAsync(string serviceGroupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (serviceGroupId==null? "" : System.Uri.EscapeDataString(serviceGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a service group
		/// Get a service group
		/// ServiceGroup api/groups/{serviceGroupId}
		/// </summary>
		/// <param name="serviceGroupId">The service group id</param>
		/// <returns>Successful operation</returns>
		public async Task<Group> ServiceGroupAsync(string serviceGroupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (serviceGroupId==null? "" : System.Uri.EscapeDataString(serviceGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Group>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a service group with a diff
		/// Update a service group with a diff
		/// PatchGroup api/groups/{serviceGroupId}
		/// </summary>
		/// <param name="serviceGroupId">The service group id</param>
		/// <returns>Successful operation</returns>
		public async Task<Group> PatchGroupAsync(string serviceGroupId, PatchGroupPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (serviceGroupId==null? "" : System.Uri.EscapeDataString(serviceGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Group>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a service group
		/// Update a service group
		/// UpdateGroup api/groups/{serviceGroupId}
		/// </summary>
		/// <param name="serviceGroupId">The service group id</param>
		/// <returns>Successful operation</returns>
		public async Task<Group> UpdateGroupAsync(string serviceGroupId, Group requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (serviceGroupId==null? "" : System.Uri.EscapeDataString(serviceGroupId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Group>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all services descriptor for a group
		/// Get all services descriptor for a group
		/// ServiceGroupServices api/groups/{serviceGroupId}/services
		/// </summary>
		/// <param name="serviceGroupId">The service group id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey[]> ServiceGroupServicesAsync(string serviceGroupId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/groups/"+ (serviceGroupId==null? "" : System.Uri.EscapeDataString(serviceGroupId))+"/services";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Import the full state of Otoroshi as a file
		/// Import the full state of Otoroshi as a file
		/// FullImportFromFile api/import
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Done> FullImportFromFileAsync(ImportExport requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/import";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Done>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get global otoroshi stats
		/// Get global otoroshi stats
		/// GlobalLiveStats api/live
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Stats> GlobalLiveStatsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/live";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Stats>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get live feed of otoroshi stats
		/// Get live feed of global otoroshi stats (global) or for a service {id}
		/// ServiceLiveStats api/live/{id}
		/// </summary>
		/// <param name="id">The service id or global for otoroshi stats</param>
		/// <returns>Successful operation</returns>
		public async Task<Stats> ServiceLiveStatsAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/live/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Stats>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Export the full state of Otoroshi
		/// Export the full state of Otoroshi
		/// FullExport api/otoroshi.json
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ImportExport> FullExportAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/otoroshi.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportExport>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Import the full state of Otoroshi
		/// Import the full state of Otoroshi
		/// FullImport api/otoroshi.json
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Done> FullImportAsync(ImportExport requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/otoroshi.json";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Done>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all scripts
		/// Get all scripts
		/// FindAllScripts api/scripts
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Script[]> FindAllScriptsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/scripts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Script[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new script
		/// Create a new script
		/// CreateScript api/scripts
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Script> CreateScriptAsync(Script requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/scripts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Script>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Compile a script
		/// Compile a script
		/// CompileScript api/scripts/_compile
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ScriptCompilationResult> CompileScriptAsync(Script requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/scripts/_compile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ScriptCompilationResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a script
		/// Delete a script
		/// DeleteScript api/scripts/{scriptId}
		/// </summary>
		/// <param name="scriptId">The script id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteScriptAsync(string scriptId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/scripts/"+ (scriptId==null? "" : System.Uri.EscapeDataString(scriptId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a script
		/// Get a script
		/// FindScriptById api/scripts/{scriptId}
		/// </summary>
		/// <param name="scriptId">The script id</param>
		/// <returns>Successful operation</returns>
		public async Task<Script> FindScriptByIdAsync(string scriptId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/scripts/"+ (scriptId==null? "" : System.Uri.EscapeDataString(scriptId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Script>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a script with a diff
		/// Update a script with a diff
		/// PatchScript api/scripts/{scriptId}
		/// </summary>
		/// <param name="scriptId">The script id</param>
		/// <returns>Successful operation</returns>
		public async Task<Script> PatchScriptAsync(string scriptId, PatchScriptPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/scripts/"+ (scriptId==null? "" : System.Uri.EscapeDataString(scriptId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Script>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a script
		/// Update a script
		/// UpdateScript api/scripts/{scriptId}
		/// </summary>
		/// <param name="scriptId">The script id</param>
		/// <returns>Successful operation</returns>
		public async Task<Script> UpdateScriptAsync(string scriptId, Script requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/scripts/"+ (scriptId==null? "" : System.Uri.EscapeDataString(scriptId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Script>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all services
		/// Get all services
		/// AllServices api/services
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Service[]> AllServicesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new service descriptor
		/// Create a new service descriptor
		/// CreateService api/services
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Service> CreateServiceAsync(Service requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a service descriptor
		/// Delete a service descriptor
		/// DeleteService api/services/{serviceId}
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteServiceAsync(string serviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a service descriptor
		/// Get a service descriptor
		/// Service api/services/{serviceId}
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Service> ServiceAsync(string serviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a service descriptor with a diff
		/// Update a service descriptor with a diff
		/// PatchService api/services/{serviceId}
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Service> PatchServiceAsync(string serviceId, PatchServicePatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a service descriptor
		/// Update a service descriptor
		/// UpdateService api/services/{serviceId}
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Service> UpdateServiceAsync(string serviceId, Service requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all api keys for the group of a service
		/// Get all api keys for the group of a service
		/// ApiKeys api/services/{serviceId}/apikeys
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey[]> ApiKeysAsync(string serviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new api key for a service
		/// CreateApiKey api/services/{serviceId}/apikeys
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> CreateApiKeyAsync(string serviceId, ApiKey requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an api key
		/// Delete an api key for a specified service descriptor
		/// DeleteApiKey api/services/{serviceId}/apikeys/{clientId}
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteApiKeyAsync(string serviceId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an api key
		/// Get an api key for a specified service descriptor
		/// ApiKey api/services/{serviceId}/apikeys/{clientId}
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> ApiKeyAsync(string serviceId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an api key with a diff
		/// Update an api key for a specified service descriptor with a diff
		/// PatchApiKey api/services/{serviceId}/apikeys/{clientId}
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> PatchApiKeyAsync(string serviceId, string clientId, PatchApiKeyPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an api key
		/// Update an api key for a specified service descriptor
		/// UpdateApiKey api/services/{serviceId}/apikeys/{clientId}
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> UpdateApiKeyAsync(string serviceId, string clientId, ApiKey requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the group of an api key
		/// Get the group of an api key
		/// ApiKeyGroup api/services/{serviceId}/apikeys/{clientId}/group
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<Group> ApiKeyGroupAsync(string serviceId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/group";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Group>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset the quota state of an api key
		/// Reset the quota state of an api key
		/// ResetApiKeyQuotas api/services/{serviceId}/apikeys/{clientId}/quotas
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<Quotas> ResetApiKeyQuotasAsync(string serviceId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/quotas";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Quotas>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the quota state of an api key
		/// Get the quota state of an api key
		/// ApiKeyQuotas api/services/{serviceId}/apikeys/{clientId}/quotas
		/// </summary>
		/// <param name="serviceId">The api key service id</param>
		/// <param name="clientId">the api key id</param>
		/// <returns>Successful operation</returns>
		public async Task<Quotas> ApiKeyQuotasAsync(string serviceId, string clientId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/apikeys/"+ (clientId==null? "" : System.Uri.EscapeDataString(clientId))+"/quotas";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Quotas>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a service descriptor target
		/// Delete a service descriptor target
		/// ServiceDeleteTarget api/services/{serviceId}/targets
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Target[]> ServiceDeleteTargetAsync(string serviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Target[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a service descriptor targets
		/// Get a service descriptor targets
		/// ServiceTargets api/services/{serviceId}/targets
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Target[]> ServiceTargetsAsync(string serviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Target[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a service descriptor targets
		/// Update a service descriptor targets
		/// UpdateServiceTargets api/services/{serviceId}/targets
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Target[]> UpdateServiceTargetsAsync(string serviceId, UpdateServiceTargetsPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Target[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a target to a service descriptor
		/// Add a target to a service descriptor
		/// ServiceAddTarget api/services/{serviceId}/targets
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Target[]> ServiceAddTargetAsync(string serviceId, Target requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/targets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Target[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a service descriptor error template
		/// Delete a service descriptor error template
		/// DeleteServiceTemplate api/services/{serviceId}/template
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteServiceTemplateAsync(string serviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/template";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a service descriptor error template
		/// Get a service descriptor error template
		/// ServiceTemplate api/services/{serviceId}/template
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<ErrorTemplate> ServiceTemplateAsync(string serviceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/template";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ErrorTemplate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a service descriptor error template
		/// Update a service descriptor targets
		/// CreateServiceTemplate api/services/{serviceId}/template
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<ErrorTemplate> CreateServiceTemplateAsync(string serviceId, ErrorTemplate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/template";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ErrorTemplate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an error template to a service descriptor
		/// Update an error template to a service descriptor
		/// UpdateServiceTemplate api/services/{serviceId}/template
		/// </summary>
		/// <param name="serviceId">The service id</param>
		/// <returns>Successful operation</returns>
		public async Task<ErrorTemplate> UpdateServiceTemplateAsync(string serviceId, ErrorTemplate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/services/"+ (serviceId==null? "" : System.Uri.EscapeDataString(serviceId))+"/template";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ErrorTemplate>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start the Snow Monkey
		/// Start the Snow Monkey
		/// StartSnowMonkey api/snowmonkey/_start
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Done> StartSnowMonkeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/snowmonkey/_start";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Done>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stop the Snow Monkey
		/// Stop the Snow Monkey
		/// StopSnowMonkey api/snowmonkey/_stop
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Done> StopSnowMonkeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/snowmonkey/_stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Done>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get current Snow Monkey config
		/// Get current Snow Monkey config
		/// GetSnowMonkeyConfig api/snowmonkey/config
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SnowMonkeyConfig> GetSnowMonkeyConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/snowmonkey/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SnowMonkeyConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update current Snow Monkey config
		/// Update current Snow Monkey config
		/// PatchSnowMonkey api/snowmonkey/config
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SnowMonkeyConfig> PatchSnowMonkeyAsync(Group requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/snowmonkey/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SnowMonkeyConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update current Snow Monkey config
		/// Update current Snow Monkey config
		/// UpdateSnowMonkey api/snowmonkey/config
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SnowMonkeyConfig> UpdateSnowMonkeyAsync(Group requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/snowmonkey/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SnowMonkeyConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset Snow Monkey Outages for the day
		/// Reset Snow Monkey Outages for the day
		/// ResetSnowMonkey api/snowmonkey/outages
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Done> ResetSnowMonkeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/snowmonkey/outages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Done>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all current Snow Monkey ourages
		/// Get all current Snow Monkey ourages
		/// GetSnowMonkeyOutages api/snowmonkey/outages
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Outage[]> GetSnowMonkeyOutagesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/snowmonkey/outages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Outage[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all global JWT verifiers
		/// Get all global JWT verifiers
		/// FindAllGlobalJwtVerifiers api/verifiers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GlobalJwtVerifier[]> FindAllGlobalJwtVerifiersAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/verifiers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GlobalJwtVerifier[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create one global JWT verifiers
		/// Create one global JWT verifiers
		/// CreateGlobalJwtVerifier api/verifiers
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<GlobalJwtVerifier> CreateGlobalJwtVerifierAsync(GlobalJwtVerifier requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/verifiers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GlobalJwtVerifier>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete one global JWT verifiers
		/// Delete one global JWT verifiers
		/// DeleteGlobalJwtVerifier api/verifiers/{verifierId}
		/// </summary>
		/// <param name="verifierId">The jwt verifier id</param>
		/// <returns>Successful operation</returns>
		public async Task<Deleted> DeleteGlobalJwtVerifierAsync(string verifierId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/verifiers/"+ (verifierId==null? "" : System.Uri.EscapeDataString(verifierId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deleted>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get one global JWT verifiers
		/// Get one global JWT verifiers
		/// FindGlobalJwtVerifiersById api/verifiers/{verifierId}
		/// </summary>
		/// <param name="verifierId">The jwt verifier id</param>
		/// <returns>Successful operation</returns>
		public async Task<GlobalJwtVerifier> FindGlobalJwtVerifiersByIdAsync(string verifierId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/verifiers/"+ (verifierId==null? "" : System.Uri.EscapeDataString(verifierId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GlobalJwtVerifier>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update one global JWT verifiers
		/// Update one global JWT verifiers
		/// PatchGlobalJwtVerifier api/verifiers/{verifierId}
		/// </summary>
		/// <param name="verifierId">The jwt verifier id</param>
		/// <returns>Successful operation</returns>
		public async Task<GlobalJwtVerifier> PatchGlobalJwtVerifierAsync(string verifierId, PatchGlobalJwtVerifierPatchBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/verifiers/"+ (verifierId==null? "" : System.Uri.EscapeDataString(verifierId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GlobalJwtVerifier>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update one global JWT verifiers
		/// Update one global JWT verifiers
		/// UpdateGlobalJwtVerifier api/verifiers/{verifierId}
		/// </summary>
		/// <param name="verifierId">The jwt verifier id</param>
		/// <returns>Successful operation</returns>
		public async Task<GlobalJwtVerifier> UpdateGlobalJwtVerifierAsync(string verifierId, GlobalJwtVerifier requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/verifiers/"+ (verifierId==null? "" : System.Uri.EscapeDataString(verifierId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GlobalJwtVerifier>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return current Otoroshi health
		/// Import the full state of Otoroshi as a file
		/// Health health
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<OtoroshiHealth> HealthAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OtoroshiHealth>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all environments
		/// Get all environments provided by the current Otoroshi instance
		/// AllLines lines
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<string> AllLinesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lines";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all services for an environment
		/// Get all services for an environment provided by the current Otoroshi instance
		/// ServicesForALine lines/{line}/services
		/// </summary>
		/// <param name="line">The environment where to find services</param>
		/// <returns>Successful operation</returns>
		public async Task<Service[]> ServicesForALineAsync(string line, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lines/"+ (line==null? "" : System.Uri.EscapeDataString(line))+"/services";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a template of an Otoroshi Api Key
		/// Get a template of an Otoroshi Api Key. The generated entity is not persisted
		/// InitiateApiKey new/apikey
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ApiKey> InitiateApiKeyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "new/apikey";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ApiKey>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a template of an Otoroshi service group
		/// Get a template of an Otoroshi service group. The generated entity is not persisted
		/// InitiateServiceGroup new/group
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Group> InitiateServiceGroupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "new/group";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Group>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a template of an Otoroshi service descriptor
		/// Get a template of an Otoroshi service descriptor. The generated entity is not persisted
		/// InitiateService new/service
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<Service> InitiateServiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "new/service";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class PatchGlobalAuthModulePatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchCertPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchClientValidatorPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class DeletebulkDataExporterConfigReturn
	{
		
		/// <summary>
		/// Whether the action was carried out correctly or not
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// Data exporter id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Boolean> Id { get; set; }
		
		/// <summary>
		/// Status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<DeletebulkDataExporterConfigReturnStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DeletebulkDataExporterConfigReturnStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="200")]
		_200 = 0,
	}
	
	public class PatchDataExporterConfigPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchGlobalConfigPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchApiKeyFromGroupPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchGroupPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchScriptPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchServicePatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchApiKeyPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class UpdateServiceTargetsPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
	
	public class PatchGlobalJwtVerifierPatchBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="op")]
		public PatchElementOp Op { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public object Value { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
