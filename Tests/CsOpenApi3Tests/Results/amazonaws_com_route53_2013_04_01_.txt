//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivateKeySigningKeyResponse
	{
		
		/// <summary>
		/// A complex type that describes change information about changes made to your hosted zone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	/// <summary>
	/// A complex type that describes change information about changes made to your hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChangeInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset SubmittedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChangeStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PENDING")]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INSYNC")]
		INSYNC = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConcurrentModification
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchKeySigningKey
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidKeySigningKeyStatus
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidSigningStatus
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidKMSArn
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidInput
	{
	}
	
	/// <summary>
	/// A complex type that contains the response information for the <code>AssociateVPCWithHostedZone</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateVPCWithHostedZoneResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VPCRegion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-1")]
		usMinuseastMinus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-2")]
		usMinuseastMinus2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-1")]
		usMinuswestMinus1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-2")]
		usMinuswestMinus2 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-1")]
		euMinuswestMinus1 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-2")]
		euMinuswestMinus2 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-3")]
		euMinuswestMinus3 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-central-1")]
		euMinuscentralMinus1 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-central-2")]
		euMinuscentralMinus2 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-east-1")]
		apMinuseastMinus1 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me-south-1")]
		meMinussouthMinus1 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-gov-west-1")]
		usMinusgovMinuswestMinus1 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-gov-east-1")]
		usMinusgovMinuseastMinus1 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-iso-east-1")]
		usMinusisoMinuseastMinus1 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-iso-west-1")]
		usMinusisoMinuswestMinus1 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-isob-east-1")]
		usMinusisobMinuseastMinus1 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me-central-1")]
		meMinuscentralMinus1 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-1")]
		apMinussoutheastMinus1 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-2")]
		apMinussoutheastMinus2 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-3")]
		apMinussoutheastMinus3 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-south-1")]
		apMinussouthMinus1 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-south-2")]
		apMinussouthMinus2 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-1")]
		apMinusnortheastMinus1 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-2")]
		apMinusnortheastMinus2 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-3")]
		apMinusnortheastMinus3 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-north-1")]
		euMinusnorthMinus1 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sa-east-1")]
		saMinuseastMinus1 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ca-central-1")]
		caMinuscentralMinus1 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cn-north-1")]
		cnMinusnorthMinus1 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="af-south-1")]
		afMinussouthMinus1 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-south-1")]
		euMinussouthMinus1 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-south-2")]
		euMinussouthMinus2 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-4")]
		apMinussoutheastMinus4 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="il-central-1")]
		ilMinuscentralMinus1 = 33,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchHostedZone
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotAuthorizedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidVPCId
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicZoneVPCAssociation
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictingDomainExists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LimitsExceeded
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PriorRequestNotComplete
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChangeCidrCollectionResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the CIDR collection change.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CidrCollectionChange
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string LocationName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CidrCollectionChangeAction Action { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] CidrList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CidrCollectionChangeAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PUT")]
		PUT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETE_IF_EXISTS")]
		DELETE_IF_EXISTS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchCidrCollectionException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CidrCollectionVersionMismatchException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CidrBlockInUseException
	{
	}
	
	/// <summary>
	/// A complex type containing the response for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChangeResourceRecordSetsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchHealthCheck
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidChangeBatch
	{
	}
	
	/// <summary>
	/// Empty response for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChangeTagsForResourceResponse
	{
	}
	
	/// <summary>
	/// A complex type that contains information about a tag that you want to add or edit for the specified health check or hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThrottlingException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateCidrCollectionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CidrCollection Collection { get; set; }
	}
	
	/// <summary>
	/// A complex type that identifies a CIDR collection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CidrCollection
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CidrCollectionAlreadyExistsException
	{
	}
	
	/// <summary>
	/// A complex type containing the response information for the new health check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateHealthCheckResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HealthCheck HealthCheck { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about one health check that is associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheck
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CallerReference { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LinkedService LinkedService { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HealthCheckConfig HealthCheckConfig { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int HealthCheckVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CloudWatchAlarmConfiguration CloudWatchAlarmConfiguration { get; set; }
	}
	
	/// <summary>
	/// If a health check or hosted zone was created by another service, <code>LinkedService</code> is a complex type that describes the service that created the resource. When a resource is created by another service, you can't edit or delete it using Amazon Route 53. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LinkedService
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ServicePrincipal { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the health check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string IPAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HealthCheckType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourcePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FullyQualifiedDomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SearchString { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> RequestInterval { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> FailureThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> MeasureLatency { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Inverted { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> HealthThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ChildHealthChecks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSNI { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AlarmIdentifier AlarmIdentifier { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InsufficientDataHealthStatus InsufficientDataHealthStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RoutingControlArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum HealthCheckType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HTTP")]
		HTTP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HTTPS")]
		HTTPS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HTTP_STR_MATCH")]
		HTTP_STR_MATCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HTTPS_STR_MATCH")]
		HTTPS_STR_MATCH = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TCP")]
		TCP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CALCULATED")]
		CALCULATED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CLOUDWATCH_METRIC")]
		CLOUDWATCH_METRIC = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RECOVERY_CONTROL")]
		RECOVERY_CONTROL = 7,
	}
	
	/// <summary>
	/// A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AlarmIdentifier
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CloudWatchRegion Region { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CloudWatchRegion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-1")]
		usMinuseastMinus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-2")]
		usMinuseastMinus2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-1")]
		usMinuswestMinus1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-2")]
		usMinuswestMinus2 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ca-central-1")]
		caMinuscentralMinus1 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-central-1")]
		euMinuscentralMinus1 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-central-2")]
		euMinuscentralMinus2 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-1")]
		euMinuswestMinus1 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-2")]
		euMinuswestMinus2 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-3")]
		euMinuswestMinus3 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-east-1")]
		apMinuseastMinus1 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me-south-1")]
		meMinussouthMinus1 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me-central-1")]
		meMinuscentralMinus1 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-south-1")]
		apMinussouthMinus1 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-south-2")]
		apMinussouthMinus2 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-1")]
		apMinussoutheastMinus1 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-2")]
		apMinussoutheastMinus2 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-3")]
		apMinussoutheastMinus3 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-1")]
		apMinusnortheastMinus1 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-2")]
		apMinusnortheastMinus2 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-3")]
		apMinusnortheastMinus3 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-north-1")]
		euMinusnorthMinus1 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sa-east-1")]
		saMinuseastMinus1 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cn-northwest-1")]
		cnMinusnorthwestMinus1 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cn-north-1")]
		cnMinusnorthMinus1 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="af-south-1")]
		afMinussouthMinus1 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-south-1")]
		euMinussouthMinus1 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-south-2")]
		euMinussouthMinus2 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-gov-west-1")]
		usMinusgovMinuswestMinus1 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-gov-east-1")]
		usMinusgovMinuseastMinus1 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-iso-east-1")]
		usMinusisoMinuseastMinus1 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-iso-west-1")]
		usMinusisoMinuswestMinus1 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-isob-east-1")]
		usMinusisobMinuseastMinus1 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-4")]
		apMinussoutheastMinus4 = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="il-central-1")]
		ilMinuscentralMinus1 = 34,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum InsufficientDataHealthStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Healthy")]
		Healthy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Unhealthy")]
		Unhealthy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LastKnownStatus")]
		LastKnownStatus = 2,
	}
	
	/// <summary>
	/// A complex type that contains information about the CloudWatch alarm that Amazon Route 53 is monitoring for this health check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudWatchAlarmConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int EvaluationPeriods { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public double Threshold { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ComparisonOperator ComparisonOperator { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Period { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MetricName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Namespace { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Statistic Statistic { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Dimensions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ComparisonOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GreaterThanOrEqualToThreshold")]
		GreaterThanOrEqualToThreshold = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GreaterThanThreshold")]
		GreaterThanThreshold = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LessThanThreshold")]
		LessThanThreshold = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LessThanOrEqualToThreshold")]
		LessThanOrEqualToThreshold = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Statistic
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Average")]
		Average = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Sum")]
		Sum = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SampleCount")]
		SampleCount = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Maximum")]
		Maximum = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Minimum")]
		Minimum = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyHealthChecks
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckAlreadyExists
	{
	}
	
	/// <summary>
	/// A complex type containing the response information for the hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateHostedZoneResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HostedZone HostedZone { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DelegationSet DelegationSet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VPC VPC { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains general information about the hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZone
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CallerReference { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HostedZoneConfig Config { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ResourceRecordSetCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LinkedService LinkedService { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains an optional comment about your hosted zone. If you don't want to specify a comment, omit both the <code>HostedZoneConfig</code> and <code>Comment</code> elements.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZoneConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> PrivateZone { get; set; }
	}
	
	/// <summary>
	/// A complex type that lists the name servers in a delegation set, as well as the <code>CallerReference</code> and the <code>ID</code> for the delegation set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DelegationSet
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CallerReference { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] NameServers { get; set; }
	}
	
	/// <summary>
	/// <p>(Private hosted zones only) A complex type that contains information about an Amazon VPC.</p> <p>If you associate a private hosted zone with an Amazon VPC when you make a <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateHostedZone.html">CreateHostedZone</a> request, the following parameters are also required.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VPC
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VPCRegion VPCRegion { get; set; }
		
		/// <summary>
		/// (Private hosted zones only) The ID of an Amazon VPC. 
		/// Max length: 1024
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(1024)]
		public string VPCId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidDomainName
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZoneAlreadyExists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyHostedZones
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DelegationSetNotAvailable
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchDelegationSet
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DelegationSetNotReusable
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateKeySigningKeyResponse
	{
		
		/// <summary>
		/// A complex type that describes change information about changes made to your hosted zone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySigningKey KeySigningKey { get; set; }
	}
	
	/// <summary>
	/// A key-signing key (KSK) is a complex type that represents a public/private key pair. The private key is used to generate a digital signature for the zone signing key (ZSK). The public key is stored in the DNS and is used to authenticate the ZSK. A KSK is always associated with a hosted zone; it cannot exist by itself.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeySigningKey
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KmsArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Flag { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SigningAlgorithmMnemonic { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SigningAlgorithmType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DigestAlgorithmMnemonic { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DigestAlgorithmType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> KeyTag { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DigestValue { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PublicKey { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DSRecord { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DNSKEYRecord { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset LastModifiedDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidArgument
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidKeySigningKeyName
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeySigningKeyAlreadyExists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyKeySigningKeys
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateQueryLoggingConfigResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public QueryLoggingConfig QueryLoggingConfig { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about a configuration for DNS query logging.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryLoggingConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CloudWatchLogsLogGroupArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchCloudWatchLogsLogGroup
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QueryLoggingConfigAlreadyExists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InsufficientCloudWatchLogsResourcePolicy
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateReusableDelegationSetResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DelegationSet DelegationSet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DelegationSetAlreadyCreated
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZoneNotFound
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DelegationSetAlreadyReusable
	{
	}
	
	/// <summary>
	/// A complex type that contains the response information for the <code>CreateTrafficPolicy</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTrafficPolicyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TrafficPolicy TrafficPolicy { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains settings for a traffic policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrafficPolicy
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Version { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RRType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Document { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RRType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SOA")]
		SOA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="A")]
		A = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TXT")]
		TXT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NS")]
		NS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CNAME")]
		CNAME = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MX")]
		MX = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NAPTR")]
		NAPTR = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PTR")]
		PTR = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SRV")]
		SRV = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SPF")]
		SPF = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AAAA")]
		AAAA = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CAA")]
		CAA = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DS")]
		DS = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyTrafficPolicies
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrafficPolicyAlreadyExists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidTrafficPolicyDocument
	{
	}
	
	/// <summary>
	/// A complex type that contains the response information for the <code>CreateTrafficPolicyInstance</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTrafficPolicyInstanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TrafficPolicyInstance TrafficPolicyInstance { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains settings for the new traffic policy instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrafficPolicyInstance
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TTL { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TrafficPolicyVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RRType TrafficPolicyType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyTrafficPolicyInstances
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchTrafficPolicy
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrafficPolicyInstanceAlreadyExists
	{
	}
	
	/// <summary>
	/// A complex type that contains the response information for the <code>CreateTrafficPolicyVersion</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTrafficPolicyVersionResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TrafficPolicy TrafficPolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyTrafficPolicyVersionsForCurrentPolicy
	{
	}
	
	/// <summary>
	/// A complex type that contains the response information from a <code>CreateVPCAssociationAuthorization</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVPCAssociationAuthorizationResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VPC VPC { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyVPCAssociationAuthorizations
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeactivateKeySigningKeyResponse
	{
		
		/// <summary>
		/// A complex type that describes change information about changes made to your hosted zone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeySigningKeyInUse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeySigningKeyInParentDSRecord
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteCidrCollectionResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CidrCollectionInUseException
	{
	}
	
	/// <summary>
	/// An empty element.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteHealthCheckResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckInUse
	{
	}
	
	/// <summary>
	/// A complex type that contains the response to a <code>DeleteHostedZone</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteHostedZoneResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZoneNotEmpty
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteKeySigningKeyResponse
	{
		
		/// <summary>
		/// A complex type that describes change information about changes made to your hosted zone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteQueryLoggingConfigResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchQueryLoggingConfig
	{
	}
	
	/// <summary>
	/// An empty element.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteReusableDelegationSetResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DelegationSetInUse
	{
	}
	
	/// <summary>
	/// An empty element.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTrafficPolicyResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrafficPolicyInUse
	{
	}
	
	/// <summary>
	/// An empty element.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTrafficPolicyInstanceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchTrafficPolicyInstance
	{
	}
	
	/// <summary>
	/// Empty response for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVPCAssociationAuthorizationResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VPCAssociationAuthorizationNotFound
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisableHostedZoneDNSSECResponse
	{
		
		/// <summary>
		/// A complex type that describes change information about changes made to your hosted zone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DNSSECNotFound
	{
	}
	
	/// <summary>
	/// A complex type that contains the response information for the disassociate request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateVPCFromHostedZoneResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VPCAssociationNotFound
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LastVPCAssociation
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnableHostedZoneDNSSECResponse
	{
		
		/// <summary>
		/// A complex type that describes change information about changes made to your hosted zone.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KeySigningKeyWithActiveStatusNotFound
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZonePartiallyDelegated
	{
	}
	
	/// <summary>
	/// A complex type that contains the requested limit. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAccountLimitResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AccountLimit Limit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Count { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the type of limit that you specified in the request and the current value for that limit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccountLimit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AccountLimitType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AccountLimitType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAX_HEALTH_CHECKS_BY_OWNER")]
		MAX_HEALTH_CHECKS_BY_OWNER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAX_HOSTED_ZONES_BY_OWNER")]
		MAX_HOSTED_ZONES_BY_OWNER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER")]
		MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAX_REUSABLE_DELEGATION_SETS_BY_OWNER")]
		MAX_REUSABLE_DELEGATION_SETS_BY_OWNER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAX_TRAFFIC_POLICIES_BY_OWNER")]
		MAX_TRAFFIC_POLICIES_BY_OWNER = 4,
	}
	
	/// <summary>
	/// A complex type that contains the <code>ChangeInfo</code> element.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChangeResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeInfo ChangeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchChange
	{
	}
	
	/// <summary>
	/// A complex type that contains the <code>CheckerIpRanges</code> element.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetCheckerIpRangesResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] CheckerIpRanges { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetDNSSECResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DNSSECStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public KeySigningKey[] KeySigningKeys { get; set; }
	}
	
	/// <summary>
	/// A string repesenting the status of DNSSEC signing.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DNSSECStatus
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ServeSignature { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the specified geolocation code.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetGeoLocationResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public GeoLocationDetails GeoLocationDetails { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the codes and full continent, country, and subdivision names for the specified <code>geolocation</code> code.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GeoLocationDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ContinentCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContinentName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CountryCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CountryName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubdivisionCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubdivisionName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchGeoLocation
	{
	}
	
	/// <summary>
	/// A complex type that contains the response to a <code>GetHealthCheck</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHealthCheckResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HealthCheck HealthCheck { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IncompatibleVersion
	{
	}
	
	/// <summary>
	/// A complex type that contains the response to a <code>GetHealthCheckCount</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHealthCheckCountResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int HealthCheckCount { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response to a <code>GetHealthCheckLastFailureReason</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHealthCheckLastFailureReasonResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] HealthCheckObservations { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response to a <code>GetHealthCheck</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHealthCheckStatusResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] HealthCheckObservations { get; set; }
	}
	
	/// <summary>
	/// A complex type that contain the response to a <code>GetHostedZone</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHostedZoneResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HostedZone HostedZone { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DelegationSet DelegationSet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] VPCs { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response to a <code>GetHostedZoneCount</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHostedZoneCountResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int HostedZoneCount { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the requested limit. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHostedZoneLimitResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HostedZoneLimit Limit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Count { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the type of limit that you specified in the request and the current value for that limit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZoneLimit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HostedZoneLimitType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum HostedZoneLimitType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAX_RRSETS_BY_ZONE")]
		MAX_RRSETS_BY_ZONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAX_VPCS_ASSOCIATED_BY_ZONE")]
		MAX_VPCS_ASSOCIATED_BY_ZONE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZoneNotPrivate
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetQueryLoggingConfigResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public QueryLoggingConfig QueryLoggingConfig { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response to the <code>GetReusableDelegationSet</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetReusableDelegationSetResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DelegationSet DelegationSet { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the requested limit. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetReusableDelegationSetLimitResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ReusableDelegationSetLimit Limit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Count { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the type of limit that you specified in the request and the current value for that limit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReusableDelegationSetLimit
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ReusableDelegationSetLimitType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReusableDelegationSetLimitType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAX_ZONES_BY_REUSABLE_DELEGATION_SET")]
		MAX_ZONES_BY_REUSABLE_DELEGATION_SET = 0,
	}
	
	/// <summary>
	/// A complex type that contains the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetTrafficPolicyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TrafficPolicy TrafficPolicy { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the resource record sets that Amazon Route 53 created based on a specified traffic policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetTrafficPolicyInstanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TrafficPolicyInstance TrafficPolicyInstance { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the resource record sets that Amazon Route 53 created based on a specified traffic policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetTrafficPolicyInstanceCountResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TrafficPolicyInstanceCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCidrBlocksResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CidrBlockSummary[] CidrBlocks { get; set; }
	}
	
	/// <summary>
	/// A complex type that lists the CIDR blocks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CidrBlockSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CidrBlock { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LocationName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NoSuchCidrLocationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCidrCollectionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CollectionSummary[] CidrCollections { get; set; }
	}
	
	/// <summary>
	/// A complex type that is an entry in an <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CidrCollection.html">CidrCollection</a> array.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CollectionSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCidrLocationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LocationSummary[] CidrLocations { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the CIDR location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocationSummary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string LocationName { get; set; }
	}
	
	/// <summary>
	/// A complex type containing the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGeoLocationsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] GeoLocationDetailsList { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextContinentCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextCountryCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextSubdivisionCode { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response to a <code>ListHealthChecks</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListHealthChecksResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] HealthChecks { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextMarker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListHostedZonesResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] HostedZones { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextMarker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListHostedZonesByNameResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] HostedZones { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DNSName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextDNSName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextHostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListHostedZonesByVPCResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] HostedZoneSummaries { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InvalidPaginationToken
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListQueryLoggingConfigsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] QueryLoggingConfigs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains list information for the resource record set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListResourceRecordSetsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] ResourceRecordSets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextRecordName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RRType NextRecordType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextRecordIdentifier { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the reusable delegation sets that are associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListReusableDelegationSetsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] DelegationSets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextMarker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the health checks or hosted zones for which you want to list tags.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ResourceTagSet ResourceTagSet { get; set; }
	}
	
	/// <summary>
	/// A complex type containing a resource and its associated tags.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceTagSet
	{
		
		[System.Runtime.Serialization.DataMember()]
		public TagResourceType ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourceId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TagResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="healthcheck")]
		healthcheck = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hostedzone")]
		hostedzone = 1,
	}
	
	/// <summary>
	/// A complex type containing tags for the specified resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourcesResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] ResourceTagSets { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPoliciesResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] TrafficPolicySummaries { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyIdMarker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPolicyInstancesResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] TrafficPolicyInstances { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneIdMarker { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyInstanceNameMarker { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RRType TrafficPolicyInstanceTypeMarker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPolicyInstancesByHostedZoneResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] TrafficPolicyInstances { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyInstanceNameMarker { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RRType TrafficPolicyInstanceTypeMarker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPolicyInstancesByPolicyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] TrafficPolicyInstances { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneIdMarker { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyInstanceNameMarker { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RRType TrafficPolicyInstanceTypeMarker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPolicyVersionsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] TrafficPolicies { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool IsTruncated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyVersionMarker { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string MaxItems { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVPCAssociationAuthorizationsResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] VPCs { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response to a <code>TestDNSAnswer</code> request. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TestDNSAnswerResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Nameserver { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string RecordName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RRType RecordType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] RecordData { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ResponseCode { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Protocol { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response to the <code>UpdateHealthCheck</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateHealthCheckResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HealthCheck HealthCheck { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum HealthCheckRegion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-1")]
		usMinuseastMinus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-1")]
		usMinuswestMinus1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-2")]
		usMinuswestMinus2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-1")]
		euMinuswestMinus1 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-1")]
		apMinussoutheastMinus1 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-2")]
		apMinussoutheastMinus2 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-1")]
		apMinusnortheastMinus1 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sa-east-1")]
		saMinuseastMinus1 = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ResettableElementName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FullyQualifiedDomainName")]
		FullyQualifiedDomainName = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="Regions")]
		Regions = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ResourcePath")]
		ResourcePath = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ChildHealthChecks")]
		ChildHealthChecks = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckVersionMismatch
	{
	}
	
	/// <summary>
	/// A complex type that contains the response to the <code>UpdateHostedZoneComment</code> request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateHostedZoneCommentResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HostedZone HostedZone { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the response information for the traffic policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTrafficPolicyCommentResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TrafficPolicy TrafficPolicy { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the resource record sets that Amazon Route 53 created based on a specified traffic policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTrafficPolicyInstanceResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public TrafficPolicyInstance TrafficPolicyInstance { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictingTypes
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ActivateKeySigningKeyRequest
	{
	}
	
	/// <summary>
	/// <p> <i>Alias resource record sets only:</i> Information about the Amazon Web Services resource, such as a CloudFront distribution or an Amazon S3 bucket, that you want to route traffic to.</p> <p>When creating resource record sets for a private hosted zone, note the following:</p> <ul> <li> <p>For information about creating failover resource record sets in a private hosted zone, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-private-hosted-zones.html">Configuring Failover in a Private Hosted Zone</a>.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AliasTarget
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DNSName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EvaluateTargetHealth { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the request to associate a VPC with a private hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateVPCWithHostedZoneRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VPC VPC { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ChangeAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATE")]
		CREATE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETE")]
		DELETE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPSERT")]
		UPSERT = 2,
	}
	
	/// <summary>
	/// Information about the resource record set to create or delete.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceRecordSet
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RRType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SetIdentifier { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Weight { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceRecordSetRegion Region { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GeoLocation GeoLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceRecordSetFailover Failover { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> MultiValueAnswer { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TTL { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ResourceRecords { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AliasTarget AliasTarget { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HealthCheckId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyInstanceId { get; set; }
		
		/// <summary>
		/// <p>The object that is specified in resource record set object when you are linking a resource record set to a CIDR location.</p> <p>A <code>LocationName</code> with an asterisk * can be used to create a default CIDR record. <code>CollectionId</code> is still required for default record.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CidrRoutingConfig CidrRoutingConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ResourceRecordSetRegion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-1")]
		usMinuseastMinus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-2")]
		usMinuseastMinus2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-1")]
		usMinuswestMinus1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-2")]
		usMinuswestMinus2 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ca-central-1")]
		caMinuscentralMinus1 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-1")]
		euMinuswestMinus1 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-2")]
		euMinuswestMinus2 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-3")]
		euMinuswestMinus3 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-central-1")]
		euMinuscentralMinus1 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-central-2")]
		euMinuscentralMinus2 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-1")]
		apMinussoutheastMinus1 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-2")]
		apMinussoutheastMinus2 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-3")]
		apMinussoutheastMinus3 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-1")]
		apMinusnortheastMinus1 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-2")]
		apMinusnortheastMinus2 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-3")]
		apMinusnortheastMinus3 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-north-1")]
		euMinusnorthMinus1 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sa-east-1")]
		saMinuseastMinus1 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cn-north-1")]
		cnMinusnorthMinus1 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cn-northwest-1")]
		cnMinusnorthwestMinus1 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-east-1")]
		apMinuseastMinus1 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me-south-1")]
		meMinussouthMinus1 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me-central-1")]
		meMinuscentralMinus1 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-south-1")]
		apMinussouthMinus1 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-south-2")]
		apMinussouthMinus2 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="af-south-1")]
		afMinussouthMinus1 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-south-1")]
		euMinussouthMinus1 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-south-2")]
		euMinussouthMinus2 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-4")]
		apMinussoutheastMinus4 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="il-central-1")]
		ilMinuscentralMinus1 = 29,
	}
	
	/// <summary>
	/// A complex type that contains information about a geographic location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GeoLocation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ContinentCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CountryCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SubdivisionCode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ResourceRecordSetFailover
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PRIMARY")]
		PRIMARY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SECONDARY")]
		SECONDARY = 1,
	}
	
	/// <summary>
	/// <p>The object that is specified in resource record set object when you are linking a resource record set to a CIDR location.</p> <p>A <code>LocationName</code> with an asterisk * can be used to create a default CIDR record. <code>CollectionId</code> is still required for default record.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CidrRoutingConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CollectionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string LocationName { get; set; }
	}
	
	/// <summary>
	/// The information for each resource record set that you want to change.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Change
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeAction Action { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ResourceRecordSet ResourceRecordSet { get; set; }
	}
	
	/// <summary>
	/// The information for a change request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChangeBatch
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] Changes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChangeCidrCollectionRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> CollectionVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CidrCollectionChange[] Changes { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains change information for the resource record set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChangeResourceRecordSetsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ChangeBatch ChangeBatch { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the tags that you want to add, edit, or delete.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ChangeTagsForResourceRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AddTags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] RemoveTagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateCidrCollectionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CallerReference { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the health check request information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateHealthCheckRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CallerReference { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HealthCheckConfig HealthCheckConfig { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the request to create a public or private hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateHostedZoneRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VPC VPC { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CallerReference { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HostedZoneConfig HostedZoneConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DelegationSetId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateKeySigningKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CallerReference { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string KeyManagementServiceArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateQueryLoggingConfigRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CloudWatchLogsLogGroupArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateReusableDelegationSetRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CallerReference { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the resource record sets that you want to create based on a specified traffic policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTrafficPolicyInstanceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TTL { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TrafficPolicyVersion { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the traffic policy that you want to create.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTrafficPolicyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Document { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the traffic policy that you want to create a new version for.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTrafficPolicyVersionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Document { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the request to authorize associating a VPC with your private hosted zone. Authorization is only required when a private hosted zone and a VPC were created by using different accounts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVPCAssociationAuthorizationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VPC VPC { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeactivateKeySigningKeyRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteCidrCollectionRequest
	{
	}
	
	/// <summary>
	/// This action deletes a health check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteHealthCheckRequest
	{
	}
	
	/// <summary>
	/// A request to delete a hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteHostedZoneRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteKeySigningKeyRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteQueryLoggingConfigRequest
	{
	}
	
	/// <summary>
	/// A request to delete a reusable delegation set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteReusableDelegationSetRequest
	{
	}
	
	/// <summary>
	/// A request to delete a specified traffic policy instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTrafficPolicyInstanceRequest
	{
	}
	
	/// <summary>
	/// A request to delete a specified traffic policy version.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTrafficPolicyRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains information about the request to remove authorization to associate a VPC that was created by one Amazon Web Services account with a hosted zone that was created with a different Amazon Web Services account. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVPCAssociationAuthorizationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VPC VPC { get; set; }
	}
	
	/// <summary>
	/// For the metric that the CloudWatch alarm is associated with, a complex type that contains information about one dimension.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Dimension
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisableHostedZoneDNSSECRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains information about the VPC that you want to disassociate from a specified private hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateVPCFromHostedZoneRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VPC VPC { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EnableHostedZoneDNSSECRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains information about the request to create a hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetAccountLimitRequest
	{
	}
	
	/// <summary>
	/// The input for a GetChange request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetChangeRequest
	{
	}
	
	/// <summary>
	/// Empty request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetCheckerIpRangesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetDNSSECRequest
	{
	}
	
	/// <summary>
	/// A request for information about whether a specified geographic location is supported for Amazon Route 53 geolocation resource record sets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetGeoLocationRequest
	{
	}
	
	/// <summary>
	/// A request for the number of health checks that are associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHealthCheckCountRequest
	{
	}
	
	/// <summary>
	/// A request for the reason that a health check failed most recently.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHealthCheckLastFailureReasonRequest
	{
	}
	
	/// <summary>
	/// A request to get information about a specified health check. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHealthCheckRequest
	{
	}
	
	/// <summary>
	/// A request to get the status for a health check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHealthCheckStatusRequest
	{
	}
	
	/// <summary>
	/// A request to retrieve a count of all the hosted zones that are associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHostedZoneCountRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains information about the request to create a hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHostedZoneLimitRequest
	{
	}
	
	/// <summary>
	/// A request to get information about a specified hosted zone. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetHostedZoneRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetQueryLoggingConfigRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains information about the request to create a hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetReusableDelegationSetLimitRequest
	{
	}
	
	/// <summary>
	/// A request to get information about a specified reusable delegation set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetReusableDelegationSetRequest
	{
	}
	
	/// <summary>
	/// Request to get the number of traffic policy instances that are associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetTrafficPolicyInstanceCountRequest
	{
	}
	
	/// <summary>
	/// Gets information about a specified traffic policy instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetTrafficPolicyInstanceRequest
	{
	}
	
	/// <summary>
	/// Gets information about a specific traffic policy version.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetTrafficPolicyRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains the status that one Amazon Route 53 health checker reports and the time of the health check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatusReport
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CheckedTime { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the last failure reason as reported by one Amazon Route 53 health checker.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckObservation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public HealthCheckRegion Region { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IPAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StatusReport StatusReport { get; set; }
	}
	
	/// <summary>
	/// A complex type that identifies a hosted zone that a specified Amazon VPC is associated with and the owner of the hosted zone. If there is a value for <code>OwningAccount</code>, there is no value for <code>OwningService</code>, and vice versa. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZoneOwner
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string OwningAccount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OwningService { get; set; }
	}
	
	/// <summary>
	/// In the response to a <code>ListHostedZonesByVPC</code> request, the <code>HostedZoneSummaries</code> element contains one <code>HostedZoneSummary</code> element for each hosted zone that the specified Amazon VPC is associated with. Each <code>HostedZoneSummary</code> element contains the hosted zone name and ID, and information about who owns the hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostedZoneSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostedZoneId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public HostedZoneOwner Owner { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCidrBlocksRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCidrCollectionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListCidrLocationsRequest
	{
	}
	
	/// <summary>
	/// A request to get a list of geographic locations that Amazon Route 53 supports for geolocation resource record sets. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGeoLocationsRequest
	{
	}
	
	/// <summary>
	/// A request to retrieve a list of the health checks that are associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListHealthChecksRequest
	{
	}
	
	/// <summary>
	/// Retrieves a list of the public and private hosted zones that are associated with the current Amazon Web Services account in ASCII order by domain name. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListHostedZonesByNameRequest
	{
	}
	
	/// <summary>
	/// Lists all the private hosted zones that a specified VPC is associated with, regardless of which Amazon Web Services account created the hosted zones.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListHostedZonesByVPCRequest
	{
	}
	
	/// <summary>
	/// A request to retrieve a list of the public and private hosted zones that are associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListHostedZonesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListQueryLoggingConfigsRequest
	{
	}
	
	/// <summary>
	/// A request for the resource record sets that are associated with a specified hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListResourceRecordSetsRequest
	{
	}
	
	/// <summary>
	/// A request to get a list of the reusable delegation sets that are associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListReusableDelegationSetsRequest
	{
	}
	
	/// <summary>
	/// A complex type containing information about a request for a list of the tags that are associated with an individual resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains information about the health checks or hosted zones for which you want to list tags.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourcesRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] ResourceIds { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains the information about the request to list the traffic policies that are associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPoliciesRequest
	{
	}
	
	/// <summary>
	/// A request for the traffic policy instances that you created in a specified hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPolicyInstancesByHostedZoneRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains the information about the request to list your traffic policy instances.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPolicyInstancesByPolicyRequest
	{
	}
	
	/// <summary>
	/// A request to get information about the traffic policy instances that you created by using the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPolicyInstancesRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains the information about the request to list your traffic policies.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficPolicyVersionsRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains information about that can be associated with your hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVPCAssociationAuthorizationsRequest
	{
	}
	
	/// <summary>
	/// <p>Information specific to the resource record.</p> <note> <p>If you're creating an alias resource record set, omit <code>ResourceRecord</code>.</p> </note>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceRecord
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Gets the value that Amazon Route 53 returns in response to a DNS request for a specified record name and type. You can optionally specify the IP address of a DNS resolver, an EDNS0 client subnet IP address, and a subnet mask. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TestDNSAnswerRequest
	{
	}
	
	/// <summary>
	/// A complex type that contains information about the latest version of one traffic policy that is associated with the current Amazon Web Services account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrafficPolicySummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RRType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int LatestVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TrafficPolicyCount { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about a request to update a health check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateHealthCheckRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> HealthCheckVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string IPAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ResourcePath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string FullyQualifiedDomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SearchString { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> FailureThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Inverted { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> HealthThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ChildHealthChecks { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> EnableSNI { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AlarmIdentifier AlarmIdentifier { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InsufficientDataHealthStatus InsufficientDataHealthStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ResetElements { get; set; }
	}
	
	/// <summary>
	/// A request to update the comment for a hosted zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateHostedZoneCommentRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the traffic policy that you want to update the comment for.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTrafficPolicyCommentRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Comment { get; set; }
	}
	
	/// <summary>
	/// A complex type that contains information about the resource record sets that you want to update based on a specified traffic policy instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTrafficPolicyInstanceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TTL { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TrafficPolicyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TrafficPolicyVersion { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Activates a key-signing key (KSK) so that it can be used for signing by DNSSEC. This operation changes the KSK status to <code>ACTIVE</code>.
		/// ActivateKeySigningKey 2013-04-01/keysigningkey/{HostedZoneId}/{Name}/activate
		/// </summary>
		/// <param name="HostedZoneId">A unique string used to identify a hosted zone.</param>
		/// <param name="Name">A string used to identify a key-signing key (KSK). <code>Name</code> can include numbers, letters, and underscores (_). <code>Name</code> must be unique for each key-signing key in the same hosted zone.</param>
		/// <returns>Success</returns>
		public async Task ActivateKeySigningKeyAsync(string HostedZoneId, string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/keysigningkey/"+ (HostedZoneId==null? "" : System.Uri.EscapeDataString(HostedZoneId))+"/"+ (Name==null? "" : System.Uri.EscapeDataString(Name))+"/activate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a CIDR collection in the current Amazon Web Services account. The collection must be empty before it can be deleted.
		/// DeleteCidrCollection 2013-04-01/cidrcollection/{CidrCollectionId}
		/// </summary>
		/// <param name="CidrCollectionId">The UUID of the collection to delete.</param>
		/// <returns>Success</returns>
		public async Task DeleteCidrCollectionAsync(string CidrCollectionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/cidrcollection/"+ (CidrCollectionId==null? "" : System.Uri.EscapeDataString(CidrCollectionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated list of CIDR locations for the given collection (metadata only, does not include CIDR blocks).
		/// ListCidrLocations 2013-04-01/cidrcollection/{CidrCollectionId}
		/// </summary>
		/// <param name="CidrCollectionId">The CIDR collection ID.</param>
		/// <param name="nexttoken"><p>An opaque pagination token to indicate where the service is to begin enumerating results.</p> <p>If no value is provided, the listing of results starts from the beginning.</p></param>
		/// <param name="maxresults">The maximum number of CIDR collection locations to return in the response.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task ListCidrLocationsAsync(string CidrCollectionId, string nexttoken, string maxresults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/cidrcollection/"+ (CidrCollectionId==null? "" : System.Uri.EscapeDataString(CidrCollectionId))+"&nexttoken=" + (nexttoken==null? "" : System.Uri.EscapeDataString(nexttoken))+"&maxresults=" + (maxresults==null? "" : System.Uri.EscapeDataString(maxresults))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Lists tags for one health check or hosted zone. </p> <p>For information about using tags for cost allocation, see <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">Using Cost Allocation Tags</a> in the <i>Billing and Cost Management User Guide</i>.</p>
		/// ListTagsForResource 2013-04-01/tags/{ResourceType}/{ResourceId}
		/// </summary>
		/// <param name="ResourceType"><p>The type of the resource.</p> <ul> <li> <p>The resource type for health checks is <code>healthcheck</code>.</p> </li> <li> <p>The resource type for hosted zones is <code>hostedzone</code>.</p> </li> </ul></param>
		/// <param name="ResourceId">The ID of the resource for which you want to retrieve tags.</param>
		/// <returns>Success</returns>
		public async Task ListTagsForResourceAsync(TagResourceType ResourceType, string ResourceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/tags/"+ResourceType+"/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated list of CIDR collections in the Amazon Web Services account (metadata only).
		/// ListCidrCollections 2013-04-01/cidrcollection
		/// </summary>
		/// <param name="nexttoken"><p>An opaque pagination token to indicate where the service is to begin enumerating results.</p> <p>If no value is provided, the listing of results starts from the beginning.</p></param>
		/// <param name="maxresults">The maximum number of CIDR collections to return in the response.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task ListCidrCollectionsAsync(string nexttoken, string maxresults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/cidrcollection?nexttoken=" + (nexttoken==null? "" : System.Uri.EscapeDataString(nexttoken))+"&maxresults=" + (maxresults==null? "" : System.Uri.EscapeDataString(maxresults))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of the health checks that are associated with the current Amazon Web Services account.
		/// ListHealthChecks 2013-04-01/healthcheck
		/// </summary>
		/// <param name="marker"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more health checks. To get another group, submit another <code>ListHealthChecks</code> request. </p> <p>For the value of <code>marker</code>, specify the value of <code>NextMarker</code> from the previous response, which is the ID of the first health check that Amazon Route 53 will return if you submit another request.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more health checks to get.</p></param>
		/// <param name="maxitems">The maximum number of health checks that you want <code>ListHealthChecks</code> to return in response to the current request. Amazon Route 53 returns a maximum of 100 items. If you set <code>MaxItems</code> to a value greater than 100, Route 53 returns only the first 100 health checks. </param>
		/// <param name="MaxItems">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task ListHealthChecksAsync(string marker, string maxitems, string MaxItems, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/healthcheck?marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems))+"&MaxItems=" + (MaxItems==null? "" : System.Uri.EscapeDataString(MaxItems))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves a list of the public and private hosted zones that are associated with the current Amazon Web Services account. The response includes a <code>HostedZones</code> child element for each hosted zone.</p> <p>Amazon Route 53 returns a maximum of 100 items in each response. If you have a lot of hosted zones, you can use the <code>maxitems</code> parameter to list them in groups of up to 100.</p>
		/// ListHostedZones 2013-04-01/hostedzone
		/// </summary>
		/// <param name="marker"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more hosted zones. To get more hosted zones, submit another <code>ListHostedZones</code> request. </p> <p>For the value of <code>marker</code>, specify the value of <code>NextMarker</code> from the previous response, which is the ID of the first hosted zone that Amazon Route 53 will return if you submit another request.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more hosted zones to get.</p></param>
		/// <param name="maxitems">(Optional) The maximum number of hosted zones that you want Amazon Route 53 to return. If you have more than <code>maxitems</code> hosted zones, the value of <code>IsTruncated</code> in the response is <code>true</code>, and the value of <code>NextMarker</code> is the hosted zone ID of the first hosted zone that Route 53 will return if you submit another request.</param>
		/// <param name="delegationsetid">If you're using reusable delegation sets and you want to list all of the hosted zones that are associated with a reusable delegation set, specify the ID of that reusable delegation set. </param>
		/// <param name="MaxItems">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task ListHostedZonesAsync(string marker, string maxitems, string delegationsetid, string MaxItems, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzone?marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems))+"&delegationsetid=" + (delegationsetid==null? "" : System.Uri.EscapeDataString(delegationsetid))+"&MaxItems=" + (MaxItems==null? "" : System.Uri.EscapeDataString(MaxItems))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the configurations for DNS query logging that are associated with the current Amazon Web Services account or the configuration that is associated with a specified hosted zone.</p> <p>For more information about DNS query logs, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a>. Additional information, including the format of DNS query logs, appears in <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries</a> in the <i>Amazon Route 53 Developer Guide</i>.</p>
		/// ListQueryLoggingConfigs 2013-04-01/queryloggingconfig
		/// </summary>
		/// <param name="hostedzoneid"><p>(Optional) If you want to list the query logging configuration that is associated with a hosted zone, specify the ID in <code>HostedZoneId</code>. </p> <p>If you don't specify a hosted zone ID, <code>ListQueryLoggingConfigs</code> returns all of the configurations that are associated with the current Amazon Web Services account.</p></param>
		/// <param name="nexttoken"><p>(Optional) If the current Amazon Web Services account has more than <code>MaxResults</code> query logging configurations, use <code>NextToken</code> to get the second and subsequent pages of results.</p> <p>For the first <code>ListQueryLoggingConfigs</code> request, omit this value.</p> <p>For the second and subsequent requests, get the value of <code>NextToken</code> from the previous response and specify that value for <code>NextToken</code> in the request.</p></param>
		/// <param name="maxresults"><p>(Optional) The maximum number of query logging configurations that you want Amazon Route 53 to return in response to the current request. If the current Amazon Web Services account has more than <code>MaxResults</code> configurations, use the value of <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListQueryLoggingConfigs.html#API_ListQueryLoggingConfigs_RequestSyntax">NextToken</a> in the response to get the next page of results.</p> <p>If you don't specify a value for <code>MaxResults</code>, Route 53 returns up to 100 configurations.</p></param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task ListQueryLoggingConfigsAsync(string hostedzoneid, string nexttoken, string maxresults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/queryloggingconfig?hostedzoneid=" + (hostedzoneid==null? "" : System.Uri.EscapeDataString(hostedzoneid))+"&nexttoken=" + (nexttoken==null? "" : System.Uri.EscapeDataString(nexttoken))+"&maxresults=" + (maxresults==null? "" : System.Uri.EscapeDataString(maxresults))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of the reusable delegation sets that are associated with the current Amazon Web Services account.
		/// ListReusableDelegationSets 2013-04-01/delegationset
		/// </summary>
		/// <param name="marker"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more reusable delegation sets. To get another group, submit another <code>ListReusableDelegationSets</code> request. </p> <p>For the value of <code>marker</code>, specify the value of <code>NextMarker</code> from the previous response, which is the ID of the first reusable delegation set that Amazon Route 53 will return if you submit another request.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more reusable delegation sets to get.</p></param>
		/// <param name="maxitems">The number of reusable delegation sets that you want Amazon Route 53 to return in the response to this request. If you specify a value greater than 100, Route 53 returns only the first 100 reusable delegation sets.</param>
		/// <returns>Success</returns>
		public async Task ListReusableDelegationSetsAsync(string marker, string maxitems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/delegationset?marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets a list of the VPCs that were created by other accounts and that can be associated with a specified hosted zone because you've submitted one or more <code>CreateVPCAssociationAuthorization</code> requests. </p> <p>The response includes a <code>VPCs</code> element with a <code>VPC</code> child element for each VPC that can be associated with the hosted zone.</p>
		/// ListVPCAssociationAuthorizations 2013-04-01/hostedzone/{Id}/authorizevpcassociation
		/// </summary>
		/// <param name="Id">The ID of the hosted zone for which you want a list of VPCs that can be associated with the hosted zone.</param>
		/// <param name="nexttoken"> <i>Optional</i>: If a response includes a <code>NextToken</code> element, there are more VPCs that can be associated with the specified hosted zone. To get the next page of results, submit another request, and include the value of <code>NextToken</code> from the response in the <code>nexttoken</code> parameter in another <code>ListVPCAssociationAuthorizations</code> request.</param>
		/// <param name="maxresults"> <i>Optional</i>: An integer that specifies the maximum number of VPCs that you want Amazon Route 53 to return. If you don't specify a value for <code>MaxResults</code>, Route 53 returns up to 50 VPCs per page.</param>
		/// <returns>Success</returns>
		public async Task ListVPCAssociationAuthorizationsAsync(string Id, string nexttoken, string maxresults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzone/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/authorizevpcassociation&nexttoken=" + (nexttoken==null? "" : System.Uri.EscapeDataString(nexttoken))+"&maxresults=" + (maxresults==null? "" : System.Uri.EscapeDataString(maxresults));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deactivates a key-signing key (KSK) so that it will not be used for signing by DNSSEC. This operation changes the KSK status to <code>INACTIVE</code>.
		/// DeactivateKeySigningKey 2013-04-01/keysigningkey/{HostedZoneId}/{Name}/deactivate
		/// </summary>
		/// <param name="HostedZoneId">A unique string used to identify a hosted zone.</param>
		/// <param name="Name">A string used to identify a key-signing key (KSK).</param>
		/// <returns>Success</returns>
		public async Task DeactivateKeySigningKeyAsync(string HostedZoneId, string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/keysigningkey/"+ (HostedZoneId==null? "" : System.Uri.EscapeDataString(HostedZoneId))+"/"+ (Name==null? "" : System.Uri.EscapeDataString(Name))+"/deactivate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a health check.</p> <important> <p>Amazon Route 53 does not prevent you from deleting a health check even if the health check is associated with one or more resource record sets. If you delete a health check and you don't update the associated resource record sets, the future status of the health check can't be predicted and may change. This will affect the routing of DNS queries for your DNS failover configuration. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/health-checks-creating-deleting.html#health-checks-deleting.html">Replacing and Deleting Health Checks</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> </important> <p>If you're using Cloud Map and you configured Cloud Map to create a Route 53 health check when you register an instance, you can't use the Route 53 <code>DeleteHealthCheck</code> command to delete the health check. The health check is deleted automatically when you deregister the instance; there can be a delay of several hours before the health check is deleted from Route 53. </p>
		/// DeleteHealthCheck 2013-04-01/healthcheck/{HealthCheckId}
		/// </summary>
		/// <param name="HealthCheckId">The ID of the health check that you want to delete.</param>
		/// <returns>Success</returns>
		public async Task DeleteHealthCheckAsync(string HealthCheckId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/healthcheck/"+ (HealthCheckId==null? "" : System.Uri.EscapeDataString(HealthCheckId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a specified health check.
		/// GetHealthCheck 2013-04-01/healthcheck/{HealthCheckId}
		/// </summary>
		/// <param name="HealthCheckId">The identifier that Amazon Route 53 assigned to the health check when you created it. When you add or update a resource record set, you use this value to specify which health check to use. The value can be up to 64 characters long.</param>
		/// <returns>Success</returns>
		public async Task GetHealthCheckAsync(string HealthCheckId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/healthcheck/"+ (HealthCheckId==null? "" : System.Uri.EscapeDataString(HealthCheckId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a hosted zone.</p> <p>If the hosted zone was created by another service, such as Cloud Map, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DeleteHostedZone.html#delete-public-hosted-zone-created-by-another-service">Deleting Public Hosted Zones That Were Created by Another Service</a> in the <i>Amazon Route53 Developer Guide</i> for information about how to delete it. (The process is the same for public and private hosted zones that were created by another service.)</p> <p>If you want to keep your domain registration but you want to stop routing internet traffic to your website or web application, we recommend that you delete resource record sets in the hosted zone instead of deleting the hosted zone.</p> <important> <p>If you delete a hosted zone, you can't undelete it. You must create a new hosted zone and update the name servers for your domain registration, which can require up to 48 hours to take effect. (If you delegated responsibility for a subdomain to a hosted zone and you delete the child hosted zone, you must update the name servers in the parent hosted zone.) In addition, if you delete a hosted zone, someone could hijack the domain and route traffic to their own resources using your domain name.</p> </important> <p>If you want to avoid the monthly charge for the hosted zone, you can transfer DNS service for the domain to a free DNS service. When you transfer DNS service, you have to update the name servers for the domain registration. If the domain is registered with Route53, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_domains_UpdateDomainNameservers.html">UpdateDomainNameservers</a> for information about how to replace Route53 name servers with name servers for the new DNS service. If the domain is registered with another registrar, use the method provided by the registrar to update name servers for the domain registration. For more information, perform an internet search on "free DNS service."</p> <p>You can delete a hosted zone only if it contains only the default SOA record and NS resource record sets. If the hosted zone contains other resource record sets, you must delete them before you can delete the hosted zone. If you try to delete a hosted zone that contains other resource record sets, the request fails, and Route53 returns a <code>HostedZoneNotEmpty</code> error. For information about deleting records from your hosted zone, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html">ChangeResourceRecordSets</a>.</p> <p>To verify that the hosted zone has been deleted, do one of the following:</p> <ul> <li> <p>Use the <code>GetHostedZone</code> action to request information about the hosted zone.</p> </li> <li> <p>Use the <code>ListHostedZones</code> action to get a list of the hosted zones associated with the current Amazon Web Services account.</p> </li> </ul>
		/// DeleteHostedZone 2013-04-01/hostedzone/{Id}
		/// </summary>
		/// <param name="Id">The ID of the hosted zone you want to delete.</param>
		/// <returns>Success</returns>
		public async Task DeleteHostedZoneAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzone/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a specified hosted zone including the four name servers assigned to the hosted zone.
		/// GetHostedZone 2013-04-01/hostedzone/{Id}
		/// </summary>
		/// <param name="Id">The ID of the hosted zone that you want to get information about.</param>
		/// <returns>Success</returns>
		public async Task GetHostedZoneAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzone/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a key-signing key (KSK). Before you can delete a KSK, you must deactivate it. The KSK must be deactivated before you can delete it regardless of whether the hosted zone is enabled for DNSSEC signing.</p> <p>You can use <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeactivateKeySigningKey.html">DeactivateKeySigningKey</a> to deactivate the key before you delete it.</p> <p>Use <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetDNSSEC.html">GetDNSSEC</a> to verify that the KSK is in an <code>INACTIVE</code> status.</p>
		/// DeleteKeySigningKey 2013-04-01/keysigningkey/{HostedZoneId}/{Name}
		/// </summary>
		/// <param name="HostedZoneId">A unique string used to identify a hosted zone.</param>
		/// <param name="Name">A string used to identify a key-signing key (KSK).</param>
		/// <returns>Success</returns>
		public async Task DeleteKeySigningKeyAsync(string HostedZoneId, string Name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/keysigningkey/"+ (HostedZoneId==null? "" : System.Uri.EscapeDataString(HostedZoneId))+"/"+ (Name==null? "" : System.Uri.EscapeDataString(Name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a configuration for DNS query logging. If you delete a configuration, Amazon Route 53 stops sending query logs to CloudWatch Logs. Route 53 doesn't delete any logs that are already in CloudWatch Logs.</p> <p>For more information about DNS query logs, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a>.</p>
		/// DeleteQueryLoggingConfig 2013-04-01/queryloggingconfig/{Id}
		/// </summary>
		/// <param name="Id">The ID of the configuration that you want to delete. </param>
		/// <returns>Success</returns>
		public async Task DeleteQueryLoggingConfigAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/queryloggingconfig/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about a specified configuration for DNS query logging.</p> <p>For more information about DNS query logs, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateQueryLoggingConfig.html">CreateQueryLoggingConfig</a> and <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/query-logs.html">Logging DNS Queries</a>.</p>
		/// GetQueryLoggingConfig 2013-04-01/queryloggingconfig/{Id}
		/// </summary>
		/// <param name="Id">The ID of the configuration for DNS query logging that you want to get information about.</param>
		/// <returns>Success</returns>
		public async Task GetQueryLoggingConfigAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/queryloggingconfig/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a reusable delegation set.</p> <important> <p>You can delete a reusable delegation set only if it isn't associated with any hosted zones.</p> </important> <p>To verify that the reusable delegation set is not associated with any hosted zones, submit a <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetReusableDelegationSet.html">GetReusableDelegationSet</a> request and specify the ID of the reusable delegation set that you want to delete.</p>
		/// DeleteReusableDelegationSet 2013-04-01/delegationset/{Id}
		/// </summary>
		/// <param name="Id">The ID of the reusable delegation set that you want to delete.</param>
		/// <returns>Success</returns>
		public async Task DeleteReusableDelegationSetAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/delegationset/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about a specified reusable delegation set, including the four name servers that are assigned to the delegation set.
		/// GetReusableDelegationSet 2013-04-01/delegationset/{Id}
		/// </summary>
		/// <param name="Id">The ID of the reusable delegation set that you want to get a list of name servers for.</param>
		/// <returns>Success</returns>
		public async Task GetReusableDelegationSetAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/delegationset/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a traffic policy.</p> <p>When you delete a traffic policy, Route 53 sets a flag on the policy to indicate that it has been deleted. However, Route 53 never fully deletes the traffic policy. Note the following:</p> <ul> <li> <p>Deleted traffic policies aren't listed if you run <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListTrafficPolicies.html">ListTrafficPolicies</a>.</p> </li> <li> <p> There's no way to get a list of deleted policies.</p> </li> <li> <p>If you retain the ID of the policy, you can get information about the policy, including the traffic policy document, by running <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetTrafficPolicy.html">GetTrafficPolicy</a>.</p> </li> </ul>
		/// DeleteTrafficPolicy 2013-04-01/trafficpolicy/{Id}/{Version}
		/// </summary>
		/// <param name="Id">The ID of the traffic policy that you want to delete.</param>
		/// <param name="Version">The version number of the traffic policy that you want to delete.</param>
		/// <returns>Success</returns>
		public async Task DeleteTrafficPolicyAsync(string Id, int Version, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicy/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/"+Version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about a specific traffic policy version.</p> <p>For information about how of deleting a traffic policy affects the response from <code>GetTrafficPolicy</code>, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteTrafficPolicy.html">DeleteTrafficPolicy</a>. </p>
		/// GetTrafficPolicy 2013-04-01/trafficpolicy/{Id}/{Version}
		/// </summary>
		/// <param name="Id">The ID of the traffic policy that you want to get information about.</param>
		/// <param name="Version">The version number of the traffic policy that you want to get information about.</param>
		/// <returns>Success</returns>
		public async Task GetTrafficPolicyAsync(string Id, int Version, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicy/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/"+Version;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes a traffic policy instance and all of the resource record sets that Amazon Route 53 created when you created the instance.</p> <note> <p>In the Route 53 console, traffic policy instances are known as policy records.</p> </note>
		/// DeleteTrafficPolicyInstance 2013-04-01/trafficpolicyinstance/{Id}
		/// </summary>
		/// <param name="Id"><p>The ID of the traffic policy instance that you want to delete. </p> <important> <p>When you delete a traffic policy instance, Amazon Route 53 also deletes all of the resource record sets that were created when you created the traffic policy instance.</p> </important></param>
		/// <returns>Success</returns>
		public async Task DeleteTrafficPolicyInstanceAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicyinstance/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about a specified traffic policy instance.</p> <note> <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request, there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For more information, see the <code>State</code> response element.</p> </note> <note> <p>In the Route 53 console, traffic policy instances are known as policy records.</p> </note>
		/// GetTrafficPolicyInstance 2013-04-01/trafficpolicyinstance/{Id}
		/// </summary>
		/// <param name="Id">The ID of the traffic policy instance that you want to get information about.</param>
		/// <returns>Success</returns>
		public async Task GetTrafficPolicyInstanceAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicyinstance/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disables DNSSEC signing in a specific hosted zone. This action does not deactivate any key-signing keys (KSKs) that are active in the hosted zone.
		/// DisableHostedZoneDNSSEC 2013-04-01/hostedzone/{Id}/disable-dnssec
		/// </summary>
		/// <param name="Id">A unique string used to identify a hosted zone.</param>
		/// <returns>Success</returns>
		public async Task DisableHostedZoneDNSSECAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzone/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/disable-dnssec";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enables DNSSEC signing in a specific hosted zone.
		/// EnableHostedZoneDNSSEC 2013-04-01/hostedzone/{Id}/enable-dnssec
		/// </summary>
		/// <param name="Id">A unique string used to identify a hosted zone.</param>
		/// <returns>Success</returns>
		public async Task EnableHostedZoneDNSSECAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzone/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/enable-dnssec";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the specified limit for the current account, for example, the maximum number of health checks that you can create using the account.</p> <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit, <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&amp;limitType=service-code-route53">open a case</a>.</p> <note> <p>You can also view account limits in Amazon Web Services Trusted Advisor. Sign in to the Amazon Web Services Management Console and open the Trusted Advisor console at <a href="https://console.aws.amazon.com/trustedadvisor">https://console.aws.amazon.com/trustedadvisor/</a>. Then choose <b>Service limits</b> in the navigation pane.</p> </note>
		/// GetAccountLimit 2013-04-01/accountlimit/{Type}
		/// </summary>
		/// <param name="Type"><p>The limit that you want to get. Valid values include the following:</p> <ul> <li> <p> <b>MAX_HEALTH_CHECKS_BY_OWNER</b>: The maximum number of health checks that you can create using the current account.</p> </li> <li> <p> <b>MAX_HOSTED_ZONES_BY_OWNER</b>: The maximum number of hosted zones that you can create using the current account.</p> </li> <li> <p> <b>MAX_REUSABLE_DELEGATION_SETS_BY_OWNER</b>: The maximum number of reusable delegation sets that you can create using the current account.</p> </li> <li> <p> <b>MAX_TRAFFIC_POLICIES_BY_OWNER</b>: The maximum number of traffic policies that you can create using the current account.</p> </li> <li> <p> <b>MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER</b>: The maximum number of traffic policy instances that you can create using the current account. (Traffic policy instances are referred to as traffic flow policy records in the Amazon Route 53 console.)</p> </li> </ul></param>
		/// <returns>Success</returns>
		public async Task GetAccountLimitAsync(AccountLimitType Type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/accountlimit/"+Type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Returns the current status of a change batch request. The status is one of the following values:</p> <ul> <li> <p> <code>PENDING</code> indicates that the changes in this request have not propagated to all Amazon Route 53 DNS servers managing the hosted zone. This is the initial status of all change batch requests.</p> </li> <li> <p> <code>INSYNC</code> indicates that the changes have propagated to all Route 53 DNS servers managing the hosted zone. </p> </li> </ul>
		/// GetChange 2013-04-01/change/{Id}
		/// </summary>
		/// <param name="Id">The ID of the change batch request. The value that you specify here is the value that <code>ChangeResourceRecordSets</code> returned in the <code>Id</code> element when you submitted the request.</param>
		/// <returns>Success</returns>
		public async Task GetChangeAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/change/"+ (Id==null? "" : System.Uri.EscapeDataString(Id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p> <important> <p> <code>GetCheckerIpRanges</code> still works, but we recommend that you download ip-ranges.json, which includes IP address ranges for all Amazon Web Services services. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/route-53-ip-addresses.html">IP Address Ranges of Amazon Route 53 Servers</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> </important>
		/// GetCheckerIpRanges 2013-04-01/checkeripranges
		/// </summary>
		/// <returns>Success</returns>
		public async Task GetCheckerIpRangesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/checkeripranges";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns information about DNSSEC for a specific hosted zone, including the key-signing keys (KSKs) in the hosted zone.
		/// GetDNSSEC 2013-04-01/hostedzone/{Id}/dnssec
		/// </summary>
		/// <param name="Id">A unique string used to identify a hosted zone.</param>
		/// <returns>Success</returns>
		public async Task GetDNSSECAsync(string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzone/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/dnssec";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about whether a specified geographic location is supported for Amazon Route 53 geolocation resource record sets.</p> <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p> <p>Use the following syntax to determine whether a continent is supported for geolocation:</p> <p> <code>GET /2013-04-01/geolocation?continentcode=<i>two-letter abbreviation for a continent</i> </code> </p> <p>Use the following syntax to determine whether a country is supported for geolocation:</p> <p> <code>GET /2013-04-01/geolocation?countrycode=<i>two-character country code</i> </code> </p> <p>Use the following syntax to determine whether a subdivision of a country is supported for geolocation:</p> <p> <code>GET /2013-04-01/geolocation?countrycode=<i>two-character country code</i>&amp;subdivisioncode=<i>subdivision code</i> </code> </p>
		/// GetGeoLocation 2013-04-01/geolocation
		/// </summary>
		/// <param name="continentcode"><p>For geolocation resource record sets, a two-letter abbreviation that identifies a continent. Amazon Route 53 supports the following continent codes:</p> <ul> <li> <p> <b>AF</b>: Africa</p> </li> <li> <p> <b>AN</b>: Antarctica</p> </li> <li> <p> <b>AS</b>: Asia</p> </li> <li> <p> <b>EU</b>: Europe</p> </li> <li> <p> <b>OC</b>: Oceania</p> </li> <li> <p> <b>NA</b>: North America</p> </li> <li> <p> <b>SA</b>: South America</p> </li> </ul></param>
		/// <param name="countrycode">Amazon Route 53 uses the two-letter country codes that are specified in <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO standard 3166-1 alpha-2</a>.</param>
		/// <param name="subdivisioncode">The code for the subdivision, such as a particular state within the United States. For a list of US state abbreviations, see <a href="https://pe.usps.com/text/pub28/28apb.htm">Appendix B: TwoLetter State and Possession Abbreviations</a> on the United States Postal Service website. For a list of all supported subdivision codes, use the <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_ListGeoLocations.html">ListGeoLocations</a> API.</param>
		/// <returns>Success</returns>
		public async Task GetGeoLocationAsync(string continentcode, string countrycode, string subdivisioncode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/geolocation?continentcode=" + (continentcode==null? "" : System.Uri.EscapeDataString(continentcode))+"&countrycode=" + (countrycode==null? "" : System.Uri.EscapeDataString(countrycode))+"&subdivisioncode=" + (subdivisioncode==null? "" : System.Uri.EscapeDataString(subdivisioncode));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the number of health checks that are associated with the current Amazon Web Services account.
		/// GetHealthCheckCount 2013-04-01/healthcheckcount
		/// </summary>
		/// <returns>Success</returns>
		public async Task GetHealthCheckCountAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/healthcheckcount";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the reason that a specified health check failed most recently.
		/// GetHealthCheckLastFailureReason 2013-04-01/healthcheck/{HealthCheckId}/lastfailurereason
		/// </summary>
		/// <param name="HealthCheckId"><p>The ID for the health check for which you want the last failure reason. When you created the health check, <code>CreateHealthCheck</code> returned the ID in the response, in the <code>HealthCheckId</code> element.</p> <note> <p>If you want to get the last failure reason for a calculated health check, you must use the Amazon Route 53 console or the CloudWatch console. You can't use <code>GetHealthCheckLastFailureReason</code> for a calculated health check.</p> </note></param>
		/// <returns>Success</returns>
		public async Task GetHealthCheckLastFailureReasonAsync(string HealthCheckId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/healthcheck/"+ (HealthCheckId==null? "" : System.Uri.EscapeDataString(HealthCheckId))+"/lastfailurereason";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets status of a specified health check. </p> <important> <p>This API is intended for use during development to diagnose behavior. It doesnt support production use-cases with high query rates that require immediate and actionable responses.</p> </important>
		/// GetHealthCheckStatus 2013-04-01/healthcheck/{HealthCheckId}/status
		/// </summary>
		/// <param name="HealthCheckId"><p>The ID for the health check that you want the current status for. When you created the health check, <code>CreateHealthCheck</code> returned the ID in the response, in the <code>HealthCheckId</code> element.</p> <note> <p>If you want to check the status of a calculated health check, you must use the Amazon Route 53 console or the CloudWatch console. You can't use <code>GetHealthCheckStatus</code> to get the status of a calculated health check.</p> </note></param>
		/// <returns>Success</returns>
		public async Task GetHealthCheckStatusAsync(string HealthCheckId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/healthcheck/"+ (HealthCheckId==null? "" : System.Uri.EscapeDataString(HealthCheckId))+"/status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the number of hosted zones that are associated with the current Amazon Web Services account.
		/// GetHostedZoneCount 2013-04-01/hostedzonecount
		/// </summary>
		/// <returns>Success</returns>
		public async Task GetHostedZoneCountAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzonecount";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the specified limit for a specified hosted zone, for example, the maximum number of records that you can create in the hosted zone. </p> <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit, <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&amp;limitType=service-code-route53">open a case</a>.</p>
		/// GetHostedZoneLimit 2013-04-01/hostedzonelimit/{Id}/{Type}
		/// </summary>
		/// <param name="Type"><p>The limit that you want to get. Valid values include the following:</p> <ul> <li> <p> <b>MAX_RRSETS_BY_ZONE</b>: The maximum number of records that you can create in the specified hosted zone.</p> </li> <li> <p> <b>MAX_VPCS_ASSOCIATED_BY_ZONE</b>: The maximum number of Amazon VPCs that you can associate with the specified private hosted zone.</p> </li> </ul></param>
		/// <param name="Id">The ID of the hosted zone that you want to get a limit for.</param>
		/// <returns>Success</returns>
		public async Task GetHostedZoneLimitAsync(HostedZoneLimitType Type, string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzonelimit/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/"+Type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the maximum number of hosted zones that you can associate with the specified reusable delegation set.</p> <p>For the default limit, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the <i>Amazon Route 53 Developer Guide</i>. To request a higher limit, <a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&amp;limitType=service-code-route53">open a case</a>.</p>
		/// GetReusableDelegationSetLimit 2013-04-01/reusabledelegationsetlimit/{Id}/{Type}
		/// </summary>
		/// <param name="Type">Specify <code>MAX_ZONES_BY_REUSABLE_DELEGATION_SET</code> to get the maximum number of hosted zones that you can associate with the specified reusable delegation set.</param>
		/// <param name="Id">The ID of the delegation set that you want to get the limit for.</param>
		/// <returns>Success</returns>
		public async Task GetReusableDelegationSetLimitAsync(ReusableDelegationSetLimitType Type, string Id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/reusabledelegationsetlimit/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/"+Type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the number of traffic policy instances that are associated with the current Amazon Web Services account.
		/// GetTrafficPolicyInstanceCount 2013-04-01/trafficpolicyinstancecount
		/// </summary>
		/// <returns>Success</returns>
		public async Task GetTrafficPolicyInstanceCountAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicyinstancecount";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a paginated list of location objects and their CIDR blocks.
		/// ListCidrBlocks 2013-04-01/cidrcollection/{CidrCollectionId}/cidrblocks
		/// </summary>
		/// <param name="CidrCollectionId">The UUID of the CIDR collection.</param>
		/// <param name="location">The name of the CIDR collection location.</param>
		/// <param name="nexttoken">An opaque pagination token to indicate where the service is to begin enumerating results.</param>
		/// <param name="maxresults">Maximum number of results you want returned.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task ListCidrBlocksAsync(string CidrCollectionId, string location, string nexttoken, string maxresults, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/cidrcollection/"+ (CidrCollectionId==null? "" : System.Uri.EscapeDataString(CidrCollectionId))+"/cidrblocks&location=" + (location==null? "" : System.Uri.EscapeDataString(location))+"&nexttoken=" + (nexttoken==null? "" : System.Uri.EscapeDataString(nexttoken))+"&maxresults=" + (maxresults==null? "" : System.Uri.EscapeDataString(maxresults))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves a list of supported geographic locations.</p> <p>Countries are listed first, and continents are listed last. If Amazon Route 53 supports subdivisions for a country (for example, states or provinces), the subdivisions for that country are listed in alphabetical order immediately after the corresponding country.</p> <p>Route 53 does not perform authorization for this API because it retrieves information that is already available to the public.</p> <p>For a list of supported geolocation codes, see the <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GeoLocation.html">GeoLocation</a> data type.</p>
		/// ListGeoLocations 2013-04-01/geolocations
		/// </summary>
		/// <param name="startcontinentcode"><p>The code for the continent with which you want to start listing locations that Amazon Route 53 supports for geolocation. If Route 53 has already returned a page or more of results, if <code>IsTruncated</code> is true, and if <code>NextContinentCode</code> from the previous response has a value, enter that value in <code>startcontinentcode</code> to return the next page of results.</p> <p>Include <code>startcontinentcode</code> only if you want to list continents. Don't include <code>startcontinentcode</code> when you're listing countries or countries with their subdivisions.</p></param>
		/// <param name="startcountrycode">The code for the country with which you want to start listing locations that Amazon Route 53 supports for geolocation. If Route 53 has already returned a page or more of results, if <code>IsTruncated</code> is <code>true</code>, and if <code>NextCountryCode</code> from the previous response has a value, enter that value in <code>startcountrycode</code> to return the next page of results.</param>
		/// <param name="startsubdivisioncode"><p>The code for the state of the United States with which you want to start listing locations that Amazon Route 53 supports for geolocation. If Route 53 has already returned a page or more of results, if <code>IsTruncated</code> is <code>true</code>, and if <code>NextSubdivisionCode</code> from the previous response has a value, enter that value in <code>startsubdivisioncode</code> to return the next page of results.</p> <p>To list subdivisions (U.S. states), you must include both <code>startcountrycode</code> and <code>startsubdivisioncode</code>.</p></param>
		/// <param name="maxitems">(Optional) The maximum number of geolocations to be included in the response body for this request. If more than <code>maxitems</code> geolocations remain to be listed, then the value of the <code>IsTruncated</code> element in the response is <code>true</code>.</param>
		/// <returns>Success</returns>
		public async Task ListGeoLocationsAsync(string startcontinentcode, string startcountrycode, string startsubdivisioncode, string maxitems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/geolocations?startcontinentcode=" + (startcontinentcode==null? "" : System.Uri.EscapeDataString(startcontinentcode))+"&startcountrycode=" + (startcountrycode==null? "" : System.Uri.EscapeDataString(startcountrycode))+"&startsubdivisioncode=" + (startsubdivisioncode==null? "" : System.Uri.EscapeDataString(startsubdivisioncode))+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves a list of your hosted zones in lexicographic order. The response includes a <code>HostedZones</code> child element for each hosted zone created by the current Amazon Web Services account. </p> <p> <code>ListHostedZonesByName</code> sorts hosted zones by name with the labels reversed. For example:</p> <p> <code>com.example.www.</code> </p> <p>Note the trailing dot, which can change the sort order in some circumstances.</p> <p>If the domain name includes escape characters or Punycode, <code>ListHostedZonesByName</code> alphabetizes the domain name using the escaped or Punycoded value, which is the format that Amazon Route 53 saves in its database. For example, to create a hosted zone for exmple.com, you specify ex\344mple.com for the domain name. <code>ListHostedZonesByName</code> alphabetizes it as:</p> <p> <code>com.ex\344mple.</code> </p> <p>The labels are reversed and alphabetized using the escaped value. For more information about valid domain name formats, including internationalized domain names, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html">DNS Domain Name Format</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>Route 53 returns up to 100 items in each response. If you have a lot of hosted zones, use the <code>MaxItems</code> parameter to list them in groups of up to 100. The response includes values that help navigate from one group of <code>MaxItems</code> hosted zones to the next:</p> <ul> <li> <p>The <code>DNSName</code> and <code>HostedZoneId</code> elements in the response contain the values, if any, specified for the <code>dnsname</code> and <code>hostedzoneid</code> parameters in the request that produced the current response.</p> </li> <li> <p>The <code>MaxItems</code> element in the response contains the value, if any, that you specified for the <code>maxitems</code> parameter in the request that produced the current response.</p> </li> <li> <p>If the value of <code>IsTruncated</code> in the response is true, there are more hosted zones associated with the current Amazon Web Services account. </p> <p>If <code>IsTruncated</code> is false, this response includes the last hosted zone that is associated with the current account. The <code>NextDNSName</code> element and <code>NextHostedZoneId</code> elements are omitted from the response.</p> </li> <li> <p>The <code>NextDNSName</code> and <code>NextHostedZoneId</code> elements in the response contain the domain name and the hosted zone ID of the next hosted zone that is associated with the current Amazon Web Services account. If you want to list more hosted zones, make another call to <code>ListHostedZonesByName</code>, and specify the value of <code>NextDNSName</code> and <code>NextHostedZoneId</code> in the <code>dnsname</code> and <code>hostedzoneid</code> parameters, respectively.</p> </li> </ul>
		/// ListHostedZonesByName 2013-04-01/hostedzonesbyname
		/// </summary>
		/// <param name="dnsname">(Optional) For your first request to <code>ListHostedZonesByName</code>, include the <code>dnsname</code> parameter only if you want to specify the name of the first hosted zone in the response. If you don't include the <code>dnsname</code> parameter, Amazon Route 53 returns all of the hosted zones that were created by the current Amazon Web Services account, in ASCII order. For subsequent requests, include both <code>dnsname</code> and <code>hostedzoneid</code> parameters. For <code>dnsname</code>, specify the value of <code>NextDNSName</code> from the previous response.</param>
		/// <param name="hostedzoneid"><p>(Optional) For your first request to <code>ListHostedZonesByName</code>, do not include the <code>hostedzoneid</code> parameter.</p> <p>If you have more hosted zones than the value of <code>maxitems</code>, <code>ListHostedZonesByName</code> returns only the first <code>maxitems</code> hosted zones. To get the next group of <code>maxitems</code> hosted zones, submit another request to <code>ListHostedZonesByName</code> and include both <code>dnsname</code> and <code>hostedzoneid</code> parameters. For the value of <code>hostedzoneid</code>, specify the value of the <code>NextHostedZoneId</code> element from the previous response.</p></param>
		/// <param name="maxitems">The maximum number of hosted zones to be included in the response body for this request. If you have more than <code>maxitems</code> hosted zones, then the value of the <code>IsTruncated</code> element in the response is true, and the values of <code>NextDNSName</code> and <code>NextHostedZoneId</code> specify the first hosted zone in the next group of <code>maxitems</code> hosted zones. </param>
		/// <returns>Success</returns>
		public async Task ListHostedZonesByNameAsync(string dnsname, string hostedzoneid, string maxitems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzonesbyname?dnsname=" + (dnsname==null? "" : System.Uri.EscapeDataString(dnsname))+"&hostedzoneid=" + (hostedzoneid==null? "" : System.Uri.EscapeDataString(hostedzoneid))+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all the private hosted zones that a specified VPC is associated with, regardless of which Amazon Web Services account or Amazon Web Services service owns the hosted zones. The <code>HostedZoneOwner</code> structure in the response contains one of the following values:</p> <ul> <li> <p>An <code>OwningAccount</code> element, which contains the account number of either the current Amazon Web Services account or another Amazon Web Services account. Some services, such as Cloud Map, create hosted zones using the current account. </p> </li> <li> <p>An <code>OwningService</code> element, which identifies the Amazon Web Services service that created and owns the hosted zone. For example, if a hosted zone was created by Amazon Elastic File System (Amazon EFS), the value of <code>Owner</code> is <code>efs.amazonaws.com</code>. </p> </li> </ul> <note> <p>When listing private hosted zones, the hosted zone and the Amazon VPC must belong to the same partition where the hosted zones were created. A partition is a group of Amazon Web Services Regions. Each Amazon Web Services account is scoped to one partition.</p> <p>The following are the supported partitions:</p> <ul> <li> <p> <code>aws</code> - Amazon Web Services Regions</p> </li> <li> <p> <code>aws-cn</code> - China Regions</p> </li> <li> <p> <code>aws-us-gov</code> - Amazon Web Services GovCloud (US) Region</p> </li> </ul> <p>For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Access Management</a> in the <i>Amazon Web Services General Reference</i>.</p> </note>
		/// ListHostedZonesByVPC 2013-04-01/hostedzonesbyvpc#vpcid&vpcregion
		/// </summary>
		/// <param name="vpcid">The ID of the Amazon VPC that you want to list hosted zones for.</param>
		/// <param name="vpcregion">For the Amazon VPC that you specified for <code>VPCId</code>, the Amazon Web Services Region that you created the VPC in. </param>
		/// <param name="maxitems">(Optional) The maximum number of hosted zones that you want Amazon Route 53 to return. If the specified VPC is associated with more than <code>MaxItems</code> hosted zones, the response includes a <code>NextToken</code> element. <code>NextToken</code> contains an encrypted token that identifies the first hosted zone that Route 53 will return if you submit another request.</param>
		/// <param name="nexttoken"><p>If the previous response included a <code>NextToken</code> element, the specified VPC is associated with more hosted zones. To get more hosted zones, submit another <code>ListHostedZonesByVPC</code> request. </p> <p>For the value of <code>NextToken</code>, specify the value of <code>NextToken</code> from the previous response.</p> <p>If the previous response didn't include a <code>NextToken</code> element, there are no more hosted zones to get.</p></param>
		/// <returns>Success</returns>
		public async Task ListHostedZonesByVPCAsync(string vpcid, ListHostedZonesByVPCVpcregion vpcregion, string maxitems, string nexttoken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzonesbyvpc#vpcid&vpcregion?vpcid=" + (vpcid==null? "" : System.Uri.EscapeDataString(vpcid))+"&vpcregion=" + vpcregion+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems))+"&nexttoken=" + (nexttoken==null? "" : System.Uri.EscapeDataString(nexttoken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the resource record sets in a specified hosted zone.</p> <p> <code>ListResourceRecordSets</code> returns up to 300 resource record sets at a time in ASCII order, beginning at a position specified by the <code>name</code> and <code>type</code> elements.</p> <p> <b>Sort order</b> </p> <p> <code>ListResourceRecordSets</code> sorts results first by DNS name with the labels reversed, for example:</p> <p> <code>com.example.www.</code> </p> <p>Note the trailing dot, which can change the sort order when the record name contains characters that appear before <code>.</code> (decimal 46) in the ASCII table. These characters include the following: <code>! " # $ % &amp; ' ( ) * + , -</code> </p> <p>When multiple records have the same DNS name, <code>ListResourceRecordSets</code> sorts results by the record type.</p> <p> <b>Specifying where to start listing records</b> </p> <p>You can use the name and type elements to specify the resource record set that the list begins with:</p> <dl> <dt>If you do not specify Name or Type</dt> <dd> <p>The results begin with the first resource record set that the hosted zone contains.</p> </dd> <dt>If you specify Name but not Type</dt> <dd> <p>The results begin with the first resource record set in the list whose name is greater than or equal to <code>Name</code>.</p> </dd> <dt>If you specify Type but not Name</dt> <dd> <p>Amazon Route 53 returns the <code>InvalidInput</code> error.</p> </dd> <dt>If you specify both Name and Type</dt> <dd> <p>The results begin with the first resource record set in the list whose name is greater than or equal to <code>Name</code>, and whose type is greater than or equal to <code>Type</code>.</p> </dd> </dl> <p> <b>Resource record sets that are PENDING</b> </p> <p>This action returns the most current version of the records. This includes records that are <code>PENDING</code>, and that are not yet available on all Route 53 DNS servers.</p> <p> <b>Changing resource record sets</b> </p> <p>To ensure that you get an accurate listing of the resource record sets for a hosted zone at a point in time, do not submit a <code>ChangeResourceRecordSets</code> request while you're paging through the results of a <code>ListResourceRecordSets</code> request. If you do, some pages may display results without the latest changes while other pages display results with the latest changes.</p> <p> <b>Displaying the next page of results</b> </p> <p>If a <code>ListResourceRecordSets</code> command returns more than one page of results, the value of <code>IsTruncated</code> is <code>true</code>. To display the next page of results, get the values of <code>NextRecordName</code>, <code>NextRecordType</code>, and <code>NextRecordIdentifier</code> (if any) from the response. Then submit another <code>ListResourceRecordSets</code> request, and specify those values for <code>StartRecordName</code>, <code>StartRecordType</code>, and <code>StartRecordIdentifier</code>.</p>
		/// ListResourceRecordSets 2013-04-01/hostedzone/{Id}/rrset
		/// </summary>
		/// <param name="Id">The ID of the hosted zone that contains the resource record sets that you want to list.</param>
		/// <param name="name">The first name in the lexicographic ordering of resource record sets that you want to list. If the specified record name doesn't exist, the results begin with the first resource record set that has a name greater than the value of <code>name</code>.</param>
		/// <param name="type"><p>The type of resource record set to begin the record listing from.</p> <p>Valid values for basic resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>NS</code> | <code>PTR</code> | <code>SOA</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p> <p>Values for weighted, latency, geolocation, and failover resource record sets: <code>A</code> | <code>AAAA</code> | <code>CAA</code> | <code>CNAME</code> | <code>MX</code> | <code>NAPTR</code> | <code>PTR</code> | <code>SPF</code> | <code>SRV</code> | <code>TXT</code> </p> <p>Values for alias resource record sets: </p> <ul> <li> <p> <b>API Gateway custom regional API or edge-optimized API</b>: A</p> </li> <li> <p> <b>CloudFront distribution</b>: A or AAAA</p> </li> <li> <p> <b>Elastic Beanstalk environment that has a regionalized subdomain</b>: A</p> </li> <li> <p> <b>Elastic Load Balancing load balancer</b>: A | AAAA</p> </li> <li> <p> <b>S3 bucket</b>: A</p> </li> <li> <p> <b>VPC interface VPC endpoint</b>: A</p> </li> <li> <p> <b>Another resource record set in this hosted zone:</b> The type of the resource record set that the alias references.</p> </li> </ul> <p>Constraint: Specifying <code>type</code> without specifying <code>name</code> returns an <code>InvalidInput</code> error.</p></param>
		/// <param name="identifier"> <i>Resource record sets that have a routing policy other than simple:</i> If results were truncated for a given DNS name and type, specify the value of <code>NextRecordIdentifier</code> from the previous response to get the next resource record set that has the current DNS name and type.</param>
		/// <param name="maxitems">(Optional) The maximum number of resource records sets to include in the response body for this request. If the response includes more than <code>maxitems</code> resource record sets, the value of the <code>IsTruncated</code> element in the response is <code>true</code>, and the values of the <code>NextRecordName</code> and <code>NextRecordType</code> elements in the response identify the first resource record set in the next group of <code>maxitems</code> resource record sets.</param>
		/// <param name="MaxItems">Pagination limit</param>
		/// <param name="StartRecordName">Pagination token</param>
		/// <param name="StartRecordType">Pagination token</param>
		/// <param name="StartRecordIdentifier">Pagination token</param>
		/// <returns>Success</returns>
		public async Task ListResourceRecordSetsAsync(string Id, string name, RRType type, string identifier, string maxitems, string MaxItems, string StartRecordName, string StartRecordType, string StartRecordIdentifier, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/hostedzone/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/rrset&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&type=" + type+"&identifier=" + (identifier==null? "" : System.Uri.EscapeDataString(identifier))+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems))+"&MaxItems=" + (MaxItems==null? "" : System.Uri.EscapeDataString(MaxItems))+"&StartRecordName=" + (StartRecordName==null? "" : System.Uri.EscapeDataString(StartRecordName))+"&StartRecordType=" + (StartRecordType==null? "" : System.Uri.EscapeDataString(StartRecordType))+"&StartRecordIdentifier=" + (StartRecordIdentifier==null? "" : System.Uri.EscapeDataString(StartRecordIdentifier));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about the latest version for every traffic policy that is associated with the current Amazon Web Services account. Policies are listed in the order that they were created in. </p> <p>For information about how of deleting a traffic policy affects the response from <code>ListTrafficPolicies</code>, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_DeleteTrafficPolicy.html">DeleteTrafficPolicy</a>. </p>
		/// ListTrafficPolicies 2013-04-01/trafficpolicies
		/// </summary>
		/// <param name="trafficpolicyid"><p>(Conditional) For your first request to <code>ListTrafficPolicies</code>, don't include the <code>TrafficPolicyIdMarker</code> parameter.</p> <p>If you have more traffic policies than the value of <code>MaxItems</code>, <code>ListTrafficPolicies</code> returns only the first <code>MaxItems</code> traffic policies. To get the next group of policies, submit another request to <code>ListTrafficPolicies</code>. For the value of <code>TrafficPolicyIdMarker</code>, specify the value of <code>TrafficPolicyIdMarker</code> that was returned in the previous response.</p></param>
		/// <param name="maxitems">(Optional) The maximum number of traffic policies that you want Amazon Route 53 to return in response to this request. If you have more than <code>MaxItems</code> traffic policies, the value of <code>IsTruncated</code> in the response is <code>true</code>, and the value of <code>TrafficPolicyIdMarker</code> is the ID of the first traffic policy that Route 53 will return if you submit another request.</param>
		/// <returns>Success</returns>
		public async Task ListTrafficPoliciesAsync(string trafficpolicyid, string maxitems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicies?trafficpolicyid=" + (trafficpolicyid==null? "" : System.Uri.EscapeDataString(trafficpolicyid))+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about the traffic policy instances that you created by using the current Amazon Web Services account.</p> <note> <p>After you submit an <code>UpdateTrafficPolicyInstance</code> request, there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For more information, see the <code>State</code> response element.</p> </note> <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the <code>MaxItems</code> parameter to list them in groups of up to 100.</p>
		/// ListTrafficPolicyInstances 2013-04-01/trafficpolicyinstances
		/// </summary>
		/// <param name="hostedzoneid"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances. To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>HostedZoneId</code>, specify the value of <code>HostedZoneIdMarker</code> from the previous response, which is the hosted zone ID of the first traffic policy instance in the next group of traffic policy instances.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p></param>
		/// <param name="trafficpolicyinstancename"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances. To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>trafficpolicyinstancename</code>, specify the value of <code>TrafficPolicyInstanceNameMarker</code> from the previous response, which is the name of the first traffic policy instance in the next group of traffic policy instances.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p></param>
		/// <param name="trafficpolicyinstancetype"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances. To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>trafficpolicyinstancetype</code>, specify the value of <code>TrafficPolicyInstanceTypeMarker</code> from the previous response, which is the type of the first traffic policy instance in the next group of traffic policy instances.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p></param>
		/// <param name="maxitems">The maximum number of traffic policy instances that you want Amazon Route 53 to return in response to a <code>ListTrafficPolicyInstances</code> request. If you have more than <code>MaxItems</code> traffic policy instances, the value of the <code>IsTruncated</code> element in the response is <code>true</code>, and the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code> represent the first traffic policy instance in the next group of <code>MaxItems</code> traffic policy instances.</param>
		/// <returns>Success</returns>
		public async Task ListTrafficPolicyInstancesAsync(string hostedzoneid, string trafficpolicyinstancename, RRType trafficpolicyinstancetype, string maxitems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicyinstances?hostedzoneid=" + (hostedzoneid==null? "" : System.Uri.EscapeDataString(hostedzoneid))+"&trafficpolicyinstancename=" + (trafficpolicyinstancename==null? "" : System.Uri.EscapeDataString(trafficpolicyinstancename))+"&trafficpolicyinstancetype=" + trafficpolicyinstancetype+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about the traffic policy instances that you created in a specified hosted zone.</p> <note> <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request, there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For more information, see the <code>State</code> response element.</p> </note> <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the <code>MaxItems</code> parameter to list them in groups of up to 100.</p>
		/// ListTrafficPolicyInstancesByHostedZone 2013-04-01/trafficpolicyinstances/hostedzone#id
		/// </summary>
		/// <param name="id">The ID of the hosted zone that you want to list traffic policy instances for.</param>
		/// <param name="trafficpolicyinstancename"><p>If the value of <code>IsTruncated</code> in the previous response is true, you have more traffic policy instances. To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>trafficpolicyinstancename</code>, specify the value of <code>TrafficPolicyInstanceNameMarker</code> from the previous response, which is the name of the first traffic policy instance in the next group of traffic policy instances.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p></param>
		/// <param name="trafficpolicyinstancetype"><p>If the value of <code>IsTruncated</code> in the previous response is true, you have more traffic policy instances. To get more traffic policy instances, submit another <code>ListTrafficPolicyInstances</code> request. For the value of <code>trafficpolicyinstancetype</code>, specify the value of <code>TrafficPolicyInstanceTypeMarker</code> from the previous response, which is the type of the first traffic policy instance in the next group of traffic policy instances.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p></param>
		/// <param name="maxitems">The maximum number of traffic policy instances to be included in the response body for this request. If you have more than <code>MaxItems</code> traffic policy instances, the value of the <code>IsTruncated</code> element in the response is <code>true</code>, and the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code> represent the first traffic policy instance that Amazon Route 53 will return if you submit another request.</param>
		/// <returns>Success</returns>
		public async Task ListTrafficPolicyInstancesByHostedZoneAsync(string id, string trafficpolicyinstancename, RRType trafficpolicyinstancetype, string maxitems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicyinstances/hostedzone#id?id=" + (id==null? "" : System.Uri.EscapeDataString(id))+"&trafficpolicyinstancename=" + (trafficpolicyinstancename==null? "" : System.Uri.EscapeDataString(trafficpolicyinstancename))+"&trafficpolicyinstancetype=" + trafficpolicyinstancetype+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about the traffic policy instances that you created by using a specify traffic policy version.</p> <note> <p>After you submit a <code>CreateTrafficPolicyInstance</code> or an <code>UpdateTrafficPolicyInstance</code> request, there's a brief delay while Amazon Route 53 creates the resource record sets that are specified in the traffic policy definition. For more information, see the <code>State</code> response element.</p> </note> <p>Route 53 returns a maximum of 100 items in each response. If you have a lot of traffic policy instances, you can use the <code>MaxItems</code> parameter to list them in groups of up to 100.</p>
		/// ListTrafficPolicyInstancesByPolicy 2013-04-01/trafficpolicyinstances/trafficpolicy#id&version
		/// </summary>
		/// <param name="id">The ID of the traffic policy for which you want to list traffic policy instances.</param>
		/// <param name="version">The version of the traffic policy for which you want to list traffic policy instances. The version must be associated with the traffic policy that is specified by <code>TrafficPolicyId</code>.</param>
		/// <param name="hostedzoneid"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances. To get more traffic policy instances, submit another <code>ListTrafficPolicyInstancesByPolicy</code> request. </p> <p>For the value of <code>hostedzoneid</code>, specify the value of <code>HostedZoneIdMarker</code> from the previous response, which is the hosted zone ID of the first traffic policy instance that Amazon Route 53 will return if you submit another request.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p></param>
		/// <param name="trafficpolicyinstancename"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances. To get more traffic policy instances, submit another <code>ListTrafficPolicyInstancesByPolicy</code> request.</p> <p>For the value of <code>trafficpolicyinstancename</code>, specify the value of <code>TrafficPolicyInstanceNameMarker</code> from the previous response, which is the name of the first traffic policy instance that Amazon Route 53 will return if you submit another request.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p></param>
		/// <param name="trafficpolicyinstancetype"><p>If the value of <code>IsTruncated</code> in the previous response was <code>true</code>, you have more traffic policy instances. To get more traffic policy instances, submit another <code>ListTrafficPolicyInstancesByPolicy</code> request.</p> <p>For the value of <code>trafficpolicyinstancetype</code>, specify the value of <code>TrafficPolicyInstanceTypeMarker</code> from the previous response, which is the name of the first traffic policy instance that Amazon Route 53 will return if you submit another request.</p> <p>If the value of <code>IsTruncated</code> in the previous response was <code>false</code>, there are no more traffic policy instances to get.</p></param>
		/// <param name="maxitems">The maximum number of traffic policy instances to be included in the response body for this request. If you have more than <code>MaxItems</code> traffic policy instances, the value of the <code>IsTruncated</code> element in the response is <code>true</code>, and the values of <code>HostedZoneIdMarker</code>, <code>TrafficPolicyInstanceNameMarker</code>, and <code>TrafficPolicyInstanceTypeMarker</code> represent the first traffic policy instance that Amazon Route 53 will return if you submit another request.</param>
		/// <returns>Success</returns>
		public async Task ListTrafficPolicyInstancesByPolicyAsync(string id, int version, string hostedzoneid, string trafficpolicyinstancename, RRType trafficpolicyinstancetype, string maxitems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicyinstances/trafficpolicy#id&version?id=" + (id==null? "" : System.Uri.EscapeDataString(id))+"&version="+version+"&hostedzoneid=" + (hostedzoneid==null? "" : System.Uri.EscapeDataString(hostedzoneid))+"&trafficpolicyinstancename=" + (trafficpolicyinstancename==null? "" : System.Uri.EscapeDataString(trafficpolicyinstancename))+"&trafficpolicyinstancetype=" + trafficpolicyinstancetype+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets information about all of the versions for a specified traffic policy.</p> <p>Traffic policy versions are listed in numerical order by <code>VersionNumber</code>.</p>
		/// ListTrafficPolicyVersions 2013-04-01/trafficpolicies/{Id}/versions
		/// </summary>
		/// <param name="Id">Specify the value of <code>Id</code> of the traffic policy for which you want to list all versions.</param>
		/// <param name="trafficpolicyversion"><p>For your first request to <code>ListTrafficPolicyVersions</code>, don't include the <code>TrafficPolicyVersionMarker</code> parameter.</p> <p>If you have more traffic policy versions than the value of <code>MaxItems</code>, <code>ListTrafficPolicyVersions</code> returns only the first group of <code>MaxItems</code> versions. To get more traffic policy versions, submit another <code>ListTrafficPolicyVersions</code> request. For the value of <code>TrafficPolicyVersionMarker</code>, specify the value of <code>TrafficPolicyVersionMarker</code> in the previous response.</p></param>
		/// <param name="maxitems">The maximum number of traffic policy versions that you want Amazon Route 53 to include in the response body for this request. If the specified traffic policy has more than <code>MaxItems</code> versions, the value of <code>IsTruncated</code> in the response is <code>true</code>, and the value of the <code>TrafficPolicyVersionMarker</code> element is the ID of the first version that Route 53 will return if you submit another request.</param>
		/// <returns>Success</returns>
		public async Task ListTrafficPolicyVersionsAsync(string Id, string trafficpolicyversion, string maxitems, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/trafficpolicies/"+ (Id==null? "" : System.Uri.EscapeDataString(Id))+"/versions&trafficpolicyversion=" + (trafficpolicyversion==null? "" : System.Uri.EscapeDataString(trafficpolicyversion))+"&maxitems=" + (maxitems==null? "" : System.Uri.EscapeDataString(maxitems));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Gets the value that Amazon Route 53 returns in response to a DNS request for a specified record name and type. You can optionally specify the IP address of a DNS resolver, an EDNS0 client subnet IP address, and a subnet mask. </p> <p>This call only supports querying public hosted zones.</p> <note> <p>The <code>TestDnsAnswer </code> returns information similar to what you would expect from the answer section of the <code>dig</code> command. Therefore, if you query for the name servers of a subdomain that point to the parent name servers, those will not be returned.</p> </note>
		/// TestDNSAnswer 2013-04-01/testdnsanswer#hostedzoneid&recordname&recordtype
		/// </summary>
		/// <param name="hostedzoneid">The ID of the hosted zone that you want Amazon Route 53 to simulate a query for.</param>
		/// <param name="recordname">The name of the resource record set that you want Amazon Route 53 to simulate a query for.</param>
		/// <param name="recordtype">The type of the resource record set.</param>
		/// <param name="resolverip">If you want to simulate a request from a specific DNS resolver, specify the IP address for that resolver. If you omit this value, <code>TestDnsAnswer</code> uses the IP address of a DNS resolver in the Amazon Web Services US East (N. Virginia) Region (<code>us-east-1</code>).</param>
		/// <param name="edns0clientsubnetip">If the resolver that you specified for resolverip supports EDNS0, specify the IPv4 or IPv6 address of a client in the applicable location, for example, <code>192.0.2.44</code> or <code>2001:db8:85a3::8a2e:370:7334</code>.</param>
		/// <param name="edns0clientsubnetmask"><p>If you specify an IP address for <code>edns0clientsubnetip</code>, you can optionally specify the number of bits of the IP address that you want the checking tool to include in the DNS query. For example, if you specify <code>192.0.2.44</code> for <code>edns0clientsubnetip</code> and <code>24</code> for <code>edns0clientsubnetmask</code>, the checking tool will simulate a request from 192.0.2.0/24. The default value is 24 bits for IPv4 addresses and 64 bits for IPv6 addresses.</p> <p>The range of valid values depends on whether <code>edns0clientsubnetip</code> is an IPv4 or an IPv6 address:</p> <ul> <li> <p> <b>IPv4</b>: Specify a value between 0 and 32</p> </li> <li> <p> <b>IPv6</b>: Specify a value between 0 and 128</p> </li> </ul></param>
		/// <returns>Success</returns>
		public async Task TestDNSAnswerAsync(string hostedzoneid, string recordname, RRType recordtype, string resolverip, string edns0clientsubnetip, string edns0clientsubnetmask, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "2013-04-01/testdnsanswer#hostedzoneid&recordname&recordtype?hostedzoneid=" + (hostedzoneid==null? "" : System.Uri.EscapeDataString(hostedzoneid))+"&recordname=" + (recordname==null? "" : System.Uri.EscapeDataString(recordname))+"&recordtype=" + recordtype+"&resolverip=" + (resolverip==null? "" : System.Uri.EscapeDataString(resolverip))+"&edns0clientsubnetip=" + (edns0clientsubnetip==null? "" : System.Uri.EscapeDataString(edns0clientsubnetip))+"&edns0clientsubnetmask=" + (edns0clientsubnetmask==null? "" : System.Uri.EscapeDataString(edns0clientsubnetmask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum ListHostedZonesByVPCVpcregion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-1")]
		usMinuseastMinus1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-east-2")]
		usMinuseastMinus2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-1")]
		usMinuswestMinus1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-west-2")]
		usMinuswestMinus2 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-1")]
		euMinuswestMinus1 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-2")]
		euMinuswestMinus2 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-west-3")]
		euMinuswestMinus3 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-central-1")]
		euMinuscentralMinus1 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-central-2")]
		euMinuscentralMinus2 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-east-1")]
		apMinuseastMinus1 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me-south-1")]
		meMinussouthMinus1 = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-gov-west-1")]
		usMinusgovMinuswestMinus1 = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-gov-east-1")]
		usMinusgovMinuseastMinus1 = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-iso-east-1")]
		usMinusisoMinuseastMinus1 = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-iso-west-1")]
		usMinusisoMinuswestMinus1 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us-isob-east-1")]
		usMinusisobMinuseastMinus1 = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="me-central-1")]
		meMinuscentralMinus1 = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-1")]
		apMinussoutheastMinus1 = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-2")]
		apMinussoutheastMinus2 = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-3")]
		apMinussoutheastMinus3 = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-south-1")]
		apMinussouthMinus1 = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-south-2")]
		apMinussouthMinus2 = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-1")]
		apMinusnortheastMinus1 = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-2")]
		apMinusnortheastMinus2 = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-northeast-3")]
		apMinusnortheastMinus3 = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-north-1")]
		euMinusnorthMinus1 = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sa-east-1")]
		saMinuseastMinus1 = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ca-central-1")]
		caMinuscentralMinus1 = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cn-north-1")]
		cnMinusnorthMinus1 = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="af-south-1")]
		afMinussouthMinus1 = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-south-1")]
		euMinussouthMinus1 = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eu-south-2")]
		euMinussouthMinus2 = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ap-southeast-4")]
		apMinussoutheastMinus4 = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="il-central-1")]
		ilMinuscentralMinus1 = 33,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
