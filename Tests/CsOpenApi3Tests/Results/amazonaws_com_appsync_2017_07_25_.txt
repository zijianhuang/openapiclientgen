//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateApiResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiAssociation")]
		public ApiAssociation ApiAssociation { get; set; }
	}
	
	/// <summary>
	/// Describes an <code>ApiAssociation</code> object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApiAssociation
	{
		
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		public string DomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiId")]
		public string ApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="associationStatus")]
		public AssociationStatus AssociationStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deploymentDetail")]
		public string DeploymentDetail { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssociationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PROCESSING")]
		PROCESSING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SUCCESS")]
		SUCCESS = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessDeniedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BadRequestException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalFailureException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateMergedGraphqlApiResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociation")]
		public SourceApiAssociation SourceApiAssociation { get; set; }
	}
	
	/// <summary>
	/// <p>Describes the configuration of a source API. A source API is a GraphQL API that is linked to a merged API. There can be multiple source APIs attached to each merged API. When linked to a merged API, the source API's schema, data sources, and resolvers will be combined with other linked source API data to form a new, singular API. </p> <p>Source APIs can originate from your account or from other accounts via Amazon Web Services Resource Access Manager. For more information about sharing resources from other accounts, see <a href="https://docs.aws.amazon.com/ram/latest/userguide/what-is.html">What is Amazon Web Services Resource Access Manager?</a> in the <i>Amazon Web Services Resource Access Manager</i> guide.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceApiAssociation
	{
		
		[System.Runtime.Serialization.DataMember(Name="associationId")]
		public string AssociationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="associationArn")]
		public string AssociationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiId")]
		public string SourceApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiArn")]
		public string SourceApiArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mergedApiArn")]
		public string MergedApiArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mergedApiId")]
		public string MergedApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationConfig")]
		public SourceApiAssociationConfig SourceApiAssociationConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationStatus")]
		public SourceApiAssociationStatus SourceApiAssociationStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationStatusDetail")]
		public string SourceApiAssociationStatusDetail { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastSuccessfulMergeDate")]
		public System.DateTimeOffset LastSuccessfulMergeDate { get; set; }
	}
	
	/// <summary>
	/// Describes properties used to specify configurations related to a source API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceApiAssociationConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="mergeType")]
		public MergeType MergeType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum MergeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MANUAL_MERGE")]
		MANUAL_MERGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AUTO_MERGE")]
		AUTO_MERGE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SourceApiAssociationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MERGE_SCHEDULED")]
		MERGE_SCHEDULED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MERGE_FAILED")]
		MERGE_FAILED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MERGE_SUCCESS")]
		MERGE_SUCCESS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MERGE_IN_PROGRESS")]
		MERGE_IN_PROGRESS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AUTO_MERGE_SCHEDULE_FAILED")]
		AUTO_MERGE_SCHEDULE_FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETION_SCHEDULED")]
		DELETION_SCHEDULED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETION_IN_PROGRESS")]
		DELETION_IN_PROGRESS = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETION_FAILED")]
		DELETION_FAILED = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnauthorizedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConcurrentModificationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateSourceGraphqlApiResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociation")]
		public SourceApiAssociation SourceApiAssociation { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a <code>CreateApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateApiCacheResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiCache")]
		public ApiCache ApiCache { get; set; }
	}
	
	/// <summary>
	/// The <code>ApiCache</code> object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApiCache
	{
		
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiCachingBehavior")]
		public ApiCachingBehavior ApiCachingBehavior { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transitEncryptionEnabled")]
		public System.Nullable<System.Boolean> TransitEncryptionEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="atRestEncryptionEnabled")]
		public System.Nullable<System.Boolean> AtRestEncryptionEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ApiCacheType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ApiCacheStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ApiCachingBehavior
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FULL_REQUEST_CACHING")]
		FULL_REQUEST_CACHING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PER_RESOLVER_CACHING")]
		PER_RESOLVER_CACHING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ApiCacheType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="T2_SMALL")]
		T2_SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="T2_MEDIUM")]
		T2_MEDIUM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="R4_LARGE")]
		R4_LARGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="R4_XLARGE")]
		R4_XLARGE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="R4_2XLARGE")]
		R4_2XLARGE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="R4_4XLARGE")]
		R4_4XLARGE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="R4_8XLARGE")]
		R4_8XLARGE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SMALL")]
		SMALL = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MEDIUM")]
		MEDIUM = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LARGE")]
		LARGE = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="XLARGE")]
		XLARGE = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LARGE_2X")]
		LARGE_2X = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LARGE_4X")]
		LARGE_4X = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LARGE_8X")]
		LARGE_8X = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LARGE_12X")]
		LARGE_12X = 14,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ApiCacheStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AVAILABLE")]
		AVAILABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MODIFYING")]
		MODIFYING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateApiKeyResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiKey")]
		public ApiKey ApiKey { get; set; }
	}
	
	/// <summary>
	/// <p>Describes an API key.</p> <p>Customers invoke AppSync GraphQL API operations with API keys as an identity mechanism. There are two key versions:</p> <p> <b>da1</b>: We introduced this version at launch in November 2017. These keys always expire after 7 days. Amazon DynamoDB TTL manages key expiration. These keys ceased to be valid after February 21, 2018, and they should no longer be used.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time in milliseconds.</p> </li> <li> <p> <code>UpdateApiKey</code> is not available for this key version.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in DynamoDB as milliseconds. This results in a bug where keys are not automatically deleted because DynamoDB expects the TTL to be stored in seconds. As a one-time action, we deleted these keys from the table on February 21, 2018.</p> </li> </ul> <p> <b>da2</b>: We introduced this version in February 2018 when AppSync added support to extend key expiration.</p> <ul> <li> <p> <code>ListApiKeys</code> returns the expiration time and deletion time in seconds.</p> </li> <li> <p> <code>CreateApiKey</code> returns the expiration time and deletion time in seconds and accepts a user-provided expiration time in seconds.</p> </li> <li> <p> <code>UpdateApiKey</code> returns the expiration time and and deletion time in seconds and accepts a user-provided expiration time in seconds. Expired API keys are kept for 60 days after the expiration time. You can update the key expiration time as long as the key isn't deleted.</p> </li> <li> <p> <code>DeleteApiKey</code> deletes the item from the table.</p> </li> <li> <p>Expiration is stored in DynamoDB as seconds. After the expiration time, using the key to authenticate will fail. However, you can reinstate the key before deletion.</p> </li> <li> <p>Deletion is stored in DynamoDB as seconds. The key is deleted after deletion time.</p> </li> </ul>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApiKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expires")]
		public System.Nullable<System.Int32> Expires { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deletes")]
		public System.Nullable<System.Int32> Deletes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApiKeyLimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApiKeyValidityOutOfBoundsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateDataSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="dataSource")]
		public DataSource DataSource { get; set; }
	}
	
	/// <summary>
	/// Describes a data source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DataSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="dataSourceArn")]
		public string DataSourceArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DataSourceType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serviceRoleArn")]
		public string ServiceRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dynamodbConfig")]
		public DynamodbDataSourceConfig DynamodbConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConfig")]
		public LambdaDataSourceConfig LambdaConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="elasticsearchConfig")]
		public ElasticsearchDataSourceConfig ElasticsearchConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openSearchServiceConfig")]
		public OpenSearchServiceDataSourceConfig OpenSearchServiceConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpConfig")]
		public HttpDataSourceConfig HttpConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationalDatabaseConfig")]
		public RelationalDatabaseDataSourceConfig RelationalDatabaseConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="eventBridgeConfig")]
		public EventBridgeDataSourceConfig EventBridgeConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DataSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS_LAMBDA")]
		AWS_LAMBDA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AMAZON_DYNAMODB")]
		AMAZON_DYNAMODB = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AMAZON_ELASTICSEARCH")]
		AMAZON_ELASTICSEARCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HTTP")]
		HTTP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RELATIONAL_DATABASE")]
		RELATIONAL_DATABASE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AMAZON_OPENSEARCH_SERVICE")]
		AMAZON_OPENSEARCH_SERVICE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AMAZON_EVENTBRIDGE")]
		AMAZON_EVENTBRIDGE = 7,
	}
	
	/// <summary>
	/// Describes an Amazon DynamoDB data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DynamodbDataSourceConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tableName")]
		public string TableName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="useCallerCredentials")]
		public System.Nullable<System.Boolean> UseCallerCredentials { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deltaSyncConfig")]
		public DeltaSyncConfig DeltaSyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="versioned")]
		public System.Nullable<System.Boolean> Versioned { get; set; }
	}
	
	/// <summary>
	/// Describes a Delta Sync configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeltaSyncConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="baseTableTTL")]
		public System.Nullable<System.Int32> BaseTableTTL { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deltaSyncTableName")]
		public string DeltaSyncTableName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deltaSyncTableTTL")]
		public System.Nullable<System.Int32> DeltaSyncTableTTL { get; set; }
	}
	
	/// <summary>
	/// Describes an Lambda data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaDataSourceConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionArn")]
		public string LambdaFunctionArn { get; set; }
	}
	
	/// <summary>
	/// <p>Describes an OpenSearch data source configuration.</p> <p>As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use <a>OpenSearchServiceDataSourceConfig</a> to specify an OpenSearch data source.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ElasticsearchDataSourceConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
	}
	
	/// <summary>
	/// Describes an OpenSearch data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OpenSearchServiceDataSourceConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
	}
	
	/// <summary>
	/// Describes an HTTP data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpDataSourceConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizationConfig")]
		public AuthorizationConfig AuthorizationConfig { get; set; }
	}
	
	/// <summary>
	/// The authorization configuration in case the HTTP endpoint requires authorization.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthorizationConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizationType")]
		public AuthorizationType AuthorizationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsIamConfig")]
		public AwsIamConfig AwsIamConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AuthorizationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS_IAM")]
		AWS_IAM = 0,
	}
	
	/// <summary>
	/// The Identity and Access Management (IAM) configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AwsIamConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="signingRegion")]
		public string SigningRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="signingServiceName")]
		public string SigningServiceName { get; set; }
	}
	
	/// <summary>
	/// Describes a relational database data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RelationalDatabaseDataSourceConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="relationalDatabaseSourceType")]
		public RelationalDatabaseSourceType RelationalDatabaseSourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rdsHttpEndpointConfig")]
		public RdsHttpEndpointConfig RdsHttpEndpointConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RelationalDatabaseSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RDS_HTTP_ENDPOINT")]
		RDS_HTTP_ENDPOINT = 0,
	}
	
	/// <summary>
	/// The Amazon Relational Database Service (Amazon RDS) HTTP endpoint configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RdsHttpEndpointConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dbClusterIdentifier")]
		public string DbClusterIdentifier { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="databaseName")]
		public string DatabaseName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsSecretStoreArn")]
		public string AwsSecretStoreArn { get; set; }
	}
	
	/// <summary>
	/// Describes an Amazon EventBridge bus data source configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventBridgeDataSourceConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="eventBusArn")]
		public string EventBusArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateDomainNameResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="domainNameConfig")]
		public DomainNameConfig DomainNameConfig { get; set; }
	}
	
	/// <summary>
	/// Describes a configuration for a custom domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DomainNameConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		public string DomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="certificateArn")]
		public string CertificateArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="appsyncDomainName")]
		public string AppsyncDomainName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostedZoneId")]
		public string HostedZoneId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateFunctionResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="functionConfiguration")]
		public FunctionConfiguration FunctionConfiguration { get; set; }
	}
	
	/// <summary>
	/// A function is a reusable entity. You can use multiple functions to compose the resolver logic.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FunctionConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="functionId")]
		public string FunctionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="functionArn")]
		public string FunctionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		public string DataSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		public string RequestMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="functionVersion")]
		public string FunctionVersion { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public SyncConfig SyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public AppSyncRuntime Runtime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	/// <summary>
	/// <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SyncConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="conflictHandler")]
		public ConflictHandlerType ConflictHandler { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="conflictDetection")]
		public ConflictDetectionType ConflictDetection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConflictHandlerConfig")]
		public LambdaConflictHandlerConfig LambdaConflictHandlerConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ConflictHandlerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OPTIMISTIC_CONCURRENCY")]
		OPTIMISTIC_CONCURRENCY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LAMBDA")]
		LAMBDA = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AUTOMERGE")]
		AUTOMERGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ConflictDetectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="VERSION")]
		VERSION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 1,
	}
	
	/// <summary>
	/// The <code>LambdaConflictHandlerConfig</code> object when configuring <code>LAMBDA</code> as the Conflict Handler.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaConflictHandlerConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConflictHandlerArn")]
		public string LambdaConflictHandlerArn { get; set; }
	}
	
	/// <summary>
	/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AppSyncRuntime
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public RuntimeName Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runtimeVersion")]
		public string RuntimeVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum RuntimeName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="APPSYNC_JS")]
		APPSYNC_JS = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateGraphqlApiResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="graphqlApi")]
		public GraphqlApi GraphqlApi { get; set; }
	}
	
	/// <summary>
	/// Describes a GraphQL API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GraphqlApi
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiId")]
		public string ApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authenticationType")]
		public AuthenticationType AuthenticationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public LogConfig LogConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userPoolConfig")]
		public UserPoolConfig UserPoolConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openIDConnectConfig")]
		public OpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uris")]
		public MapOfStringToString Uris { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagMap Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="additionalAuthenticationProviders")]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="xrayEnabled")]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="wafWebAclArn")]
		public string WafWebAclArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaAuthorizerConfig")]
		public LambdaAuthorizerConfig LambdaAuthorizerConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dns")]
		public MapOfStringToString Dns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public GraphQLApiVisibility Visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiType")]
		public GraphQLApiType ApiType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mergedApiExecutionRoleArn")]
		public string MergedApiExecutionRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public string Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ownerContact")]
		public string OwnerContact { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AuthenticationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="API_KEY")]
		API_KEY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS_IAM")]
		AWS_IAM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AMAZON_COGNITO_USER_POOLS")]
		AMAZON_COGNITO_USER_POOLS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OPENID_CONNECT")]
		OPENID_CONNECT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWS_LAMBDA")]
		AWS_LAMBDA = 4,
	}
	
	/// <summary>
	/// The Amazon CloudWatch Logs configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fieldLogLevel")]
		public FieldLogLevel FieldLogLevel { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cloudWatchLogsRoleArn")]
		public string CloudWatchLogsRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludeVerboseContent")]
		public System.Nullable<System.Boolean> ExcludeVerboseContent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FieldLogLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR")]
		ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALL")]
		ALL = 2,
	}
	
	/// <summary>
	/// Describes an Amazon Cognito user pool configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserPoolConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="userPoolId")]
		public string UserPoolId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="defaultAction")]
		public DefaultAction DefaultAction { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="appIdClientRegex")]
		public string AppIdClientRegex { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DefaultAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ALLOW")]
		ALLOW = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DENY")]
		DENY = 1,
	}
	
	/// <summary>
	/// Describes an OpenID Connect (OIDC) configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OpenIDConnectConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="iatTTL")]
		public System.Nullable<System.Int32> IatTTL { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authTTL")]
		public System.Nullable<System.Int32> AuthTTL { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MapOfStringToString
	{
	}
	
	/// <summary>
	/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagMap
	{
	}
	
	/// <summary>
	/// Describes an additional authentication provider.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdditionalAuthenticationProvider
	{
		
		[System.Runtime.Serialization.DataMember(Name="authenticationType")]
		public AuthenticationType AuthenticationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openIDConnectConfig")]
		public OpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userPoolConfig")]
		public CognitoUserPoolConfig UserPoolConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaAuthorizerConfig")]
		public LambdaAuthorizerConfig LambdaAuthorizerConfig { get; set; }
	}
	
	/// <summary>
	/// Describes an Amazon Cognito user pool configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CognitoUserPoolConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="userPoolId")]
		public string UserPoolId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="appIdClientRegex")]
		public string AppIdClientRegex { get; set; }
	}
	
	/// <summary>
	/// A <code>LambdaAuthorizerConfig</code> specifies how to authorize AppSync API access when using the <code>AWS_LAMBDA</code> authorizer mode. Be aware that an AppSync API can have only one Lambda authorizer configured at a time.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LambdaAuthorizerConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="authorizerResultTtlInSeconds")]
		public System.Nullable<System.Int32> AuthorizerResultTtlInSeconds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authorizerUri")]
		public string AuthorizerUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="identityValidationExpression")]
		public string IdentityValidationExpression { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GraphQLApiVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GLOBAL")]
		GLOBAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PRIVATE")]
		PRIVATE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum GraphQLApiType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GRAPHQL")]
		GRAPHQL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MERGED")]
		MERGED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApiLimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateResolverResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="resolver")]
		public Resolver Resolver { get; set; }
	}
	
	/// <summary>
	/// Describes a resolver.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Resolver
	{
		
		[System.Runtime.Serialization.DataMember(Name="typeName")]
		public string TypeName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fieldName")]
		public string FieldName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		public string DataSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resolverArn")]
		public string ResolverArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		public string RequestMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public ResolverKind Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pipelineConfig")]
		public PipelineConfig PipelineConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public SyncConfig SyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cachingConfig")]
		public CachingConfig CachingConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public AppSyncRuntime Runtime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ResolverKind
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNIT")]
		UNIT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PIPELINE")]
		PIPELINE = 1,
	}
	
	/// <summary>
	/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PipelineConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="functions")]
		public string[] Functions { get; set; }
	}
	
	/// <summary>
	/// The caching configuration for a resolver that has caching activated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CachingConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public int Ttl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cachingKeys")]
		public string[] CachingKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTypeResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Type Type { get; set; }
	}
	
	/// <summary>
	/// Describes a type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Type
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="arn")]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="format")]
		public TypeDefinitionFormat Format { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum TypeDefinitionFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SDL")]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="JSON")]
		JSON = 1,
	}
	
	/// <summary>
	/// Represents the output of a <code>DeleteApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteApiCacheResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteApiKeyResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteDataSourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteDomainNameResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteFunctionResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteGraphqlApiResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteResolverResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTypeResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateApiResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateMergedGraphqlApiResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationStatus")]
		public SourceApiAssociationStatus SourceApiAssociationStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateSourceGraphqlApiResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationStatus")]
		public SourceApiAssociationStatus SourceApiAssociationStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EvaluateCodeResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="evaluationResult")]
		public string EvaluationResult { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public EvaluateCodeErrorDetail Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logs")]
		public string[] Logs { get; set; }
	}
	
	/// <summary>
	/// Contains the list of errors from a code evaluation response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EvaluateCodeErrorDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="codeErrors")]
		public CodeError[] CodeErrors { get; set; }
	}
	
	/// <summary>
	/// Describes an AppSync error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CodeError
	{
		
		[System.Runtime.Serialization.DataMember(Name="errorType")]
		public string ErrorType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public CodeErrorLocation Location { get; set; }
	}
	
	/// <summary>
	/// Describes the location of the error in a code sample.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CodeErrorLocation
	{
		
		[System.Runtime.Serialization.DataMember(Name="line")]
		public System.Nullable<System.Int32> Line { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="column")]
		public System.Nullable<System.Int32> Column { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="span")]
		public System.Nullable<System.Int32> Span { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EvaluateMappingTemplateResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="evaluationResult")]
		public string EvaluationResult { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ErrorDetail Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logs")]
		public string[] Logs { get; set; }
	}
	
	/// <summary>
	/// Contains the list of errors generated. When using JavaScript, this will apply to the request or response function evaluation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ErrorDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a <code>FlushApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FlushApiCacheResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetApiAssociationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiAssociation")]
		public ApiAssociation ApiAssociation { get; set; }
	}
	
	/// <summary>
	/// Represents the output of a <code>GetApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetApiCacheResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiCache")]
		public ApiCache ApiCache { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetDataSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="dataSource")]
		public DataSource DataSource { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetDomainNameResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="domainNameConfig")]
		public DomainNameConfig DomainNameConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetFunctionResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="functionConfiguration")]
		public FunctionConfiguration FunctionConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetGraphqlApiResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="graphqlApi")]
		public GraphqlApi GraphqlApi { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetIntrospectionSchemaResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GraphQLSchemaException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetResolverResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="resolver")]
		public Resolver Resolver { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetSchemaCreationStatusResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public SchemaStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SchemaStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PROCESSING")]
		PROCESSING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SUCCESS")]
		SUCCESS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NOT_APPLICABLE")]
		NOT_APPLICABLE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetSourceApiAssociationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociation")]
		public SourceApiAssociation SourceApiAssociation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetTypeResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Type Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListApiKeysResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiKeys")]
		public ApiKey[] ApiKeys { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListDataSourcesResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="dataSources")]
		public DataSource[] DataSources { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListDomainNamesResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="domainNameConfigs")]
		public DomainNameConfig[] DomainNameConfigs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListFunctionsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="functions")]
		public FunctionConfiguration[] Functions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGraphqlApisResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="graphqlApis")]
		public GraphqlApi[] GraphqlApis { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListResolversResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="resolvers")]
		public Resolver[] Resolvers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListResolversByFunctionResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="resolvers")]
		public Resolver[] Resolvers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListSourceApiAssociationsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationSummaries")]
		public SourceApiAssociationSummary[] SourceApiAssociationSummaries { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// Describes the ARNs and IDs of associations, Merged APIs, and source APIs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceApiAssociationSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="associationId")]
		public string AssociationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="associationArn")]
		public string AssociationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiId")]
		public string SourceApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiArn")]
		public string SourceApiArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mergedApiId")]
		public string MergedApiId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mergedApiArn")]
		public string MergedApiArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTypesResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="types")]
		public Type[] Types { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTypesByAssociationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="types")]
		public Type[] Types { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextToken")]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartSchemaCreationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public SchemaStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartSchemaMergeResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationStatus")]
		public SourceApiAssociationStatus SourceApiAssociationStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceResponse
	{
	}
	
	/// <summary>
	/// Represents the output of a <code>UpdateApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateApiCacheResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiCache")]
		public ApiCache ApiCache { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateApiKeyResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="apiKey")]
		public ApiKey ApiKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateDataSourceResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="dataSource")]
		public DataSource DataSource { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateDomainNameResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="domainNameConfig")]
		public DomainNameConfig DomainNameConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateFunctionResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="functionConfiguration")]
		public FunctionConfiguration FunctionConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGraphqlApiResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="graphqlApi")]
		public GraphqlApi GraphqlApi { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateResolverResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="resolver")]
		public Resolver Resolver { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateSourceApiAssociationResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociation")]
		public SourceApiAssociation SourceApiAssociation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTypeResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Type Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateApiRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiId")]
		public string ApiId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateMergedGraphqlApiRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mergedApiIdentifier")]
		public string MergedApiIdentifier { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationConfig")]
		public SourceApiAssociationConfig SourceApiAssociationConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AssociateSourceGraphqlApiRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceApiIdentifier")]
		public string SourceApiIdentifier { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationConfig")]
		public SourceApiAssociationConfig SourceApiAssociationConfig { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>CreateApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateApiCacheRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public int Ttl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transitEncryptionEnabled")]
		public System.Nullable<System.Boolean> TransitEncryptionEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="atRestEncryptionEnabled")]
		public System.Nullable<System.Boolean> AtRestEncryptionEnabled { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiCachingBehavior")]
		public ApiCachingBehavior ApiCachingBehavior { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ApiCacheType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateApiKeyRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expires")]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateDataSourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DataSourceType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serviceRoleArn")]
		public string ServiceRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dynamodbConfig")]
		public DynamodbDataSourceConfig DynamodbConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConfig")]
		public LambdaDataSourceConfig LambdaConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="elasticsearchConfig")]
		public ElasticsearchDataSourceConfig ElasticsearchConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openSearchServiceConfig")]
		public OpenSearchServiceDataSourceConfig OpenSearchServiceConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpConfig")]
		public HttpDataSourceConfig HttpConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationalDatabaseConfig")]
		public RelationalDatabaseDataSourceConfig RelationalDatabaseConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="eventBridgeConfig")]
		public EventBridgeDataSourceConfig EventBridgeConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateDomainNameRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		public string DomainName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateArn")]
		public string CertificateArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateFunctionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		public string DataSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		public string RequestMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="functionVersion")]
		public string FunctionVersion { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public SyncConfig SyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public AppSyncRuntime Runtime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateGraphqlApiRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public LogConfig LogConfig { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authenticationType")]
		public AuthenticationType AuthenticationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userPoolConfig")]
		public UserPoolConfig UserPoolConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openIDConnectConfig")]
		public OpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagMap Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="additionalAuthenticationProviders")]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="xrayEnabled")]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaAuthorizerConfig")]
		public LambdaAuthorizerConfig LambdaAuthorizerConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public GraphQLApiVisibility Visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="apiType")]
		public GraphQLApiType ApiType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mergedApiExecutionRoleArn")]
		public string MergedApiExecutionRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ownerContact")]
		public string OwnerContact { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateResolverRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fieldName")]
		public string FieldName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		public string DataSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		public string RequestMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public ResolverKind Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pipelineConfig")]
		public PipelineConfig PipelineConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public SyncConfig SyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cachingConfig")]
		public CachingConfig CachingConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public AppSyncRuntime Runtime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateTypeRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public TypeDefinitionFormat Format { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>DeleteApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteApiCacheRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteApiKeyRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteDataSourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteDomainNameRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteFunctionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteGraphqlApiRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteResolverRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteTypeRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateApiRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateMergedGraphqlApiRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisassociateSourceGraphqlApiRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EvaluateCodeRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public AppSyncRuntime Runtime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="function")]
		public string Function { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EvaluateMappingTemplateRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="template")]
		public string Template { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
	}
	
	/// <summary>
	/// Represents the input of a <code>FlushApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FlushApiCacheRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetApiAssociationRequest
	{
	}
	
	/// <summary>
	/// Represents the input of a <code>GetApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetApiCacheRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetDataSourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetDomainNameRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetFunctionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetGraphqlApiRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum OutputType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SDL")]
		SDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="JSON")]
		JSON = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetIntrospectionSchemaRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetResolverRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetSchemaCreationStatusRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetSourceApiAssociationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetTypeRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListApiKeysRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListDataSourcesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListDomainNamesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListFunctionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Ownership
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CURRENT_ACCOUNT")]
		CURRENT_ACCOUNT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OTHER_ACCOUNTS")]
		OTHER_ACCOUNTS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListGraphqlApisRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListResolversByFunctionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListResolversRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListSourceApiAssociationsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTypesByAssociationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTypesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartSchemaCreationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartSchemaMergeRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public TagMap Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceRequest
	{
	}
	
	/// <summary>
	/// Represents the input of a <code>UpdateApiCache</code> operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateApiCacheRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public int Ttl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiCachingBehavior")]
		public ApiCachingBehavior ApiCachingBehavior { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ApiCacheType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateApiKeyRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expires")]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateDataSourceRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DataSourceType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serviceRoleArn")]
		public string ServiceRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dynamodbConfig")]
		public DynamodbDataSourceConfig DynamodbConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConfig")]
		public LambdaDataSourceConfig LambdaConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="elasticsearchConfig")]
		public ElasticsearchDataSourceConfig ElasticsearchConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openSearchServiceConfig")]
		public OpenSearchServiceDataSourceConfig OpenSearchServiceConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpConfig")]
		public HttpDataSourceConfig HttpConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="relationalDatabaseConfig")]
		public RelationalDatabaseDataSourceConfig RelationalDatabaseConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="eventBridgeConfig")]
		public EventBridgeDataSourceConfig EventBridgeConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateDomainNameRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateFunctionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		public string DataSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		public string RequestMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="functionVersion")]
		public string FunctionVersion { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public SyncConfig SyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public AppSyncRuntime Runtime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateGraphqlApiRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public LogConfig LogConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authenticationType")]
		public AuthenticationType AuthenticationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userPoolConfig")]
		public UserPoolConfig UserPoolConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="openIDConnectConfig")]
		public OpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="additionalAuthenticationProviders")]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="xrayEnabled")]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaAuthorizerConfig")]
		public LambdaAuthorizerConfig LambdaAuthorizerConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mergedApiExecutionRoleArn")]
		public string MergedApiExecutionRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ownerContact")]
		public string OwnerContact { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateResolverRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		public string DataSourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		public string RequestMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		public string ResponseMappingTemplate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public ResolverKind Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pipelineConfig")]
		public PipelineConfig PipelineConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public SyncConfig SyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cachingConfig")]
		public CachingConfig CachingConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public AppSyncRuntime Runtime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateSourceApiAssociationRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationConfig")]
		public SourceApiAssociationConfig SourceApiAssociationConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateTypeRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public TypeDefinitionFormat Format { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Maps an endpoint to your custom domain.
		/// AssociateApi v1/domainnames/{domainName}/apiassociation
		/// </summary>
		/// <param name="domainName">The domain name.
		/// Max length: 253
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<AssociateApiResponse> AssociateApiAsync(string domainName, AssociateApiPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domainnames/"+ (domainName==null? "" : System.Uri.EscapeDataString(domainName))+"/apiassociation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssociateApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes an <code>ApiAssociation</code> object from a custom domain.
		/// DisassociateApi v1/domainnames/{domainName}/apiassociation
		/// </summary>
		/// <param name="domainName">The domain name.
		/// Max length: 253
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<DisassociateApiResponse> DisassociateApiAsync(string domainName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domainnames/"+ (domainName==null? "" : System.Uri.EscapeDataString(domainName))+"/apiassociation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DisassociateApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an <code>ApiAssociation</code> object.
		/// GetApiAssociation v1/domainnames/{domainName}/apiassociation
		/// </summary>
		/// <param name="domainName">The domain name.
		/// Max length: 253
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<GetApiAssociationResponse> GetApiAssociationAsync(string domainName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domainnames/"+ (domainName==null? "" : System.Uri.EscapeDataString(domainName))+"/apiassociation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetApiAssociationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an association between a Merged API and source API using the source API's identifier.
		/// AssociateMergedGraphqlApi v1/sourceApis/{sourceApiIdentifier}/mergedApiAssociations
		/// </summary>
		/// <param name="sourceApiIdentifier">The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.</param>
		/// <returns>Success</returns>
		public async Task<AssociateMergedGraphqlApiResponse> AssociateMergedGraphqlApiAsync(string sourceApiIdentifier, AssociateMergedGraphqlApiPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sourceApis/"+ (sourceApiIdentifier==null? "" : System.Uri.EscapeDataString(sourceApiIdentifier))+"/mergedApiAssociations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssociateMergedGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates an association between a Merged API and source API using the Merged API's identifier.
		/// AssociateSourceGraphqlApi v1/mergedApis/{mergedApiIdentifier}/sourceApiAssociations
		/// </summary>
		/// <param name="mergedApiIdentifier">The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.</param>
		/// <returns>Success</returns>
		public async Task<AssociateSourceGraphqlApiResponse> AssociateSourceGraphqlApiAsync(string mergedApiIdentifier, AssociateSourceGraphqlApiPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/mergedApis/"+ (mergedApiIdentifier==null? "" : System.Uri.EscapeDataString(mergedApiIdentifier))+"/sourceApiAssociations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssociateSourceGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a cache for the GraphQL API.
		/// CreateApiCache v1/apis/{apiId}/ApiCaches
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <returns>Success</returns>
		public async Task<CreateApiCacheResponse> CreateApiCacheAsync(string apiId, CreateApiCachePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/ApiCaches";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an <code>ApiCache</code> object.
		/// DeleteApiCache v1/apis/{apiId}/ApiCaches
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<DeleteApiCacheResponse> DeleteApiCacheAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/ApiCaches";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an <code>ApiCache</code> object.
		/// GetApiCache v1/apis/{apiId}/ApiCaches
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<GetApiCacheResponse> GetApiCacheAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/ApiCaches";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a unique key that you can distribute to clients who invoke your API.
		/// CreateApiKey v1/apis/{apiId}/apikeys
		/// </summary>
		/// <param name="apiId">The ID for your GraphQL API.</param>
		/// <returns>Success</returns>
		public async Task<CreateApiKeyResponse> CreateApiKeyAsync(string apiId, CreateApiKeyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/apikeys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateApiKeyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Lists the API keys for a given API.</p> <note> <p>API keys are deleted automatically 60 days after they expire. However, they may still be included in the response until they have actually been deleted. You can safely call <code>DeleteApiKey</code> to manually delete a key before it's automatically deleted.</p> </note>
		/// ListApiKeys v1/apis/{apiId}/apikeys
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListApiKeysResponse> ListApiKeysAsync(string apiId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/apikeys&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListApiKeysResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a <code>DataSource</code> object.
		/// CreateDataSource v1/apis/{apiId}/datasources
		/// </summary>
		/// <param name="apiId">The API ID for the GraphQL API for the <code>DataSource</code>.</param>
		/// <returns>Success</returns>
		public async Task<CreateDataSourceResponse> CreateDataSourceAsync(string apiId, CreateDataSourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/datasources";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateDataSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the data sources for a given API.
		/// ListDataSources v1/apis/{apiId}/datasources
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListDataSourcesResponse> ListDataSourcesAsync(string apiId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/datasources&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListDataSourcesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a custom <code>DomainName</code> object.
		/// CreateDomainName v1/domainnames
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateDomainNameResponse> CreateDomainNameAsync(CreateDomainNamePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domainnames";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateDomainNameResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists multiple custom domain names.
		/// ListDomainNames v1/domainnames
		/// </summary>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListDomainNamesResponse> ListDomainNamesAsync(string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domainnames?nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListDomainNamesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a <code>Function</code> object.</p> <p>A function is a reusable entity. You can use multiple functions to compose the resolver logic.</p>
		/// CreateFunction v1/apis/{apiId}/functions
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <returns>Success</returns>
		public async Task<CreateFunctionResponse> CreateFunctionAsync(string apiId, CreateFunctionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/functions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List multiple functions.
		/// ListFunctions v1/apis/{apiId}/functions
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListFunctionsResponse> ListFunctionsAsync(string apiId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/functions&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListFunctionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a <code>GraphqlApi</code> object.
		/// CreateGraphqlApi v1/apis
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateGraphqlApiResponse> CreateGraphqlApiAsync(CreateGraphqlApiPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists your GraphQL APIs.
		/// ListGraphqlApis v1/apis
		/// </summary>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <param name="apiType">The value that indicates whether the GraphQL API is a standard API (<code>GRAPHQL</code>) or merged API (<code>MERGED</code>).</param>
		/// <param name="owner">The account owner of the GraphQL API.</param>
		/// <returns>Success</returns>
		public async Task<ListGraphqlApisResponse> ListGraphqlApisAsync(string nextToken, int maxResults, GraphQLApiType apiType, Ownership owner, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis?nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults+"&apiType=" + apiType+"&owner=" + owner;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListGraphqlApisResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a <code>Resolver</code> object.</p> <p>A resolver converts incoming requests into a format that a data source can understand, and converts the data source's responses into GraphQL.</p>
		/// CreateResolver v1/apis/{apiId}/types/{typeName}/resolvers
		/// </summary>
		/// <param name="apiId">The ID for the GraphQL API for which the resolver is being created.</param>
		/// <param name="typeName">The name of the <code>Type</code>.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateResolverResponse> CreateResolverAsync(string apiId, string typeName, CreateResolverPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : System.Uri.EscapeDataString(typeName))+"/resolvers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateResolverResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the resolvers for a given API and type.
		/// ListResolvers v1/apis/{apiId}/types/{typeName}/resolvers
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The type name.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListResolversResponse> ListResolversAsync(string apiId, string typeName, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : System.Uri.EscapeDataString(typeName))+"/resolvers&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListResolversResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a <code>Type</code> object.
		/// CreateType v1/apis/{apiId}/types
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<CreateTypeResponse> CreateTypeAsync(string apiId, CreateTypePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an API key.
		/// DeleteApiKey v1/apis/{apiId}/apikeys/{id}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="id">The ID for the API key.</param>
		/// <returns>Success</returns>
		public async Task<DeleteApiKeyResponse> DeleteApiKeyAsync(string apiId, string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/apikeys/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteApiKeyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an API key. You can update the key as long as it's not deleted.
		/// UpdateApiKey v1/apis/{apiId}/apikeys/{id}
		/// </summary>
		/// <param name="apiId">The ID for the GraphQL API.</param>
		/// <param name="id">The API key ID.</param>
		/// <returns>Success</returns>
		public async Task<UpdateApiKeyResponse> UpdateApiKeyAsync(string apiId, string id, UpdateApiKeyPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/apikeys/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateApiKeyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>DataSource</code> object.
		/// DeleteDataSource v1/apis/{apiId}/datasources/{name}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="name">The name of the data source.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteDataSourceResponse> DeleteDataSourceAsync(string apiId, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/datasources/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteDataSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>DataSource</code> object.
		/// GetDataSource v1/apis/{apiId}/datasources/{name}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="name">The name of the data source.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<GetDataSourceResponse> GetDataSourceAsync(string apiId, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/datasources/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetDataSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>DataSource</code> object.
		/// UpdateDataSource v1/apis/{apiId}/datasources/{name}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="name">The new name for the data source.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateDataSourceResponse> UpdateDataSourceAsync(string apiId, string name, UpdateDataSourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/datasources/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateDataSourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a custom <code>DomainName</code> object.
		/// DeleteDomainName v1/domainnames/{domainName}
		/// </summary>
		/// <param name="domainName">The domain name.
		/// Max length: 253
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteDomainNameResponse> DeleteDomainNameAsync(string domainName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domainnames/"+ (domainName==null? "" : System.Uri.EscapeDataString(domainName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteDomainNameResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a custom <code>DomainName</code> object.
		/// GetDomainName v1/domainnames/{domainName}
		/// </summary>
		/// <param name="domainName">The domain name.
		/// Max length: 253
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<GetDomainNameResponse> GetDomainNameAsync(string domainName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domainnames/"+ (domainName==null? "" : System.Uri.EscapeDataString(domainName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetDomainNameResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a custom <code>DomainName</code> object.
		/// UpdateDomainName v1/domainnames/{domainName}
		/// </summary>
		/// <param name="domainName">The domain name.
		/// Max length: 253
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateDomainNameResponse> UpdateDomainNameAsync(string domainName, UpdateDomainNamePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domainnames/"+ (domainName==null? "" : System.Uri.EscapeDataString(domainName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateDomainNameResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>Function</code>.
		/// DeleteFunction v1/apis/{apiId}/functions/{functionId}
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <param name="functionId">The <code>Function</code> ID.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteFunctionResponse> DeleteFunctionAsync(string apiId, string functionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/functions/"+ (functionId==null? "" : System.Uri.EscapeDataString(functionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a <code>Function</code>.
		/// GetFunction v1/apis/{apiId}/functions/{functionId}
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <param name="functionId">The <code>Function</code> ID.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<GetFunctionResponse> GetFunctionAsync(string apiId, string functionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/functions/"+ (functionId==null? "" : System.Uri.EscapeDataString(functionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>Function</code> object.
		/// UpdateFunction v1/apis/{apiId}/functions/{functionId}
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <param name="functionId">The function ID.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateFunctionResponse> UpdateFunctionAsync(string apiId, string functionId, UpdateFunctionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/functions/"+ (functionId==null? "" : System.Uri.EscapeDataString(functionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>GraphqlApi</code> object.
		/// DeleteGraphqlApi v1/apis/{apiId}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<DeleteGraphqlApiResponse> DeleteGraphqlApiAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>GraphqlApi</code> object.
		/// GetGraphqlApi v1/apis/{apiId}
		/// </summary>
		/// <param name="apiId">The API ID for the GraphQL API.</param>
		/// <returns>Success</returns>
		public async Task<GetGraphqlApiResponse> GetGraphqlApiAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>GraphqlApi</code> object.
		/// UpdateGraphqlApi v1/apis/{apiId}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<UpdateGraphqlApiResponse> UpdateGraphqlApiAsync(string apiId, UpdateGraphqlApiPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>Resolver</code> object.
		/// DeleteResolver v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The name of the resolver type.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="fieldName">The resolver field name.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteResolverResponse> DeleteResolverAsync(string apiId, string typeName, string fieldName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : System.Uri.EscapeDataString(typeName))+"/resolvers/"+ (fieldName==null? "" : System.Uri.EscapeDataString(fieldName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteResolverResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>Resolver</code> object.
		/// GetResolver v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The resolver type name.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="fieldName">The resolver field name.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<GetResolverResponse> GetResolverAsync(string apiId, string typeName, string fieldName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : System.Uri.EscapeDataString(typeName))+"/resolvers/"+ (fieldName==null? "" : System.Uri.EscapeDataString(fieldName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetResolverResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>Resolver</code> object.
		/// UpdateResolver v1/apis/{apiId}/types/{typeName}/resolvers/{fieldName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The new type name.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="fieldName">The new field name.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateResolverResponse> UpdateResolverAsync(string apiId, string typeName, string fieldName, UpdateResolverPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : System.Uri.EscapeDataString(typeName))+"/resolvers/"+ (fieldName==null? "" : System.Uri.EscapeDataString(fieldName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateResolverResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a <code>Type</code> object.
		/// DeleteType v1/apis/{apiId}/types/{typeName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The type name.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<DeleteTypeResponse> DeleteTypeAsync(string apiId, string typeName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : System.Uri.EscapeDataString(typeName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a <code>Type</code> object.
		/// UpdateType v1/apis/{apiId}/types/{typeName}
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The new type name.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateTypeResponse> UpdateTypeAsync(string apiId, string typeName, UpdateTypePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : System.Uri.EscapeDataString(typeName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an association between a Merged API and source API using the source API's identifier and the association ID.
		/// DisassociateMergedGraphqlApi v1/sourceApis/{sourceApiIdentifier}/mergedApiAssociations/{associationId}
		/// </summary>
		/// <param name="sourceApiIdentifier">The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.</param>
		/// <param name="associationId">The ID generated by the AppSync service for the source API association.</param>
		/// <returns>Success</returns>
		public async Task<DisassociateMergedGraphqlApiResponse> DisassociateMergedGraphqlApiAsync(string sourceApiIdentifier, string associationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sourceApis/"+ (sourceApiIdentifier==null? "" : System.Uri.EscapeDataString(sourceApiIdentifier))+"/mergedApiAssociations/"+ (associationId==null? "" : System.Uri.EscapeDataString(associationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DisassociateMergedGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an association between a Merged API and source API using the Merged API's identifier and the association ID.
		/// DisassociateSourceGraphqlApi v1/mergedApis/{mergedApiIdentifier}/sourceApiAssociations/{associationId}
		/// </summary>
		/// <param name="mergedApiIdentifier">The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.</param>
		/// <param name="associationId">The ID generated by the AppSync service for the source API association.</param>
		/// <returns>Success</returns>
		public async Task<DisassociateSourceGraphqlApiResponse> DisassociateSourceGraphqlApiAsync(string mergedApiIdentifier, string associationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/mergedApis/"+ (mergedApiIdentifier==null? "" : System.Uri.EscapeDataString(mergedApiIdentifier))+"/sourceApiAssociations/"+ (associationId==null? "" : System.Uri.EscapeDataString(associationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DisassociateSourceGraphqlApiResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>SourceApiAssociation</code> object.
		/// GetSourceApiAssociation v1/mergedApis/{mergedApiIdentifier}/sourceApiAssociations/{associationId}
		/// </summary>
		/// <param name="mergedApiIdentifier">The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.</param>
		/// <param name="associationId">The ID generated by the AppSync service for the source API association.</param>
		/// <returns>Success</returns>
		public async Task<GetSourceApiAssociationResponse> GetSourceApiAssociationAsync(string mergedApiIdentifier, string associationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/mergedApis/"+ (mergedApiIdentifier==null? "" : System.Uri.EscapeDataString(mergedApiIdentifier))+"/sourceApiAssociations/"+ (associationId==null? "" : System.Uri.EscapeDataString(associationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetSourceApiAssociationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates some of the configuration choices of a particular source API association.
		/// UpdateSourceApiAssociation v1/mergedApis/{mergedApiIdentifier}/sourceApiAssociations/{associationId}
		/// </summary>
		/// <param name="associationId">The ID generated by the AppSync service for the source API association.</param>
		/// <param name="mergedApiIdentifier">The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.</param>
		/// <returns>Success</returns>
		public async Task<UpdateSourceApiAssociationResponse> UpdateSourceApiAssociationAsync(string associationId, string mergedApiIdentifier, UpdateSourceApiAssociationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/mergedApis/"+ (mergedApiIdentifier==null? "" : System.Uri.EscapeDataString(mergedApiIdentifier))+"/sourceApiAssociations/"+ (associationId==null? "" : System.Uri.EscapeDataString(associationId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateSourceApiAssociationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Evaluates the given code and returns the response. The code definition requirements depend on the specified runtime. For <code>APPSYNC_JS</code> runtimes, the code defines the request and response functions. The request function takes the incoming request after a GraphQL operation is parsed and converts it into a request configuration for the selected data source operation. The response function interprets responses from the data source and maps it to the shape of the GraphQL field output type.
		/// EvaluateCode v1/dataplane-evaluatecode
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EvaluateCodeResponse> EvaluateCodeAsync(EvaluateCodePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/dataplane-evaluatecode";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EvaluateCodeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// <p>Evaluates a given template and returns the response. The mapping template can be a request or response template.</p> <p>Request templates take the incoming request after a GraphQL operation is parsed and convert it into a request configuration for the selected data source operation. Response templates interpret responses from the data source and map it to the shape of the GraphQL field output type.</p> <p>Mapping templates are written in the Apache Velocity Template Language (VTL).</p>
		/// EvaluateMappingTemplate v1/dataplane-evaluatetemplate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<EvaluateMappingTemplateResponse> EvaluateMappingTemplateAsync(EvaluateMappingTemplatePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/dataplane-evaluatetemplate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EvaluateMappingTemplateResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Flushes an <code>ApiCache</code> object.
		/// FlushApiCache v1/apis/{apiId}/FlushCache
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<FlushApiCacheResponse> FlushApiCacheAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/FlushCache";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FlushApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the introspection schema for a GraphQL API.
		/// GetIntrospectionSchema v1/apis/{apiId}/schema#format
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="format">The schema format: SDL or JSON.</param>
		/// <param name="includeDirectives">A flag that specifies whether the schema introspection should contain directives.</param>
		/// <returns>Success</returns>
		public async Task<GetIntrospectionSchemaResponse> GetIntrospectionSchemaAsync(string apiId, TypeDefinitionFormat format, bool includeDirectives, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/schema#format&format=" + format+"&includeDirectives="+includeDirectives;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetIntrospectionSchemaResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the current status of a schema creation operation.
		/// GetSchemaCreationStatus v1/apis/{apiId}/schemacreation
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<GetSchemaCreationStatusResponse> GetSchemaCreationStatusAsync(string apiId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/schemacreation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetSchemaCreationStatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Adds a new schema to your GraphQL API.</p> <p>This operation is asynchronous. Use to determine when it has completed.</p>
		/// StartSchemaCreation v1/apis/{apiId}/schemacreation
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <returns>Success</returns>
		public async Task<StartSchemaCreationResponse> StartSchemaCreationAsync(string apiId, StartSchemaCreationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/schemacreation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartSchemaCreationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a <code>Type</code> object.
		/// GetType v1/apis/{apiId}/types/{typeName}#format
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="typeName">The type name.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="format">The type format: SDL or JSON.</param>
		/// <returns>Success</returns>
		public async Task<GetTypeResponse> GetTypeAsync(string apiId, string typeName, TypeDefinitionFormat format, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types/"+ (typeName==null? "" : System.Uri.EscapeDataString(typeName))+"#format&format=" + format;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the resolvers that are associated with a specific function.
		/// ListResolversByFunction v1/apis/{apiId}/functions/{functionId}/resolvers
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="functionId">The function ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListResolversByFunctionResponse> ListResolversByFunctionAsync(string apiId, string functionId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/functions/"+ (functionId==null? "" : System.Uri.EscapeDataString(functionId))+"/resolvers&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListResolversByFunctionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the <code>SourceApiAssociationSummary</code> data.
		/// ListSourceApiAssociations v1/apis/{apiId}/sourceApiAssociations
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListSourceApiAssociationsResponse> ListSourceApiAssociationsAsync(string apiId, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/sourceApiAssociations&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListSourceApiAssociationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the tags for a resource.
		/// ListTagsForResource v1/tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The <code>GraphqlApi</code> Amazon Resource Name (ARN).
		/// Max length: 75
		/// Min length: 70
		// </param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Tags a resource with user-supplied tags.
		/// TagResource v1/tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">The <code>GraphqlApi</code> Amazon Resource Name (ARN).
		/// Max length: 75
		/// Min length: 70
		// </param>
		/// <returns>Success</returns>
		public async Task<TagResourceResponse> TagResourceAsync(string resourceArn, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the types for a given API.
		/// ListTypes v1/apis/{apiId}/types#format
		/// </summary>
		/// <param name="apiId">The API ID.</param>
		/// <param name="format">The type format: SDL or JSON.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListTypesResponse> ListTypesAsync(string apiId, TypeDefinitionFormat format, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/types#format&format=" + format+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTypesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists <code>Type</code> objects by the source API association ID.
		/// ListTypesByAssociation v1/mergedApis/{mergedApiIdentifier}/sourceApiAssociations/{associationId}/types#format
		/// </summary>
		/// <param name="mergedApiIdentifier">The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.</param>
		/// <param name="associationId">The ID generated by the AppSync service for the source API association.</param>
		/// <param name="format">The format type.</param>
		/// <param name="nextToken">An identifier that was returned from the previous call to this operation, which you can use to return the next set of items in the list.
		/// Max length: 65536
		/// Min length: 1
		// </param>
		/// <param name="maxResults">The maximum number of results that you want the request to return.
		/// Minimum: 0
		/// Maximum: 25
		// </param>
		/// <returns>Success</returns>
		public async Task<ListTypesByAssociationResponse> ListTypesByAssociationAsync(string mergedApiIdentifier, string associationId, TypeDefinitionFormat format, string nextToken, int maxResults, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/mergedApis/"+ (mergedApiIdentifier==null? "" : System.Uri.EscapeDataString(mergedApiIdentifier))+"/sourceApiAssociations/"+ (associationId==null? "" : System.Uri.EscapeDataString(associationId))+"/types#format&format=" + format+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&maxResults="+maxResults;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTypesByAssociationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates a merge operation. Returns a status that shows the result of the merge operation.
		/// StartSchemaMerge v1/mergedApis/{mergedApiIdentifier}/sourceApiAssociations/{associationId}/merge
		/// </summary>
		/// <param name="associationId">The ID generated by the AppSync service for the source API association.</param>
		/// <param name="mergedApiIdentifier">The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.</param>
		/// <returns>Success</returns>
		public async Task<StartSchemaMergeResponse> StartSchemaMergeAsync(string associationId, string mergedApiIdentifier, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/mergedApis/"+ (mergedApiIdentifier==null? "" : System.Uri.EscapeDataString(mergedApiIdentifier))+"/sourceApiAssociations/"+ (associationId==null? "" : System.Uri.EscapeDataString(associationId))+"/merge";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartSchemaMergeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Untags a resource.
		/// UntagResource v1/tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">The <code>GraphqlApi</code> Amazon Resource Name (ARN).
		/// Max length: 75
		/// Min length: 70
		// </param>
		/// <param name="tagKeys">A list of <code>TagKey</code> objects.
		/// Minimum items: 1
		/// Maximum items: 50
		// </param>
		/// <returns>Success</returns>
		public async Task<UntagResourceResponse> UntagResourceAsync(string resourceArn, string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn))+"#tagKeys&"+string.Join("&", tagKeys.Select(z => $"tagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UntagResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the cache for the GraphQL API.
		/// UpdateApiCache v1/apis/{apiId}/ApiCaches/update
		/// </summary>
		/// <param name="apiId">The GraphQL API ID.</param>
		/// <returns>Success</returns>
		public async Task<UpdateApiCacheResponse> UpdateApiCacheAsync(string apiId, UpdateApiCachePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/apis/"+ (apiId==null? "" : System.Uri.EscapeDataString(apiId))+"/ApiCaches/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateApiCacheResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public class AssociateApiPostBody
	{
		
		/// <summary>
		/// The API ID. Private APIs can not be associated with custom domains.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiId")]
		public string ApiId { get; set; }
	}
	
	public class AssociateMergedGraphqlApiPostBody
	{
		
		/// <summary>
		/// The identifier of the AppSync Merged API. This is generated by the AppSync service. In most cases, Merged APIs (especially in your account) only require the API ID value or ARN of the merged API. However, Merged APIs in other accounts (cross-account use cases) strictly require the full resource ARN of the merged API.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mergedApiIdentifier")]
		public string MergedApiIdentifier { get; set; }
		
		/// <summary>
		/// The description field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Describes properties used to specify configurations related to a source API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationConfig")]
		public AssociateMergedGraphqlApiPostBodySourceApiAssociationConfig SourceApiAssociationConfig { get; set; }
	}
	
	public class AssociateMergedGraphqlApiPostBodySourceApiAssociationConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="mergeType")]
		public MergeType MergeType { get; set; }
	}
	
	public class AssociateSourceGraphqlApiPostBody
	{
		
		/// <summary>
		/// The identifier of the AppSync Source API. This is generated by the AppSync service. In most cases, source APIs (especially in your account) only require the API ID value or ARN of the source API. However, source APIs from other accounts (cross-account use cases) strictly require the full resource ARN of the source API.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceApiIdentifier")]
		public string SourceApiIdentifier { get; set; }
		
		/// <summary>
		/// The description field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Describes properties used to specify configurations related to a source API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationConfig")]
		public AssociateSourceGraphqlApiPostBodySourceApiAssociationConfig SourceApiAssociationConfig { get; set; }
	}
	
	public class AssociateSourceGraphqlApiPostBodySourceApiAssociationConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="mergeType")]
		public MergeType MergeType { get; set; }
	}
	
	public class CreateApiCachePostBody
	{
		
		/// <summary>
		/// <p>TTL in seconds for cache entries.</p> <p>Valid values are 13,600 seconds.</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public int Ttl { get; set; }
		
		/// <summary>
		/// Transit encryption flag when connecting to cache. You cannot update this setting after creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transitEncryptionEnabled")]
		public System.Nullable<System.Boolean> TransitEncryptionEnabled { get; set; }
		
		/// <summary>
		/// At-rest encryption flag for cache. You cannot update this setting after creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="atRestEncryptionEnabled")]
		public System.Nullable<System.Boolean> AtRestEncryptionEnabled { get; set; }
		
		/// <summary>
		/// <p>Caching behavior.</p> <ul> <li> <p> <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.</p> </li> <li> <p> <b>PER_RESOLVER_CACHING</b>: Individual resolvers that you specify are cached.</p> </li> </ul>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiCachingBehavior")]
		public ApiCachingBehavior ApiCachingBehavior { get; set; }
		
		/// <summary>
		/// <p>The cache instance type. Valid values are </p> <ul> <li> <p> <code>SMALL</code> </p> </li> <li> <p> <code>MEDIUM</code> </p> </li> <li> <p> <code>LARGE</code> </p> </li> <li> <p> <code>XLARGE</code> </p> </li> <li> <p> <code>LARGE_2X</code> </p> </li> <li> <p> <code>LARGE_4X</code> </p> </li> <li> <p> <code>LARGE_8X</code> (not available in all regions)</p> </li> <li> <p> <code>LARGE_12X</code> </p> </li> </ul> <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p> <p>The following legacy instance types are available, but their use is discouraged:</p> <ul> <li> <p> <b>T2_SMALL</b>: A t2.small instance type.</p> </li> <li> <p> <b>T2_MEDIUM</b>: A t2.medium instance type.</p> </li> <li> <p> <b>R4_LARGE</b>: A r4.large instance type.</p> </li> <li> <p> <b>R4_XLARGE</b>: A r4.xlarge instance type.</p> </li> <li> <p> <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p> </li> <li> <p> <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p> </li> <li> <p> <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p> </li> </ul>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ApiCacheType Type { get; set; }
	}
	
	public class CreateApiKeyPostBody
	{
		
		/// <summary>
		/// A description of the purpose of the API key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// From the creation time, the time after which the API key expires. The date is represented as seconds since the epoch, rounded down to the nearest hour. The default value for this parameter is 7 days from creation time. For more information, see .
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expires")]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	public class CreateDataSourcePostBody
	{
		
		/// <summary>
		/// A user-supplied name for the <code>DataSource</code>.
		/// Required
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[_A-Za-z][_0-9A-Za-z]*")]
		public string Name { get; set; }
		
		/// <summary>
		/// A description of the <code>DataSource</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The type of the <code>DataSource</code>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DataSourceType Type { get; set; }
		
		/// <summary>
		/// The Identity and Access Management (IAM) service role Amazon Resource Name (ARN) for the data source. The system assumes this role when accessing the data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceRoleArn")]
		public string ServiceRoleArn { get; set; }
		
		/// <summary>
		/// Describes an Amazon DynamoDB data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamodbConfig")]
		public CreateDataSourcePostBodyDynamodbConfig DynamodbConfig { get; set; }
		
		/// <summary>
		/// Describes an Lambda data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lambdaConfig")]
		public CreateDataSourcePostBodyLambdaConfig LambdaConfig { get; set; }
		
		/// <summary>
		/// <p>Describes an OpenSearch data source configuration.</p> <p>As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use <a>OpenSearchServiceDataSourceConfig</a> to specify an OpenSearch data source.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="elasticsearchConfig")]
		public CreateDataSourcePostBodyElasticsearchConfig ElasticsearchConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenSearch data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openSearchServiceConfig")]
		public CreateDataSourcePostBodyOpenSearchServiceConfig OpenSearchServiceConfig { get; set; }
		
		/// <summary>
		/// Describes an HTTP data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpConfig")]
		public CreateDataSourcePostBodyHttpConfig HttpConfig { get; set; }
		
		/// <summary>
		/// Describes a relational database data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationalDatabaseConfig")]
		public CreateDataSourcePostBodyRelationalDatabaseConfig RelationalDatabaseConfig { get; set; }
		
		/// <summary>
		/// Describes an Amazon EventBridge bus data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventBridgeConfig")]
		public CreateDataSourcePostBodyEventBridgeConfig EventBridgeConfig { get; set; }
	}
	
	public class CreateDataSourcePostBodyDynamodbConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="tableName")]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="useCallerCredentials")]
		public System.Nullable<System.Boolean> UseCallerCredentials { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deltaSyncConfig")]
		public DeltaSyncConfig DeltaSyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="versioned")]
		public System.Nullable<System.Boolean> Versioned { get; set; }
	}
	
	public class CreateDataSourcePostBodyLambdaConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionArn")]
		public string LambdaFunctionArn { get; set; }
	}
	
	public class CreateDataSourcePostBodyElasticsearchConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
	}
	
	public class CreateDataSourcePostBodyOpenSearchServiceConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
	}
	
	public class CreateDataSourcePostBodyHttpConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizationConfig")]
		public AuthorizationConfig AuthorizationConfig { get; set; }
	}
	
	public class CreateDataSourcePostBodyRelationalDatabaseConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="relationalDatabaseSourceType")]
		public RelationalDatabaseSourceType RelationalDatabaseSourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rdsHttpEndpointConfig")]
		public RdsHttpEndpointConfig RdsHttpEndpointConfig { get; set; }
	}
	
	public class CreateDataSourcePostBodyEventBridgeConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="eventBusArn")]
		public string EventBusArn { get; set; }
	}
	
	public class CreateDomainNamePostBody
	{
		
		/// <summary>
		/// The domain name.
		/// Required
		/// Max length: 253
		/// Min length: 1
		/// Pattern: ^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(253)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^(\*[\w\d-]*\.)?([\w\d-]+\.)+[\w\d-]+$")]
		public string DomainName { get; set; }
		
		/// <summary>
		/// The Amazon Resource Name (ARN) of the certificate. This can be an Certificate Manager (ACM) certificate or an Identity and Access Management (IAM) server certificate.
		/// Required
		/// Max length: 2048
		/// Min length: 20
		/// Pattern: ^arn:[a-z-]*:(acm|iam):[a-z0-9-]*:\d{12}:(certificate|server-certificate)/[0-9A-Za-z_/-]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateArn")]
		[System.ComponentModel.DataAnnotations.MinLength(20)]
		[System.ComponentModel.DataAnnotations.MaxLength(2048)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^arn:[a-z-]*:(acm|iam):[a-z0-9-]*:\d{12}:(certificate|server-certificate)/[0-9A-Za-z_/-]*$")]
		public string CertificateArn { get; set; }
		
		/// <summary>
		/// A description of the <code>DomainName</code>.
		/// Max length: 255
		/// Min length: 0
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string Description { get; set; }
	}
	
	public class CreateFunctionPostBody
	{
		
		/// <summary>
		/// The <code>Function</code> name. The function name does not have to be unique.
		/// Required
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[_A-Za-z][_0-9A-Za-z]*")]
		public string Name { get; set; }
		
		/// <summary>
		/// The <code>Function</code> description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The <code>Function</code> <code>DataSource</code> name.
		/// Required
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[_A-Za-z][_0-9A-Za-z]*")]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// The <code>Function</code> request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// The <code>Function</code> response mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string ResponseMappingTemplate { get; set; }
		
		/// <summary>
		/// The <code>version</code> of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the <code>functionVersion</code> is required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="functionVersion")]
		public string FunctionVersion { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public CreateFunctionPostBodySyncConfig SyncConfig { get; set; }
		
		/// <summary>
		/// The maximum batching size for a resolver.
		/// Minimum: 0
		/// Maximum: 2000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		[System.ComponentModel.DataAnnotations.Range(0, 2000)]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public CreateFunctionPostBodyRuntime Runtime { get; set; }
		
		/// <summary>
		/// The <code>function</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.
		/// Max length: 32768
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32768)]
		public string Code { get; set; }
	}
	
	public class CreateFunctionPostBodySyncConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="conflictHandler")]
		public ConflictHandlerType ConflictHandler { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="conflictDetection")]
		public ConflictDetectionType ConflictDetection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConflictHandlerConfig")]
		public LambdaConflictHandlerConfig LambdaConflictHandlerConfig { get; set; }
	}
	
	public class CreateFunctionPostBodyRuntime
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public RuntimeName Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="runtimeVersion")]
		public string RuntimeVersion { get; set; }
	}
	
	public class CreateGraphqlApiPostBody
	{
		
		/// <summary>
		/// A user-supplied name for the <code>GraphqlApi</code>.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Amazon CloudWatch Logs configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public CreateGraphqlApiPostBodyLogConfig LogConfig { get; set; }
		
		/// <summary>
		/// The authentication type: API key, Identity and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authenticationType")]
		public AuthenticationType AuthenticationType { get; set; }
		
		/// <summary>
		/// Describes an Amazon Cognito user pool configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userPoolConfig")]
		public CreateGraphqlApiPostBodyUserPoolConfig UserPoolConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenID Connect (OIDC) configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openIDConnectConfig")]
		public CreateGraphqlApiPostBodyOpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		/// <summary>
		/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// A list of additional authentication providers for the <code>GraphqlApi</code> API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalAuthenticationProviders")]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		/// <summary>
		/// A flag indicating whether to use X-Ray tracing for the <code>GraphqlApi</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xrayEnabled")]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
		
		/// <summary>
		/// A <code>LambdaAuthorizerConfig</code> specifies how to authorize AppSync API access when using the <code>AWS_LAMBDA</code> authorizer mode. Be aware that an AppSync API can have only one Lambda authorizer configured at a time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lambdaAuthorizerConfig")]
		public CreateGraphqlApiPostBodyLambdaAuthorizerConfig LambdaAuthorizerConfig { get; set; }
		
		/// <summary>
		/// Sets the value of the GraphQL API to public (<code>GLOBAL</code>) or private (<code>PRIVATE</code>). If no value is provided, the visibility will be set to <code>GLOBAL</code> by default. This value cannot be changed once the API has been created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public GraphQLApiVisibility Visibility { get; set; }
		
		/// <summary>
		/// The value that indicates whether the GraphQL API is a standard API (<code>GRAPHQL</code>) or merged API (<code>MERGED</code>).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiType")]
		public GraphQLApiType ApiType { get; set; }
		
		/// <summary>
		/// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the <code>AUTO_MERGE</code> to update the merged API endpoint with the source API changes automatically.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mergedApiExecutionRoleArn")]
		public string MergedApiExecutionRoleArn { get; set; }
		
		/// <summary>
		/// <p>The owner contact information for an API resource.</p> <p>This field accepts any string input with a length of 0 - 256 characters.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ownerContact")]
		public string OwnerContact { get; set; }
	}
	
	public class CreateGraphqlApiPostBodyLogConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="fieldLogLevel")]
		public FieldLogLevel FieldLogLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cloudWatchLogsRoleArn")]
		public string CloudWatchLogsRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludeVerboseContent")]
		public System.Nullable<System.Boolean> ExcludeVerboseContent { get; set; }
	}
	
	public class CreateGraphqlApiPostBodyUserPoolConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="userPoolId")]
		public string UserPoolId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultAction")]
		public DefaultAction DefaultAction { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="appIdClientRegex")]
		public string AppIdClientRegex { get; set; }
	}
	
	public class CreateGraphqlApiPostBodyOpenIDConnectConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="iatTTL")]
		public System.Nullable<System.Int32> IatTTL { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authTTL")]
		public System.Nullable<System.Int32> AuthTTL { get; set; }
	}
	
	public class CreateGraphqlApiPostBodyLambdaAuthorizerConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="authorizerResultTtlInSeconds")]
		public System.Nullable<System.Int32> AuthorizerResultTtlInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerUri")]
		public string AuthorizerUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="identityValidationExpression")]
		public string IdentityValidationExpression { get; set; }
	}
	
	public class CreateResolverPostBody
	{
		
		/// <summary>
		/// The name of the field to attach the resolver to.
		/// Required
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fieldName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[_A-Za-z][_0-9A-Za-z]*")]
		public string FieldName { get; set; }
		
		/// <summary>
		/// The name of the data source for which the resolver is being created.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[_A-Za-z][_0-9A-Za-z]*")]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// <p>The mapping template to use for requests.</p> <p>A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL).</p> <p>VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.</p>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// The mapping template to use for responses from the data source.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string ResponseMappingTemplate { get; set; }
		
		/// <summary>
		/// <p>The resolver type.</p> <ul> <li> <p> <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.</p> </li> <li> <p> <b>PIPELINE</b>: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of <code>Function</code> objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public ResolverKind Kind { get; set; }
		
		/// <summary>
		/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pipelineConfig")]
		public CreateResolverPostBodyPipelineConfig PipelineConfig { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public CreateResolverPostBodySyncConfig SyncConfig { get; set; }
		
		/// <summary>
		/// The caching configuration for a resolver that has caching activated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cachingConfig")]
		public CreateResolverPostBodyCachingConfig CachingConfig { get; set; }
		
		/// <summary>
		/// The maximum batching size for a resolver.
		/// Minimum: 0
		/// Maximum: 2000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		[System.ComponentModel.DataAnnotations.Range(0, 2000)]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public CreateResolverPostBodyRuntime Runtime { get; set; }
		
		/// <summary>
		/// The <code>resolver</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.
		/// Max length: 32768
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32768)]
		public string Code { get; set; }
	}
	
	public class CreateResolverPostBodyPipelineConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="functions")]
		public string[] Functions { get; set; }
	}
	
	public class CreateResolverPostBodySyncConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="conflictHandler")]
		public ConflictHandlerType ConflictHandler { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="conflictDetection")]
		public ConflictDetectionType ConflictDetection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConflictHandlerConfig")]
		public LambdaConflictHandlerConfig LambdaConflictHandlerConfig { get; set; }
	}
	
	public class CreateResolverPostBodyCachingConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cachingKeys")]
		public string[] CachingKeys { get; set; }
	}
	
	public class CreateResolverPostBodyRuntime
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public RuntimeName Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="runtimeVersion")]
		public string RuntimeVersion { get; set; }
	}
	
	public class CreateTypePostBody
	{
		
		/// <summary>
		/// <p>The type definition, in GraphQL Schema Definition Language (SDL) format.</p> <p>For more information, see the <a href="http://graphql.org/learn/schema/">GraphQL SDL documentation</a>.</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		/// <summary>
		/// The type format: SDL or JSON.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public TypeDefinitionFormat Format { get; set; }
	}
	
	public class UpdateApiKeyPostBody
	{
		
		/// <summary>
		/// A description of the purpose of the API key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// From the update time, the time after which the API key expires. The date is represented as seconds since the epoch. For more information, see .
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expires")]
		public System.Nullable<System.Int32> Expires { get; set; }
	}
	
	public class UpdateDataSourcePostBody
	{
		
		/// <summary>
		/// The new description for the data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The new data source type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DataSourceType Type { get; set; }
		
		/// <summary>
		/// The new service role Amazon Resource Name (ARN) for the data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceRoleArn")]
		public string ServiceRoleArn { get; set; }
		
		/// <summary>
		/// Describes an Amazon DynamoDB data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dynamodbConfig")]
		public UpdateDataSourcePostBodyDynamodbConfig DynamodbConfig { get; set; }
		
		/// <summary>
		/// Describes an Lambda data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lambdaConfig")]
		public UpdateDataSourcePostBodyLambdaConfig LambdaConfig { get; set; }
		
		/// <summary>
		/// <p>Describes an OpenSearch data source configuration.</p> <p>As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch Service. This configuration is deprecated. For new data sources, use <a>OpenSearchServiceDataSourceConfig</a> to specify an OpenSearch data source.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="elasticsearchConfig")]
		public UpdateDataSourcePostBodyElasticsearchConfig ElasticsearchConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenSearch data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openSearchServiceConfig")]
		public UpdateDataSourcePostBodyOpenSearchServiceConfig OpenSearchServiceConfig { get; set; }
		
		/// <summary>
		/// Describes an HTTP data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpConfig")]
		public UpdateDataSourcePostBodyHttpConfig HttpConfig { get; set; }
		
		/// <summary>
		/// Describes a relational database data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationalDatabaseConfig")]
		public UpdateDataSourcePostBodyRelationalDatabaseConfig RelationalDatabaseConfig { get; set; }
		
		/// <summary>
		/// Describes an Amazon EventBridge bus data source configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventBridgeConfig")]
		public UpdateDataSourcePostBodyEventBridgeConfig EventBridgeConfig { get; set; }
	}
	
	public class UpdateDataSourcePostBodyDynamodbConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="tableName")]
		public string TableName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="useCallerCredentials")]
		public System.Nullable<System.Boolean> UseCallerCredentials { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="deltaSyncConfig")]
		public DeltaSyncConfig DeltaSyncConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="versioned")]
		public System.Nullable<System.Boolean> Versioned { get; set; }
	}
	
	public class UpdateDataSourcePostBodyLambdaConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="lambdaFunctionArn")]
		public string LambdaFunctionArn { get; set; }
	}
	
	public class UpdateDataSourcePostBodyElasticsearchConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
	}
	
	public class UpdateDataSourcePostBodyOpenSearchServiceConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
	}
	
	public class UpdateDataSourcePostBodyHttpConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizationConfig")]
		public AuthorizationConfig AuthorizationConfig { get; set; }
	}
	
	public class UpdateDataSourcePostBodyRelationalDatabaseConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="relationalDatabaseSourceType")]
		public RelationalDatabaseSourceType RelationalDatabaseSourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rdsHttpEndpointConfig")]
		public RdsHttpEndpointConfig RdsHttpEndpointConfig { get; set; }
	}
	
	public class UpdateDataSourcePostBodyEventBridgeConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="eventBusArn")]
		public string EventBusArn { get; set; }
	}
	
	public class UpdateDomainNamePostBody
	{
		
		/// <summary>
		/// A description of the <code>DomainName</code>.
		/// Max length: 255
		/// Min length: 0
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string Description { get; set; }
	}
	
	public class UpdateFunctionPostBody
	{
		
		/// <summary>
		/// The <code>Function</code> name.
		/// Required
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[_A-Za-z][_0-9A-Za-z]*")]
		public string Name { get; set; }
		
		/// <summary>
		/// The <code>Function</code> description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The <code>Function</code> <code>DataSource</code> name.
		/// Required
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[_A-Za-z][_0-9A-Za-z]*")]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// The <code>Function</code> request mapping template. Functions support only the 2018-05-29 version of the request mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// The <code>Function</code> request mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string ResponseMappingTemplate { get; set; }
		
		/// <summary>
		/// The <code>version</code> of the request mapping template. Currently, the supported value is 2018-05-29. Note that when using VTL and mapping templates, the <code>functionVersion</code> is required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="functionVersion")]
		public string FunctionVersion { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public UpdateFunctionPostBodySyncConfig SyncConfig { get; set; }
		
		/// <summary>
		/// The maximum batching size for a resolver.
		/// Minimum: 0
		/// Maximum: 2000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		[System.ComponentModel.DataAnnotations.Range(0, 2000)]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public UpdateFunctionPostBodyRuntime Runtime { get; set; }
		
		/// <summary>
		/// The <code>function</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.
		/// Max length: 32768
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32768)]
		public string Code { get; set; }
	}
	
	public class UpdateFunctionPostBodySyncConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="conflictHandler")]
		public ConflictHandlerType ConflictHandler { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="conflictDetection")]
		public ConflictDetectionType ConflictDetection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConflictHandlerConfig")]
		public LambdaConflictHandlerConfig LambdaConflictHandlerConfig { get; set; }
	}
	
	public class UpdateFunctionPostBodyRuntime
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public RuntimeName Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="runtimeVersion")]
		public string RuntimeVersion { get; set; }
	}
	
	public class UpdateGraphqlApiPostBody
	{
		
		/// <summary>
		/// The new name for the <code>GraphqlApi</code> object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Amazon CloudWatch Logs configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public UpdateGraphqlApiPostBodyLogConfig LogConfig { get; set; }
		
		/// <summary>
		/// The new authentication type for the <code>GraphqlApi</code> object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationType")]
		public AuthenticationType AuthenticationType { get; set; }
		
		/// <summary>
		/// Describes an Amazon Cognito user pool configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userPoolConfig")]
		public UpdateGraphqlApiPostBodyUserPoolConfig UserPoolConfig { get; set; }
		
		/// <summary>
		/// Describes an OpenID Connect (OIDC) configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openIDConnectConfig")]
		public UpdateGraphqlApiPostBodyOpenIDConnectConfig OpenIDConnectConfig { get; set; }
		
		/// <summary>
		/// A list of additional authentication providers for the <code>GraphqlApi</code> API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalAuthenticationProviders")]
		public AdditionalAuthenticationProvider[] AdditionalAuthenticationProviders { get; set; }
		
		/// <summary>
		/// A flag indicating whether to use X-Ray tracing for the <code>GraphqlApi</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xrayEnabled")]
		public System.Nullable<System.Boolean> XrayEnabled { get; set; }
		
		/// <summary>
		/// A <code>LambdaAuthorizerConfig</code> specifies how to authorize AppSync API access when using the <code>AWS_LAMBDA</code> authorizer mode. Be aware that an AppSync API can have only one Lambda authorizer configured at a time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lambdaAuthorizerConfig")]
		public UpdateGraphqlApiPostBodyLambdaAuthorizerConfig LambdaAuthorizerConfig { get; set; }
		
		/// <summary>
		/// The Identity and Access Management service role ARN for a merged API. The AppSync service assumes this role on behalf of the Merged API to validate access to source APIs at runtime and to prompt the <code>AUTO_MERGE</code> to update the merged API endpoint with the source API changes automatically.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mergedApiExecutionRoleArn")]
		public string MergedApiExecutionRoleArn { get; set; }
		
		/// <summary>
		/// <p>The owner contact information for an API resource.</p> <p>This field accepts any string input with a length of 0 - 256 characters.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ownerContact")]
		public string OwnerContact { get; set; }
	}
	
	public class UpdateGraphqlApiPostBodyLogConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="fieldLogLevel")]
		public FieldLogLevel FieldLogLevel { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cloudWatchLogsRoleArn")]
		public string CloudWatchLogsRoleArn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="excludeVerboseContent")]
		public System.Nullable<System.Boolean> ExcludeVerboseContent { get; set; }
	}
	
	public class UpdateGraphqlApiPostBodyUserPoolConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="userPoolId")]
		public string UserPoolId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultAction")]
		public DefaultAction DefaultAction { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="appIdClientRegex")]
		public string AppIdClientRegex { get; set; }
	}
	
	public class UpdateGraphqlApiPostBodyOpenIDConnectConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="issuer")]
		public string Issuer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="iatTTL")]
		public System.Nullable<System.Int32> IatTTL { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authTTL")]
		public System.Nullable<System.Int32> AuthTTL { get; set; }
	}
	
	public class UpdateGraphqlApiPostBodyLambdaAuthorizerConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="authorizerResultTtlInSeconds")]
		public System.Nullable<System.Int32> AuthorizerResultTtlInSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authorizerUri")]
		public string AuthorizerUri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="identityValidationExpression")]
		public string IdentityValidationExpression { get; set; }
	}
	
	public class UpdateResolverPostBody
	{
		
		/// <summary>
		/// The new data source name.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: [_A-Za-z][_0-9A-Za-z]*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataSourceName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[_A-Za-z][_0-9A-Za-z]*")]
		public string DataSourceName { get; set; }
		
		/// <summary>
		/// <p>The new request mapping template.</p> <p>A resolver uses a request mapping template to convert a GraphQL expression into a format that a data source can understand. Mapping templates are written in Apache Velocity Template Language (VTL).</p> <p>VTL request mapping templates are optional when using an Lambda data source. For all other data sources, VTL request and response mapping templates are required.</p>
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMappingTemplate")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string RequestMappingTemplate { get; set; }
		
		/// <summary>
		/// The new response mapping template.
		/// Max length: 65536
		/// Min length: 1
		/// Pattern: ^.*$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseMappingTemplate")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^.*$")]
		public string ResponseMappingTemplate { get; set; }
		
		/// <summary>
		/// <p>The resolver type.</p> <ul> <li> <p> <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver type. You can use a UNIT resolver to run a GraphQL query against a single data source.</p> </li> <li> <p> <b>PIPELINE</b>: A PIPELINE resolver type. You can use a PIPELINE resolver to invoke a series of <code>Function</code> objects in a serial manner. You can use a pipeline resolver to run a GraphQL query against multiple data sources.</p> </li> </ul>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public ResolverKind Kind { get; set; }
		
		/// <summary>
		/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pipelineConfig")]
		public UpdateResolverPostBodyPipelineConfig PipelineConfig { get; set; }
		
		/// <summary>
		/// <p>Describes a Sync configuration for a resolver.</p> <p>Specifies which Conflict Detection strategy and Resolution strategy to use when the resolver is invoked.</p>
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public UpdateResolverPostBodySyncConfig SyncConfig { get; set; }
		
		/// <summary>
		/// The caching configuration for a resolver that has caching activated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cachingConfig")]
		public UpdateResolverPostBodyCachingConfig CachingConfig { get; set; }
		
		/// <summary>
		/// The maximum batching size for a resolver.
		/// Minimum: 0
		/// Maximum: 2000
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxBatchSize")]
		[System.ComponentModel.DataAnnotations.Range(0, 2000)]
		public System.Nullable<System.Int32> MaxBatchSize { get; set; }
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public UpdateResolverPostBodyRuntime Runtime { get; set; }
		
		/// <summary>
		/// The <code>resolver</code> code that contains the request and response functions. When code is used, the <code>runtime</code> is required. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.
		/// Max length: 32768
		/// Min length: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32768)]
		public string Code { get; set; }
	}
	
	public class UpdateResolverPostBodyPipelineConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="functions")]
		public string[] Functions { get; set; }
	}
	
	public class UpdateResolverPostBodySyncConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="conflictHandler")]
		public ConflictHandlerType ConflictHandler { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="conflictDetection")]
		public ConflictDetectionType ConflictDetection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lambdaConflictHandlerConfig")]
		public LambdaConflictHandlerConfig LambdaConflictHandlerConfig { get; set; }
	}
	
	public class UpdateResolverPostBodyCachingConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cachingKeys")]
		public string[] CachingKeys { get; set; }
	}
	
	public class UpdateResolverPostBodyRuntime
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public RuntimeName Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="runtimeVersion")]
		public string RuntimeVersion { get; set; }
	}
	
	public class UpdateTypePostBody
	{
		
		/// <summary>
		/// The new definition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		/// <summary>
		/// The new type format: SDL or JSON.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public TypeDefinitionFormat Format { get; set; }
	}
	
	public class UpdateSourceApiAssociationPostBody
	{
		
		/// <summary>
		/// The description field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Describes properties used to specify configurations related to a source API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceApiAssociationConfig")]
		public UpdateSourceApiAssociationPostBodySourceApiAssociationConfig SourceApiAssociationConfig { get; set; }
	}
	
	public class UpdateSourceApiAssociationPostBodySourceApiAssociationConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="mergeType")]
		public MergeType MergeType { get; set; }
	}
	
	public class EvaluateCodePostBody
	{
		
		/// <summary>
		/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver or Amazon Web Services AppSync function. Specifies the name and version of the runtime to use. Note that if a runtime is specified, code must also be specified.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runtime")]
		public EvaluateCodePostBodyRuntime Runtime { get; set; }
		
		/// <summary>
		/// The code definition to be evaluated. Note that <code>code</code> and <code>runtime</code> are both required for this action. The <code>runtime</code> value must be <code>APPSYNC_JS</code>.
		/// Required
		/// Max length: 32768
		/// Min length: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(32768)]
		public string Code { get; set; }
		
		/// <summary>
		/// The map that holds all of the contextual information for your resolver invocation. A <code>context</code> is required for this action.
		/// Required
		/// Max length: 28000
		/// Min length: 2
		/// Pattern: ^[\s\S]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(28000)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[\s\S]*$")]
		public string Context { get; set; }
		
		/// <summary>
		/// The function within the code to be evaluated. If provided, the valid values are <code>request</code> and <code>response</code>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="function")]
		public string Function { get; set; }
	}
	
	public class EvaluateCodePostBodyRuntime
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public RuntimeName Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="runtimeVersion")]
		public string RuntimeVersion { get; set; }
	}
	
	public class EvaluateMappingTemplatePostBody
	{
		
		/// <summary>
		/// The mapping template; this can be a request or response template. A <code>template</code> is required for this action.
		/// Required
		/// Max length: 65536
		/// Min length: 2
		/// Pattern: ^[\s\S]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="template")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(65536)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[\s\S]*$")]
		public string Template { get; set; }
		
		/// <summary>
		/// The map that holds all of the contextual information for your resolver invocation. A <code>context</code> is required for this action.
		/// Required
		/// Max length: 28000
		/// Min length: 2
		/// Pattern: ^[\s\S]*$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(28000)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[\s\S]*$")]
		public string Context { get; set; }
	}
	
	public class StartSchemaCreationPostBody
	{
		
		/// <summary>
		/// The schema definition, in GraphQL schema language format.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// A map with keys of <code>TagKey</code> objects and values of <code>TagValue</code> objects.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class UpdateApiCachePostBody
	{
		
		/// <summary>
		/// <p>TTL in seconds for cache entries.</p> <p>Valid values are 13,600 seconds.</p>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public int Ttl { get; set; }
		
		/// <summary>
		/// <p>Caching behavior.</p> <ul> <li> <p> <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.</p> </li> <li> <p> <b>PER_RESOLVER_CACHING</b>: Individual resolvers that you specify are cached.</p> </li> </ul>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apiCachingBehavior")]
		public ApiCachingBehavior ApiCachingBehavior { get; set; }
		
		/// <summary>
		/// <p>The cache instance type. Valid values are </p> <ul> <li> <p> <code>SMALL</code> </p> </li> <li> <p> <code>MEDIUM</code> </p> </li> <li> <p> <code>LARGE</code> </p> </li> <li> <p> <code>XLARGE</code> </p> </li> <li> <p> <code>LARGE_2X</code> </p> </li> <li> <p> <code>LARGE_4X</code> </p> </li> <li> <p> <code>LARGE_8X</code> (not available in all regions)</p> </li> <li> <p> <code>LARGE_12X</code> </p> </li> </ul> <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p> <p>The following legacy instance types are available, but their use is discouraged:</p> <ul> <li> <p> <b>T2_SMALL</b>: A t2.small instance type.</p> </li> <li> <p> <b>T2_MEDIUM</b>: A t2.medium instance type.</p> </li> <li> <p> <b>R4_LARGE</b>: A r4.large instance type.</p> </li> <li> <p> <b>R4_XLARGE</b>: A r4.xlarge instance type.</p> </li> <li> <p> <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p> </li> <li> <p> <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p> </li> <li> <p> <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p> </li> </ul>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ApiCacheType Type { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
