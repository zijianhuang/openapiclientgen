//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Absorption Ratio
		/// Compute the absorption ratio associated to a universe of assets.
		/// 
		/// References
		/// * [Mark Kritzman, Yuanzhen Li, Sebastien Page and Roberto Rigobon, Principal Components as a Measure of Systemic Risk, The Journal of Portfolio Management Summer 2011, 37 (4) 112-126](https://jpm.pm-research.com/content/37/4/112)
		/// 
		/// AssetsAnalysisAbsorption_ratioPost assets/analysis/absorption-ratio
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsAnalysisAbsorption_ratioPostReturn> AssetsAnalysisAbsorption_ratioPostAsync(AssetsAnalysisAbsorption_ratioPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/analysis/absorption-ratio";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsAnalysisAbsorption_ratioPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Turbulence Index
		/// Compute the turbulence index associated to a universe of assets.
		/// 
		/// References
		/// * [M. Kritzman, Y. Li, Skulls, Financial Turbulence, and Risk Management,Financial Analysts Journal, Volume 66, Number 5, Pages 30-41, Year 2010](https://www.tandfonline.com/doi/abs/10.2469/faj.v66.n5.3)
		/// * [Kinlaw, W., Turkington, D. Correlation surprise. J Asset Manag 14, 385–399 (2013)](https://link.springer.com/article/10.1057/jam.2013.27)
		/// 
		/// AssetsAnalysisTurbulence_indexPost assets/analysis/turbulence-index
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsAnalysisTurbulence_indexPostReturn> AssetsAnalysisTurbulence_indexPostAsync(AssetsAnalysisTurbulence_indexPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/analysis/turbulence-index";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsAnalysisTurbulence_indexPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Correlation Matrix
		/// Compute the Pearson asset correlation matrix from either:
		/// * The asset returns
		/// * The asset covariance matrix
		/// 
		/// References
		/// * [Wikipedia, Correlation and Dependence](https://en.wikipedia.org/wiki/Correlation_and_dependence#Correlation_matrices)
		/// 
		/// AssetsCorrelationMatrixPost assets/correlation/matrix
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixPostReturn> AssetsCorrelationMatrixPostAsync(AssetsCorrelationMatrixPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Correlation Matrix Bounds
		/// Compute the lower bounds and the upper bounds of an asset correlation matrix associated to a given group of assets.
		/// 
		/// References
		/// * [Kawee Numpacharoen & Kornkanok Bunwong (2013) Boundaries of Correlation Adjustment with Applications to Financial Risk Management, Applied Mathematical Finance, 20:4, 403-414](http://dx.doi.org/10.1080/1350486X.2012.723517).
		/// 
		/// AssetsCorrelationMatrixBoundsPost assets/correlation/matrix/bounds
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixBoundsPostReturn> AssetsCorrelationMatrixBoundsPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/bounds";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixBoundsPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Denoised Correlation Matrix
		/// Compute a denoised asset correlation matrix, using one of the following methods:
		/// * The eigenvalues clipping method, described in the first reference, which is based on random matrix theory
		/// 
		/// References
		/// * [Laurent Laloux, Pierre Cizeau, Jean-Philippe Bouchaud, and Marc Potters, Noise Dressing of Financial Correlation Matrices, Phys. Rev. Lett. 83, 1467](https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.83.1467)
		/// 
		/// AssetsCorrelationMatrixDenoisedPost assets/correlation/matrix/denoised
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixDenoisedPostReturn> AssetsCorrelationMatrixDenoisedPostAsync(AssetsCorrelationMatrixDenoisedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/denoised";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixDenoisedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Correlation Matrix Distance
		/// Compute the distance between an asset correlation matrix and a reference correlation matrix, using one of the following distance metrics:
		/// * Euclidean distance (default), which is the distance induced by [the Frobenius norm](https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm)
		/// * Correlation matrix distance, defined in the first reference, which corresponds to [the cosine distance](https://en.wikipedia.org/wiki/Cosine_similarity) between the two vectorized asset correlation matrices
		/// * Bures distance, defined in the second reference
		/// 
		/// References
		/// * [M. Herdin, N. Czink, H. Ozcelik and E. Bonek, Correlation matrix distance, a meaningful measure for evaluation of non-stationary MIMO channels, 2005 IEEE 61st Vehicular Technology Conference, 2005, pp. 136-140 Vol. 1](https://ieeexplore.ieee.org/document/1543265)
		/// * [Rajendra Bhatia, Tanvi Jain, Yongdo Lim, On the Bures–Wasserstein distance between positive definite matrices, Expositiones Mathematicae, Volume 37, Issue 2, 2019](https://www.sciencedirect.com/science/article/pii/S0723086918300021)
		/// 
		/// AssetsCorrelationMatrixDistancePost assets/correlation/matrix/distance
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixDistancePostReturn> AssetsCorrelationMatrixDistancePostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/distance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixDistancePostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Correlation Matrix Effective Rank
		/// Compute the effective rank of an asset correlation matrix.
		/// 
		/// References
		/// * [Olivier Roy and Martin Vetterli, The effective rank: A measure of effective dimensionality, 15th European Signal Processing Conference, 2007](https://ieeexplore.ieee.org/document/7098875)
		/// 
		/// AssetsCorrelationMatrixEffective_rankPost assets/correlation/matrix/effective-rank
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixEffective_rankPostReturn> AssetsCorrelationMatrixEffective_rankPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/effective-rank";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixEffective_rankPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Correlation Matrix Informativeness
		/// Compute the informativeness of an asset correlation matrix, using one of the following distance metrics:
		/// * Euclidean distance (default), which is the distance induced by [the Frobenius norm](https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm)
		/// * Correlation matrix distance, defined in the second reference, which corresponds to [the cosine distance](https://en.wikipedia.org/wiki/Cosine_similarity) between the two vectorized asset correlation matrices
		/// * Bures distance, defined in the third reference
		/// 
		/// References
		/// * [Austin J. Brockmeier and Tingting Mu and Sophia Ananiadou and John Y. Goulermas, Quantifying the Informativeness of Similarity Measurements, Journal of Machine Learning Research, 2017](http://jmlr.org/papers/v18/16-296.html)
		/// * [M. Herdin, N. Czink, H. Ozcelik and E. Bonek, Correlation matrix distance, a meaningful measure for evaluation of non-stationary MIMO channels, 2005 IEEE 61st Vehicular Technology Conference, 2005, pp. 136-140 Vol. 1](https://ieeexplore.ieee.org/document/1543265)
		/// * [Rajendra Bhatia, Tanvi Jain, Yongdo Lim, On the Bures–Wasserstein distance between positive definite matrices, Expositiones Mathematicae, Volume 37, Issue 2, 2019](https://www.sciencedirect.com/science/article/pii/S0723086918300021)
		/// 
		/// AssetsCorrelationMatrixInformativenessPost assets/correlation/matrix/informativeness
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixInformativenessPostReturn> AssetsCorrelationMatrixInformativenessPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/informativeness";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixInformativenessPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Nearest Correlation Matrix
		/// Compute the _closest_ - in terms of [the Frobenius norm](https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm) - asset correlation matrix to an approximate asset correlation matrix, optionally keeping a selected number of correlations fixed.
		/// 
		/// References
		/// * [Nicholas J. Higham, Computing the Nearest Correlation Matrix—A Problem from Finance, IMA J. Numer. Anal. 22, 329–343, 2002.](http://www.maths.manchester.ac.uk/~higham/narep/narep369.pdf)
		/// 
		/// AssetsCorrelationMatrixNearestPost assets/correlation/matrix/nearest
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixNearestPostReturn> AssetsCorrelationMatrixNearestPostAsync(AssetsCorrelationMatrixNearestPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/nearest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixNearestPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Random Correlation Matrix
		/// Generate an asset correlation matrix uniformly at random over the space of positive definite correlation matrices.
		/// 
		/// References
		/// * [Joe, H., Generating random correlation matrices based on partial correlations. Journal of Multivariate Analysis, 2006, 97, 2177-2189](https://www.sciencedirect.com/science/article/pii/S0047259X05000886)
		/// 
		/// AssetsCorrelationMatrixRandomPost assets/correlation/matrix/random
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixRandomPostReturn> AssetsCorrelationMatrixRandomPostAsync(AssetsCorrelationMatrixRandomPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/random";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixRandomPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Correlation Matrix Shrinkage
		/// Compute an asset correlation matrix as a convex linear combination of an asset correlation matrix and a target correlation matrix, the target correlation matrix being either:
		/// * An equicorrelation matrix made of 1
		/// * An equicorrelation matrix made of 0
		/// * An equicorrelation matrix made of -1/(n-1), with n the number of assets
		/// * A provided correlation matrix
		/// 
		/// References
		/// * [Steiner, Andreas, Manipulating Valid Correlation Matrices](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1878165)
		/// 
		/// AssetsCorrelationMatrixShrinkagePost assets/correlation/matrix/shrinkage
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixShrinkagePostReturn> AssetsCorrelationMatrixShrinkagePostAsync(AssetsCorrelationMatrixShrinkagePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/shrinkage";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixShrinkagePostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Theory-Implied Correlation Matrix
		/// Compute the theory-implied asset correlation matrix associated with:
		/// * A hierarchical classification of a universe of assets
		/// * An asset correlation matrix
		/// 
		/// References
		/// * [Lopez de Prado, Marcos Estimation of Theory-Implied Correlation Matrices (November 9, 2019)](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3484152)
		/// 
		/// AssetsCorrelationMatrixTheory_impliedPost assets/correlation/matrix/theory-implied
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixTheory_impliedPostReturn> AssetsCorrelationMatrixTheory_impliedPostAsync(AssetsCorrelationMatrixTheory_impliedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/theory-implied";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixTheory_impliedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Correlation Matrix Validation
		/// Validate whether a matrix is an asset correlation matrix.
		/// 
		/// References
		/// * [Wikipedia, Correlation and Dependence](https://en.wikipedia.org/wiki/Correlation_and_dependence#Correlation_matrices)
		/// 
		/// AssetsCorrelationMatrixValidationPost assets/correlation/matrix/validation
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCorrelationMatrixValidationPostReturn> AssetsCorrelationMatrixValidationPostAsync(AssetsCorrelationMatrixValidationPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/correlation/matrix/validation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCorrelationMatrixValidationPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Covariance Matrix
		/// Compute the covariance matrix of assets from either:
		/// * The asset correlation matrix and their volatilities (i.e., standard deviations)
		/// * The asset correlation matrix and their variances
		/// * The asset returns
		/// 
		/// References
		/// * [Wikipedia, Covariance Matrix](https://en.wikipedia.org/wiki/Covariance_matrix)
		/// 
		/// AssetsCovarianceMatrixPost assets/covariance/matrix
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCovarianceMatrixPostReturn> AssetsCovarianceMatrixPostAsync(AssetsCovarianceMatrixPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/covariance/matrix";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCovarianceMatrixPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Covariance Matrix Effective Rank
		/// Compute the effective rank of an asset covariance matrix.
		/// 
		/// References
		/// * [Olivier Roy and Martin Vetterli, The effective rank: A measure of effective dimensionality, 15th European Signal Processing Conference, 2007](https://ieeexplore.ieee.org/document/7098875)
		/// 
		/// AssetsCovarianceMatrixEffective_rankPost assets/covariance/matrix/effective-rank
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCovarianceMatrixEffective_rankPostReturn> AssetsCovarianceMatrixEffective_rankPostAsync(object requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/covariance/matrix/effective-rank";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCovarianceMatrixEffective_rankPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Exponentially Weighted Covariance Matrix
		/// Compute an exponentially weighted covariance matrix of assets returns.
		/// 
		/// References
		/// * [RiskMetrics Group. Longerstaey, J. (1996). RiskMetrics technical document, Technical Report fourth edition](https://www.msci.com/documents/10199/5915b101-4206-4ba0-aee2-3449d5c7e95a)
		/// 
		/// AssetsCovarianceMatrixExponentially_weightedPost assets/covariance/matrix/exponentially-weighted
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCovarianceMatrixExponentially_weightedPostReturn> AssetsCovarianceMatrixExponentially_weightedPostAsync(AssetsCovarianceMatrixExponentially_weightedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/covariance/matrix/exponentially-weighted";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCovarianceMatrixExponentially_weightedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Covariance Matrix Validation
		/// Validate whether a matrix is a covariance matrix.
		/// 
		/// References
		/// * [Wikipedia, Covariance Matrix](https://en.wikipedia.org/wiki/Covariance_matrix)
		/// 
		/// AssetsCovarianceMatrixValidationPost assets/covariance/matrix/validation
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsCovarianceMatrixValidationPostReturn> AssetsCovarianceMatrixValidationPostAsync(AssetsCovarianceMatrixValidationPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/covariance/matrix/validation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsCovarianceMatrixValidationPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Kurtosis
		/// Compute the kurtosis of one or several asset(s), from the asset returns.
		/// 
		/// References
		/// * [Wikipedia, Kurtosis](https://en.wikipedia.org/wiki/Kurtosis)
		/// 
		/// AssetsKurtosisPost assets/kurtosis
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsKurtosisPostReturn> AssetsKurtosisPostAsync(AssetsKurtosisPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/kurtosis";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsKurtosisPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adjusted Prices
		/// Compute the backward-adjusted prices of one or several asset(s) for one or several date(s) from:
		/// * Unadjusted prices
		/// * Capital distributions, like stock dividends
		/// * Splits, like stock splits
		/// 
		/// The adjustment base date is chosen to be the last date for which unadjusted prices are available, which implies that:
		/// * The price on the last date for which unadjusted prices are available is left unadjusted
		/// * The price on any other date is adjusted based on the capital distributions and the splits which occurred between this date and the last date for which unadjusted prices are available
		/// 
		/// References
		/// * [Center for Research in Security Prices](https://www.crsp.org/products/documentation/crsp-calculations)
		/// 
		/// AssetsPricesAdjustedPost assets/prices/adjusted
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsPricesAdjustedPostReturn> AssetsPricesAdjustedPostAsync(AssetsPricesAdjustedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/prices/adjusted";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsPricesAdjustedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Forward-Adjusted Prices
		/// Compute the forward-adjusted prices of one or several asset(s) for one or several date(s) from:
		/// * Unadjusted prices
		/// * Capital distributions, like stock dividends
		/// * Splits, like stock splits
		/// 
		/// The adjustment base date is chosen to be the first date for which unadjusted prices are available, which implies that:
		/// * The price on the first date for which unadjusted prices are available is left unadjusted
		/// * The price on any other date is adjusted based on the capital distributions and the splits which occurred between this date and the first date for which unadjusted prices are available
		/// 
		/// References
		/// * [Center for Research in Security Prices](https://www.crsp.org/products/documentation/crsp-calculations)
		/// 
		/// AssetsPricesAdjustedForwardPost assets/prices/adjusted/forward
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsPricesAdjustedForwardPostReturn> AssetsPricesAdjustedForwardPostAsync(AssetsPricesAdjustedForwardPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/prices/adjusted/forward";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsPricesAdjustedForwardPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Arithmetic Returns
		/// Compute the arithmetic return(s) of one or several asset(s) for one or several time period(s).
		/// 
		/// References
		/// * [Wikipedia, Rate of Return](https://en.wikipedia.org/wiki/Rate_of_return#Return)
		/// 
		/// AssetsReturnsPost assets/returns
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsReturnsPostReturn> AssetsReturnsPostAsync(AssetsReturnsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/returns";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsReturnsPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Arithmetic Average Return
		/// Compute the arithmetic average of the return(s) of one or several asset(s).
		/// 
		/// References
		/// * [Wikipedia, Arithmetic Average Rate of Return](https://en.wikipedia.org/wiki/Rate_of_return#Arithmetic_average_rate_of_return)
		/// 
		/// AssetsReturnsAveragePost assets/returns/average
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsReturnsAveragePostReturn> AssetsReturnsAveragePostAsync(AssetsReturnsAveragePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/returns/average";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsReturnsAveragePostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Logarithmic Returns
		/// Compute the logarithmic return(s) of one or several asset(s) for one or several time period(s).
		/// 
		/// References
		/// * [Wikipedia, Logarithmic or continuously compounded return](https://en.wikipedia.org/wiki/Rate_of_return#Logarithmic_or_continuously_compounded_return)
		/// 
		/// AssetsReturnsLogarithmicPost assets/returns/logarithmic
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsReturnsLogarithmicPostReturn> AssetsReturnsLogarithmicPostAsync(AssetsReturnsLogarithmicPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/returns/logarithmic";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsReturnsLogarithmicPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Bootstrap
		/// Simulate the return(s) of one or several asset(s) for one or several time period(s) using a bootstrap method.
		/// 
		/// References
		/// * [Efron, B. (1979), Bootstrap methods: Another look at the jackknife, The Annals of Statistics 7, 1-26](https://projecteuclid.org/journals/annals-of-statistics/volume-7/issue-1/Bootstrap-Methods-Another-Look-at-the-Jackknife/10.1214/aos/1176344552.full)
		/// * [Politis, D. N. and Romano, J. P., A circular block resampling procedure for stationary data, in R. Lepage and L. Billard, eds, Exploring the Limits of Bootstrap, Wiley, New York, pp. 263-270](https://statistics.stanford.edu/technical-reports/circular-block-resampling-procedure-stationary-data)
		/// * [Politis, D. N. and Romano, J. P., The stationary bootstrap, Journal of the American Statistical Association 89, 1303-1313](https://www.jstor.org/stable/2290993)
		/// 
		/// AssetsReturnsSimulationBootstrapPost assets/returns/simulation/bootstrap
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsReturnsSimulationBootstrapPostReturn> AssetsReturnsSimulationBootstrapPostAsync(AssetsReturnsSimulationBootstrapPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/returns/simulation/bootstrap";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsReturnsSimulationBootstrapPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Cornish-Fisher Distribution
		/// Simulate the return(s) of one asset for one or several time period(s) using a Cornish-Fisher distribution.
		/// 
		/// References
		/// * [Maillard, Didier, A User’s Guide to the Cornish Fisher Expansion](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1997178)
		/// * [Lamb, John D., Maura E. Monville, and Kai-Hong Tee. Making Cornish–Fisher Fit for Risk Measurement, Journal of Risk, Volume 21, Number 5, p. 53-81](http://doi.org/10.21314/JOR.2019.408)
		/// 
		/// AssetsReturnsSimulationMonte_carloCornish_fisherPost assets/returns/simulation/monte-carlo/cornish-fisher
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsReturnsSimulationMonte_carloCornish_fisherPostReturn> AssetsReturnsSimulationMonte_carloCornish_fisherPostAsync(AssetsReturnsSimulationMonte_carloCornish_fisherPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/returns/simulation/monte-carlo/cornish-fisher";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsReturnsSimulationMonte_carloCornish_fisherPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Corrected Cornish-Fisher Distribution
		/// Simulate the return(s) of one asset for one or several time period(s) using a corrected Cornish-Fisher distribution.
		/// 
		/// References
		/// * [Maillard, Didier, A User’s Guide to the Cornish Fisher Expansion](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1997178)
		/// * [Lamb, John D., Maura E. Monville, and Kai-Hong Tee. Making Cornish–fisher Fit for Risk Measurement, Journal of Risk, Volume 21, Number 5, p. 53-81](http://doi.org/10.21314/JOR.2019.408)
		/// 
		/// AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPost assets/returns/simulation/monte-carlo/cornish-fisher/corrected
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturn> AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostAsync(AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/returns/simulation/monte-carlo/cornish-fisher/corrected";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gaussian Distribution
		/// Simulate the return(s) of one asset for one or several time period(s) using a Gaussian distribution.
		/// 
		/// References
		/// * [Wikipedia, Normal distribution](https://en.wikipedia.org/wiki/Normal_distribution)
		/// 
		/// AssetsReturnsSimulationMonte_carloGaussianPost assets/returns/simulation/monte-carlo/gaussian
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsReturnsSimulationMonte_carloGaussianPostReturn> AssetsReturnsSimulationMonte_carloGaussianPostAsync(AssetsReturnsSimulationMonte_carloGaussianPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/returns/simulation/monte-carlo/gaussian";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsReturnsSimulationMonte_carloGaussianPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Turbulence-partitioned Asset Returns
		/// Partition asset returns into several subsets based on their turbulence index.
		/// 
		/// References
		/// * [George Chow, Jacquier, E., Kritzman, M., & Kenneth Lowry. (1999). Optimal Portfolios in Good Times and Bad. Financial Analysts Journal, 55(3), 65–73.](https://www.jstor.org/stable/4480169)
		/// 
		/// AssetsReturnsTurbulence_partitionedPost assets/returns/turbulence-partitioned
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsReturnsTurbulence_partitionedPostReturn> AssetsReturnsTurbulence_partitionedPostAsync(AssetsReturnsTurbulence_partitionedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/returns/turbulence-partitioned";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsReturnsTurbulence_partitionedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Skewness
		/// Compute the skewness of one or several asset(s), from the asset returns.
		/// 
		/// References
		/// * [Wikipedia, Skewness](https://en.wikipedia.org/wiki/Skewness)
		/// 
		/// AssetsSkewnessPost assets/skewness
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsSkewnessPostReturn> AssetsSkewnessPostAsync(AssetsSkewnessPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/skewness";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsSkewnessPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Variance
		/// Compute the variance of one or several asset(s) from either:
		/// * The asset returns
		/// * The asset covariance matrix
		/// * The asset volatility(ies)
		/// 
		/// References
		/// * [Wikipedia, Variance](https://en.wikipedia.org/wiki/Variance)
		/// 
		/// AssetsVariancePost assets/variance
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsVariancePostReturn> AssetsVariancePostAsync(AssetsVariancePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/variance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsVariancePostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Volatility
		/// Compute the volatility (i.e., standard deviation) of one or several asset(s) from either:
		/// * The asset returns
		/// * The asset covariance matrix
		/// * The asset variance(s)
		/// 
		/// References
		/// * [Wikipedia, Standard Deviation](https://en.wikipedia.org/wiki/Standard_deviation)
		/// 
		/// AssetsVolatilityPost assets/volatility
		/// </summary>
		/// <returns>OK</returns>
		public async Task<AssetsVolatilityPostReturn> AssetsVolatilityPostAsync(AssetsVolatilityPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "assets/volatility";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AssetsVolatilityPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Residualization
		/// Compute the residuals of a factor against a set of factors, using a returns-based linear regression analysis.
		/// 
		/// References
		/// * [Factor Research, Factor Exposure Analysis: Exploring Residualization](https://insights.factorresearch.com/research-factor-exposure-analysis-exploring-residualization/)
		/// * [Catalina B. Garcia, Román Salmeron, Claudia Garcia & Jose Garcia (2019): Residualization: justification, properties and application, Journal of Applied Statistics](https://doi.org/10.1080/02664763.2019.1701638)
		/// 
		/// FactorsResidualizationPost factors/residualization
		/// </summary>
		/// <returns>OK</returns>
		public async Task<FactorsResidualizationPostReturn> FactorsResidualizationPostAsync(FactorsResidualizationPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "factors/residualization";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FactorsResidualizationPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Alpha
		/// Compute the Jensen’s alpha of one or several portfolio(s) in the Capital Asset Pricing Model (CAPM).
		/// 
		/// References
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// 
		/// PortfolioAnalysisAlphaPost portfolio/analysis/alpha
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisAlphaPostReturn> PortfolioAnalysisAlphaPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/alpha";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisAlphaPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Beta
		/// Compute the beta of one or several portfolio(s) in the Capital Asset Pricing Model (CAPM).
		/// 
		/// References
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// 
		/// PortfolioAnalysisBetaPost portfolio/analysis/beta
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisBetaPostReturn> PortfolioAnalysisBetaPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/beta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisBetaPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return Contributions
		/// Perform a return contribution analysis of one or several portfolio(s), optionally using groups of assets.
		/// 
		/// References
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// 
		/// PortfolioAnalysisContributionsReturnPost portfolio/analysis/contributions/return
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisContributionsReturnPostReturn> PortfolioAnalysisContributionsReturnPostAsync(PortfolioAnalysisContributionsReturnPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/contributions/return";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisContributionsReturnPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Risk Contributions
		/// Perform a risk contribution analysis of one or several portfolio(s), optionally using groups of assets.
		/// 
		/// References
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// 
		/// PortfolioAnalysisContributionsRiskPost portfolio/analysis/contributions/risk
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisContributionsRiskPostReturn> PortfolioAnalysisContributionsRiskPostAsync(PortfolioAnalysisContributionsRiskPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/contributions/risk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisContributionsRiskPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Correlation Spectrum
		/// Compute the correlation spectrum of one or several portfolio(s).
		/// 
		/// References
		/// * [Tristan Froidure, Khalid Jalalzai and Yves Choueifaty, Portfolio Rho-Representativity, International Journal of Theoretical and Applied FinanceVol. 22, No. 07, 1950034 (2019)](https://www.worldscientific.com/doi/10.1142/S0219024919500341)
		/// 
		/// PortfolioAnalysisCorrelation_spectrumPost portfolio/analysis/correlation-spectrum
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisCorrelation_spectrumPostReturn> PortfolioAnalysisCorrelation_spectrumPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/correlation-spectrum";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisCorrelation_spectrumPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Diversification Ratio
		/// Compute the diversification ratio of one or several portfolio(s).
		/// 
		/// References
		/// * [Yves Choueifaty and Yves Coignard, Toward Maximum Diversification, The Journal of Portfolio Management Fall 2008, 35 (1) 40-51](https://doi.org/10.3905/JPM.2008.35.1.40)
		/// * [Tristan Froidure, Khalid Jalalzai and Yves Choueifaty, Portfolio Rho-Representativity, International Journal of Theoretical and Applied FinanceVol. 22, No. 07, 1950034 (2019)](https://www.worldscientific.com/doi/10.1142/S0219024919500341)
		/// 
		/// PortfolioAnalysisDiversification_ratioPost portfolio/analysis/diversification-ratio
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisDiversification_ratioPostReturn> PortfolioAnalysisDiversification_ratioPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/diversification-ratio";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisDiversification_ratioPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Drawdowns
		/// Compute the drawdown function - also called the underwater equity curve -, as well as the worst 10 drawdowns of one or several portfolio(s).
		/// 
		/// References
		/// * [Wikipedia, Drawdown](https://en.wikipedia.org/wiki/Drawdown_(economics))
		/// 
		/// PortfolioAnalysisDrawdownsPost portfolio/analysis/drawdowns
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisDrawdownsPostReturn> PortfolioAnalysisDrawdownsPostAsync(PortfolioAnalysisDrawdownsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/drawdowns";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisDrawdownsPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Effective Number of Bets
		/// Compute the effective number of bets of one or several portfolio(s).
		/// 
		/// References
		/// * [Meucci, Attilio and Santangelo, Alberto and Deguest, Romain, Risk Budgeting and Diversification Based on Optimized Uncorrelated Factors (November 10, 2015)](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2276632)
		/// 
		/// PortfolioAnalysisEffective_number_of_betsPost portfolio/analysis/effective-number-of-bets
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisEffective_number_of_betsPostReturn> PortfolioAnalysisEffective_number_of_betsPostAsync(PortfolioAnalysisEffective_number_of_betsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/effective-number-of-bets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisEffective_number_of_betsPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Factor Exposures
		/// Compute the exposures of one or several portfolio(s) to a set of factors, using a returns-based linear regression analysis.
		/// 
		/// References
		/// * [Measuring Factor Exposures: Uses and Abuses, Ronen Israel and Adrienne Ross, The Journal of Alternative Investments Summer 2017, 20 (1) 10-25](https://jai.pm-research.com/content/20/1/10.short)
		/// 
		/// PortfolioAnalysisFactorsExposuresPost portfolio/analysis/factors/exposures
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisFactorsExposuresPostReturn> PortfolioAnalysisFactorsExposuresPostAsync(PortfolioAnalysisFactorsExposuresPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/factors/exposures";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisFactorsExposuresPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Mean-Variance Efficient Frontier
		/// Compute the discretized mean-variance efficient frontier associated to a list of assets, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraint
		/// 
		/// References
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioAnalysisMean_varianceEfficient_frontierPost portfolio/analysis/mean-variance/efficient-frontier
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisMean_varianceEfficient_frontierPostReturn> PortfolioAnalysisMean_varianceEfficient_frontierPostAsync(PortfolioAnalysisMean_varianceEfficient_frontierPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/mean-variance/efficient-frontier";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisMean_varianceEfficient_frontierPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Mean-Variance Minimum Variance Frontier
		/// Compute the discretized mean-variance minimum variance frontier associated to a list of assets, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraint
		/// 
		/// > This endpoint is similar to the endpoint [`/portfolio/analysis/mean-variance/efficient-frontier`](#post-/portfolio/analysis/mean-variance/efficient-frontier), because the mean-variance efficient frontier is the "top" portion of the mean-variance minimum variance frontier.
		/// 
		/// References
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioAnalysisMean_varianceMinimum_variance_frontierPost portfolio/analysis/mean-variance/minimum-variance-frontier
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisMean_varianceMinimum_variance_frontierPostReturn> PortfolioAnalysisMean_varianceMinimum_variance_frontierPostAsync(PortfolioAnalysisMean_varianceMinimum_variance_frontierPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/mean-variance/minimum-variance-frontier";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisMean_varianceMinimum_variance_frontierPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Arithmetic Return
		/// Compute the arithmetic return of one or several portfolio(s) from either:
		/// * Portfolio assets arithmetic returns
		/// * Portfolio values
		/// 
		/// References
		/// * [Wikipedia, Rate of Return](https://en.wikipedia.org/wiki/Rate_of_return#Return)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioAnalysisReturnPost portfolio/analysis/return
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisReturnPostReturn> PortfolioAnalysisReturnPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/return";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisReturnPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Arithmetic Average Return
		/// Compute the arithmetic average of the arithmetic return(s) of one or several portfolio(s).
		/// 
		/// References
		/// * [Wikipedia, Arithmetic Average Rate of Return](https://en.wikipedia.org/wiki/Rate_of_return#Arithmetic_average_rate_of_return)
		/// 
		/// PortfolioAnalysisReturnsAveragePost portfolio/analysis/returns/average
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisReturnsAveragePostReturn> PortfolioAnalysisReturnsAveragePostAsync(PortfolioAnalysisReturnsAveragePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/returns/average";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisReturnsAveragePostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sharpe Ratio
		/// Compute the Sharpe ratio of one or several portfolio(s) from either:
		/// * Portfolio assets arithmetic returns and assets covariance matrix
		/// * Portfolio values
		/// 
		/// References
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioAnalysisSharpe_ratioPost portfolio/analysis/sharpe-ratio
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisSharpe_ratioPostReturn> PortfolioAnalysisSharpe_ratioPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/sharpe-ratio";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisSharpe_ratioPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Bias-Adjusted Sharpe Ratio
		/// Compute the Sharpe ratio of one or several portfolio(s), adjusted for small sample bias.
		/// 
		/// References
		/// * [Opdyke, J., Comparing Sharpe ratios: So where are the p-values?. J Asset Manag 8, 308–336 (2007)](https://link.springer.com/article/10.1057/palgrave.jam.2250084)
		/// 
		/// PortfolioAnalysisSharpe_ratioBias_adjustedPost portfolio/analysis/sharpe-ratio/bias-adjusted
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisSharpe_ratioBias_adjustedPostReturn> PortfolioAnalysisSharpe_ratioBias_adjustedPostAsync(PortfolioAnalysisSharpe_ratioBias_adjustedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/sharpe-ratio/bias-adjusted";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisSharpe_ratioBias_adjustedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sharpe Ratio Confidence Interval
		/// Build a confidence interval for the Sharpe ratio of one or several portfolio(s).
		/// 
		/// References
		/// * [Opdyke, J.D., Comparing Sharpe ratios: So where are the p-values?. J Asset Manag 8, 308–336 (2007)](https://link.springer.com/article/10.1057/palgrave.jam.2250084)
		/// 
		/// PortfolioAnalysisSharpe_ratioConfidence_intervalPost portfolio/analysis/sharpe-ratio/confidence-interval
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisSharpe_ratioConfidence_intervalPostReturn> PortfolioAnalysisSharpe_ratioConfidence_intervalPostAsync(PortfolioAnalysisSharpe_ratioConfidence_intervalPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/sharpe-ratio/confidence-interval";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisSharpe_ratioConfidence_intervalPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Probabilistic Sharpe Ratio
		/// Compute the probabilistic Sharpe ratio of one or several portfolio(s).
		/// 
		/// References
		/// * [Opdyke, J.D., Comparing Sharpe ratios: So where are the p-values?. J Asset Manag 8, 308–336 (2007)](https://link.springer.com/article/10.1057/palgrave.jam.2250084)
		/// * [Bailey, David H. and Lopez de Prado, Marcos, The Sharpe Ratio Efficient Frontier (April 1, 2012). Journal of Risk, Vol. 15, No. 2, Winter 2012/13](https://ssrn.com/abstract=1821643)
		/// 
		/// PortfolioAnalysisSharpe_ratioProbabilisticPost portfolio/analysis/sharpe-ratio/probabilistic
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisSharpe_ratioProbabilisticPostReturn> PortfolioAnalysisSharpe_ratioProbabilisticPostAsync(PortfolioAnalysisSharpe_ratioProbabilisticPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/sharpe-ratio/probabilistic";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisSharpe_ratioProbabilisticPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Minimum Track Record Length
		/// Compute the minimum track record length of one or several portfolio(s).
		/// 
		/// References
		/// * [Bailey, David H. and Lopez de Prado, Marcos, The Sharpe Ratio Efficient Frontier (April 1, 2012). Journal of Risk, Vol. 15, No. 2, Winter 2012/13](https://ssrn.com/abstract=1821643)
		/// 
		/// PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPost portfolio/analysis/sharpe-ratio/probabilistic/minimum-track-record-length
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostReturn> PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostAsync(PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/sharpe-ratio/probabilistic/minimum-track-record-length";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Tracking Error
		/// Compute the tracking error between a benchmark and one or several portfolio(s).
		/// 
		/// References
		/// * [Wikipedia, Tracking error](https://en.wikipedia.org/wiki/Tracking_error)
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// 
		/// PortfolioAnalysisTracking_errorPost portfolio/analysis/tracking-error
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisTracking_errorPostReturn> PortfolioAnalysisTracking_errorPostAsync(PortfolioAnalysisTracking_errorPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/tracking-error";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisTracking_errorPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Ulcer Index
		/// Compute the Ulcer Index of one or several portfolio(s).
		/// 
		/// References
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// * [Peter G. Martin, Ulcer Index, An Alternative Approach to the Measurement of Investment Risk & Risk-Adjusted Performance](http://www.tangotools.com/ui/ui.htm)
		/// 
		/// PortfolioAnalysisUlcer_indexPost portfolio/analysis/ulcer-index
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisUlcer_indexPostReturn> PortfolioAnalysisUlcer_indexPostAsync(PortfolioAnalysisUlcer_indexPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/ulcer-index";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisUlcer_indexPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Ulcer Performance Index
		/// Compute the Ulcer Performance Index of one or several portfolio(s).
		/// 
		/// References
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// * [Peter G. Martin, Ulcer Index, An Alternative Approach to the Measurement of Investment Risk & Risk-Adjusted Performance](http://www.tangotools.com/ui/ui.htm)
		/// 
		/// PortfolioAnalysisUlcer_performance_indexPost portfolio/analysis/ulcer-performance-index
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisUlcer_performance_indexPostReturn> PortfolioAnalysisUlcer_performance_indexPostAsync(PortfolioAnalysisUlcer_performance_indexPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/ulcer-performance-index";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisUlcer_performance_indexPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Cornish-Fisher Conditional Value At Risk
		/// Compute the Cornish-Fisher conditional value at risk of one or several portfolio(s) from portfolio values.
		/// 
		/// References
		/// * [Boudt, Kris and Peterson, Brian G. and Croux, Christophe, Estimation and Decomposition of Downside Risk for Portfolios with Non-Normal Returns (October 31, 2007). Journal of Risk, Vol. 11, No. 2, pp. 79-103, 2008](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1024151).
		/// * [Maillard, Didier, A User’s Guide to the Cornish Fisher Expansion](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1997178)
		/// * [Lamb, John D., Maura E. Monville, and Kai-Hong Tee. Making Cornish–fisher Fit for Risk Measurement, Journal of Risk, Volume 21, Number 5, p. 53-81](http://doi.org/10.21314/JOR.2019.408)
		/// 
		/// PortfolioAnalysisValue_at_riskConditionalCornish_fisherPost portfolio/analysis/value-at-risk/conditional/cornish-fisher
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostReturn> PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostAsync(PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/value-at-risk/conditional/cornish-fisher";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Corrected Cornish-Fisher Conditional Value At Risk
		/// Compute the corrected Cornish-Fisher conditional value at risk of one or several portfolio(s) from portfolio values.
		/// 
		/// References
		/// * [Maillard, Didier, A User’s Guide to the Cornish Fisher Expansion](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1997178)
		/// * [Lamb, John D., Maura E. Monville, and Kai-Hong Tee. Making Cornish–fisher Fit for Risk Measurement, Journal of Risk, Volume 21, Number 5, p. 53-81](http://doi.org/10.21314/JOR.2019.408)
		/// 
		/// PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPost portfolio/analysis/value-at-risk/conditional/cornish-fisher/corrected
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostReturn> PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostAsync(PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/value-at-risk/conditional/cornish-fisher/corrected";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gaussian Conditional Value At Risk
		/// Compute the Gaussian conditional value at risk of one or several portfolio(s) from portfolio values.
		/// 
		/// References
		/// * [Boudt, Kris and Peterson, Brian G. and Croux, Christophe, Estimation and Decomposition of Downside Risk for Portfolios with Non-Normal Returns (October 31, 2007). Journal of Risk, Vol. 11, No. 2, pp. 79-103, 2008](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1024151).
		/// 
		/// PortfolioAnalysisValue_at_riskConditionalGaussianPost portfolio/analysis/value-at-risk/conditional/gaussian
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisValue_at_riskConditionalGaussianPostReturn> PortfolioAnalysisValue_at_riskConditionalGaussianPostAsync(PortfolioAnalysisValue_at_riskConditionalGaussianPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/value-at-risk/conditional/gaussian";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisValue_at_riskConditionalGaussianPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Historical Conditional Value At Risk
		/// Compute the historical conditional value at risk of one or several portfolio(s) from portfolio values.
		/// 
		/// References
		/// * [Wikipedia, Value at risk](https://en.wikipedia.org/wiki/Value_at_risk)
		/// * [Acerbi, C. and Tasche, D. (2002), Expected Shortfall: A Natural Coherent Alternative to Value at Risk. Economic Notes, 31: 379-388](https://onlinelibrary.wiley.com/doi/abs/10.1111/1468-0300.00091)
		/// 
		/// PortfolioAnalysisValue_at_riskConditionalHistoricalPost portfolio/analysis/value-at-risk/conditional/historical
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisValue_at_riskConditionalHistoricalPostReturn> PortfolioAnalysisValue_at_riskConditionalHistoricalPostAsync(PortfolioAnalysisValue_at_riskConditionalHistoricalPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/value-at-risk/conditional/historical";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisValue_at_riskConditionalHistoricalPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Cornish-Fisher Value At Risk
		/// Compute the Cornish-Fisher value at risk of one or several portfolio(s) from portfolio values.
		/// 
		/// References
		/// * [Laurent Favre and José-Antonio Galeano, Mean-Modified Value-at-Risk Optimization with Hedge Funds, The Journal of Alternative Investments Fall 2002, 5 (2) 21-25](https://jai.pm-research.com/content/5/2/21)
		/// * [Lamb, John D., Maura E. Monville, and Kai-Hong Tee. Making Cornish–fisher Fit for Risk Measurement, Journal of Risk, Volume 21, Number 5, p. 53-81](http://doi.org/10.21314/JOR.2019.408)
		/// 
		/// PortfolioAnalysisValue_at_riskCornish_fisherPost portfolio/analysis/value-at-risk/cornish-fisher
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisValue_at_riskCornish_fisherPostReturn> PortfolioAnalysisValue_at_riskCornish_fisherPostAsync(PortfolioAnalysisValue_at_riskCornish_fisherPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/value-at-risk/cornish-fisher";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisValue_at_riskCornish_fisherPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Corrected Cornish-Fisher Value At Risk
		/// Compute the corrected Cornish-Fisher value at risk of one or several portfolio(s) from portfolio values.
		/// 
		/// References
		/// * [Lamb, John D., Maura E. Monville, and Kai-Hong Tee. Making Cornish–fisher Fit for Risk Measurement, Journal of Risk, Volume 21, Number 5, p. 53-81](http://doi.org/10.21314/JOR.2019.408)
		/// 
		/// PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPost portfolio/analysis/value-at-risk/cornish-fisher/corrected
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostReturn> PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostAsync(PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/value-at-risk/cornish-fisher/corrected";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gaussian Value At Risk
		/// Compute the Gaussian value at risk of one or several portfolio(s) from portfolio values.
		/// 
		/// References
		/// * [Ballotta, Laura and Fusai, Gianluca, A Gentle Introduction to Value at Risk](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2942138)
		/// 
		/// PortfolioAnalysisValue_at_riskGaussianPost portfolio/analysis/value-at-risk/gaussian
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisValue_at_riskGaussianPostReturn> PortfolioAnalysisValue_at_riskGaussianPostAsync(PortfolioAnalysisValue_at_riskGaussianPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/value-at-risk/gaussian";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisValue_at_riskGaussianPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Historical Value At Risk
		/// Compute the historical value at risk of one or several portfolio(s) from portfolio values.
		/// 
		/// References
		/// * [Wikipedia, Value at risk](https://en.wikipedia.org/wiki/Value_at_risk)
		/// * [Acerbi, C. and Tasche, D. (2002), Expected Shortfall: A Natural Coherent Alternative to Value at Risk. Economic Notes, 31: 379-388](https://onlinelibrary.wiley.com/doi/abs/10.1111/1468-0300.00091)
		/// 
		/// PortfolioAnalysisValue_at_riskHistoricalPost portfolio/analysis/value-at-risk/historical
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisValue_at_riskHistoricalPostReturn> PortfolioAnalysisValue_at_riskHistoricalPostAsync(PortfolioAnalysisValue_at_riskHistoricalPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/value-at-risk/historical";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisValue_at_riskHistoricalPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Volatility
		/// Compute the volatility (i.e., standard deviation) of one or several portfolio(s) from either:
		/// * Portfolio assets covariance matrix
		/// * Portfolio values
		/// 
		/// References
		/// * [Wikipedia, Standard Deviation](https://en.wikipedia.org/wiki/Standard_deviation#Finance)
		/// * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioAnalysisVolatilityPost portfolio/analysis/volatility
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioAnalysisVolatilityPostReturn> PortfolioAnalysisVolatilityPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/analysis/volatility";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioAnalysisVolatilityPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Investable Portfolio
		/// Compute an investable portfolio as close as possible, in terms of assets weights, to a desired portfolio, taking into account:
		/// * The desired assets weights
		/// * The desired assets groups weights
		/// * The desired maximum assets groups weights
		/// * The prices of the assets
		/// * The portfolio value
		/// * The requirement to purchase some assets by round lots or by odd lots
		/// * The possibility to purchase some assets by a fractional quantity of shares
		/// * The requirement to purchase a minimum number of shares, or a minimum monetary value, for some assets
		/// 
		/// References
		/// * [Steiner, Andreas, Accuracy and Rounding in Portfolio Construction](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2261131)
		/// 
		/// PortfolioConstructionInvestablePost portfolio/construction/investable
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioConstructionInvestablePostReturn> PortfolioConstructionInvestablePostAsync(PortfolioConstructionInvestablePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/construction/investable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioConstructionInvestablePostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Mimicking Portfolio
		/// Construct a portfolio as close as possible, in terms of returns, to a benchmark, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * Konstantinos Benidis, Yiyong Feng, Daniel P. Palomar, Optimization Methods for Financial Index Tracking: From Theory to Practice, now publishers Inc (7 juin 2018)
		/// 
		/// PortfolioConstructionMimickingPost portfolio/construction/mimicking
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioConstructionMimickingPostReturn> PortfolioConstructionMimickingPostAsync(PortfolioConstructionMimickingPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/construction/mimicking";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioConstructionMimickingPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Random Portfolio
		/// Construct one or several random portfolio(s), optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// > Because of the nature of the endpoint, subsequent calls with the same input data will result in different output data.
		/// 
		/// References
		/// * [William Thornton Shaw, Monte Carlo Portfolio Optimization for General Investor Risk-Return Objectives and Arbitrary Return Distributions: A Solution for Long-Only Portfolios](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1680224)
		/// 
		/// PortfolioConstructionRandomPost portfolio/construction/random
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioConstructionRandomPostReturn> PortfolioConstructionRandomPostAsync(PortfolioConstructionRandomPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/construction/random";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioConstructionRandomPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Equal Risk Contributions Portfolio
		/// Compute the asset weights of the equal risk contributions portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// 
		/// References
		/// * [Richard, Jean-Charles and Roncalli, Thierry, Constrained Risk Budgeting Portfolios: Theory, Algorithms, Applications & Puzzles](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3331184)
		/// 
		/// PortfolioOptimizationEqual_risk_contributionsPost portfolio/optimization/equal-risk-contributions
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationEqual_risk_contributionsPostReturn> PortfolioOptimizationEqual_risk_contributionsPostAsync(PortfolioOptimizationEqual_risk_contributionsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/equal-risk-contributions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationEqual_risk_contributionsPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Equal Sharpe Ratio Contributions Portfolio
		/// Compute the asset weights of the equal Sharpe Ratio contributions portfolio.
		/// 
		/// References
		/// * [Andreas Steiner, Sharpe Ratio Contribution and Attribution Analysis](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1839166")
		/// 
		/// PortfolioOptimizationEqual_sharpe_ratio_contributionsPost portfolio/optimization/equal-sharpe-ratio-contributions
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationEqual_sharpe_ratio_contributionsPostReturn> PortfolioOptimizationEqual_sharpe_ratio_contributionsPostAsync(PortfolioOptimizationEqual_sharpe_ratio_contributionsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/equal-sharpe-ratio-contributions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationEqual_sharpe_ratio_contributionsPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Equal Volatility Weighted Portfolio
		/// Compute the asset weights of the equal volatility-weighted portfolio.
		/// 
		/// References
		/// * [Tristan Froidure, Khalid Jalalzai and Yves Choueifaty, Portfolio Rho-Representativity, International Journal of Theoretical and Applied FinanceVol. 22, No. 07, 1950034 (2019)](https://www.worldscientific.com/doi/10.1142/S0219024919500341)
		/// 
		/// PortfolioOptimizationEqual_volatility_weightedPost portfolio/optimization/equal-volatility-weighted
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationEqual_volatility_weightedPostReturn> PortfolioOptimizationEqual_volatility_weightedPostAsync(PortfolioOptimizationEqual_volatility_weightedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/equal-volatility-weighted";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationEqual_volatility_weightedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Equal Weighted Portfolio
		/// Compute the asset weights of the equal-weighted portfolio.
		/// 
		/// References
		/// * [Victor DeMiguel and al., Optimal Versus Naive Diversification: How Inefficient is the 1/N Portfolio Strategy?](https://academic.oup.com/rfs/article-abstract/22/5/1915/1592901?redirectedFrom=fulltext)
		/// 
		/// PortfolioOptimizationEqual_weightedPost portfolio/optimization/equal-weighted
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationEqual_weightedPostReturn> PortfolioOptimizationEqual_weightedPostAsync(PortfolioOptimizationEqual_weightedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/equal-weighted";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationEqual_weightedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Hierarchical Risk Parity Portfolio
		/// Compute the asset weights of the hierarchical risk parity portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [Lopez de Prado, M. (2016). Building diversified portfolios that outperform out-of-sample. Journal of Portfolio Management, 42(4), 59–69](https://jpm.pm-research.com/content/42/4/59)
		/// * [Johann Pfitzinger & Nico Katzke, 2019. A constrained hierarchical risk parity algorithm with cluster-based capital allocation. Working Papers 14/2019, Stellenbosch University, Department of Economics](https://ideas.repec.org/p/sza/wpaper/wpapers328.html)
		/// 
		/// PortfolioOptimizationHierarchical_risk_parityPost portfolio/optimization/hierarchical-risk-parity
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationHierarchical_risk_parityPostReturn> PortfolioOptimizationHierarchical_risk_parityPostAsync(PortfolioOptimizationHierarchical_risk_parityPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/hierarchical-risk-parity";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationHierarchical_risk_parityPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Hierarchical Clustering-Based Risk Parity Portfolio
		/// Compute the asset weights of the hierarchical clustering-based risk parity portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [Machine Learning for Asset Management: New Developments and Financial Applications, Emmanuel Jurczenko, Chapter 9, Harald Lohre,Carsten Rother,Kilian Axel Schäfer, Hierarchical Risk Parity: Accounting for Tail Dependencies in Multi-asset Multi-factor Allocations](https://onlinelibrary.wiley.com/doi/10.1002/9781119751182.ch9)
		/// * [Thomas Raffinot, Hierarchical Clustering-Based Asset Allocation, The Journal of Portfolio Management Multi-Asset Special Issue 2018, 44 (2) 89-99](https://jpm.pm-research.com/content/44/2/89.abstract)
		/// * [Raffinot, Thomas, The Hierarchical Equal Risk Contribution Portfolio](https://ssrn.com/abstract=3237540)
		/// * [Johann Pfitzinger & Nico Katzke, 2019. A constrained hierarchical risk parity algorithm with cluster-based capital allocation. Working Papers 14/2019, Stellenbosch University, Department of Economics](https://ideas.repec.org/p/sza/wpaper/wpapers328.html)
		/// 
		/// PortfolioOptimizationHierarchical_risk_parityClustering_basedPost portfolio/optimization/hierarchical-risk-parity/clustering-based
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationHierarchical_risk_parityClustering_basedPostReturn> PortfolioOptimizationHierarchical_risk_parityClustering_basedPostAsync(PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/hierarchical-risk-parity/clustering-based";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationHierarchical_risk_parityClustering_basedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inverse Variance Weighted Portfolio
		/// Compute the asset weights of the inverse variance-weighted portfolio.
		/// 
		/// References
		/// * [Raul Leote de Carvalho and al., Demystifying Equity Risk-Based Strategies: A Simple Alpha Plus Beta Description](https://doi.org/10.3905/jpm.2012.38.3.056)
		/// 
		/// PortfolioOptimizationInverse_variance_weightedPost portfolio/optimization/inverse-variance-weighted
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationInverse_variance_weightedPostReturn> PortfolioOptimizationInverse_variance_weightedPostAsync(PortfolioOptimizationInverse_variance_weightedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/inverse-variance-weighted";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationInverse_variance_weightedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inverse Volatility Weighted Portfolio
		/// Compute the asset weights of the inverse volatility-weighted portfolio.
		/// 
		/// References
		/// * [Raul Leote de Carvalho and al., Demystifying Equity Risk-Based Strategies: A Simple Alpha Plus Beta Description](https://doi.org/10.3905/jpm.2012.38.3.056)
		/// 
		/// PortfolioOptimizationInverse_volatility_weightedPost portfolio/optimization/inverse-volatility-weighted
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationInverse_volatility_weightedPostReturn> PortfolioOptimizationInverse_volatility_weightedPostAsync(PortfolioOptimizationInverse_volatility_weightedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/inverse-volatility-weighted";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationInverse_volatility_weightedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Market Capitalization Weighted Portfolio
		/// Compute the asset weights of the market capitalization-weighted portfolio.
		/// 
		/// References
		/// * [Wikipedia, Capitalization-weighted Index](https://en.wikipedia.org/wiki/Capitalization-weighted_index)
		/// 
		/// PortfolioOptimizationMarket_capitalization_weightedPost portfolio/optimization/market-capitalization-weighted
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMarket_capitalization_weightedPostReturn> PortfolioOptimizationMarket_capitalization_weightedPostAsync(PortfolioOptimizationMarket_capitalization_weightedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/market-capitalization-weighted";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMarket_capitalization_weightedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Maximum Decorrelation Portfolio
		/// Compute the asset weights of the maximum decorrelation portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [F. Goltz, S. Sivasubramanian, Scientific Beta Maximum Decorrelation Indices](http://www.scientificbeta.com/download/file/scientific-beta-max-decorrelation-indices)
		/// 
		/// PortfolioOptimizationMaximum_decorrelationPost portfolio/optimization/maximum-decorrelation
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMaximum_decorrelationPostReturn> PortfolioOptimizationMaximum_decorrelationPostAsync(PortfolioOptimizationMaximum_decorrelationPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/maximum-decorrelation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMaximum_decorrelationPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Maximum Return Portfolio
		/// Compute the asset weights of the maximum return portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMaximum_returnPost portfolio/optimization/maximum-return
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMaximum_returnPostReturn> PortfolioOptimizationMaximum_returnPostAsync(PortfolioOptimizationMaximum_returnPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/maximum-return";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMaximum_returnPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Diversified Maximum Return Portfolio
		/// Compute the asset weights of the diversified maximum return portfolio, as defined in the first reference, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// The diversification measure used in the optimization procedure is the [Herfindahl-Hirschman Index](https://en.wikipedia.org/wiki/Herfindahl%E2%80%93Hirschman_index) of the assets weights.
		/// 
		/// References
		/// * [Alejandro Corvalan, 2005. Well Diversified Efficient Portfolios, Working Papers Central Bank of Chile 336, Central Bank of Chile](https://ideas.repec.org/p/chb/bcchwp/336.html)
		/// * [Bouchaud, Jean-Philippe and Potters, Marc and Aguilar, Jean-Pierre, Missing Information and Asset Allocation, arXiv, 1997](https://arxiv.org/abs/cond-mat/9707042)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMaximum_returnDiversifiedPost portfolio/optimization/maximum-return/diversified
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMaximum_returnDiversifiedPostReturn> PortfolioOptimizationMaximum_returnDiversifiedPostAsync(PortfolioOptimizationMaximum_returnDiversifiedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/maximum-return/diversified";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMaximum_returnDiversifiedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Subset Resampling-Based Maximum Return Portfolio
		/// Compute the asset weights of the subset resampling-based maximum return portfolio, following the methodology described in the first and the second references, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [CSSA, Random Subspace Optimization (RSO)](https://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/)
		/// * [Subset Optimization for Asset Allocation,Benjamin J. Gillen](https://www.bengillen.com/uploads/1/2/3/8/123891022/subsets.pdf)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMaximum_returnSubset_resampling_basedPost portfolio/optimization/maximum-return/subset-resampling-based
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMaximum_returnSubset_resampling_basedPostReturn> PortfolioOptimizationMaximum_returnSubset_resampling_basedPostAsync(PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/maximum-return/subset-resampling-based";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMaximum_returnSubset_resampling_basedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Maximum Sharpe Ratio Portfolio
		/// Compute the asset weights of the maximum Sharpe ratio portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMaximum_sharpe_ratioPost portfolio/optimization/maximum-sharpe-ratio
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMaximum_sharpe_ratioPostReturn> PortfolioOptimizationMaximum_sharpe_ratioPostAsync(PortfolioOptimizationMaximum_sharpe_ratioPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/maximum-sharpe-ratio";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMaximum_sharpe_ratioPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Diversified Maximum Sharpe Ratio Portfolio
		/// Compute the asset weights of the diversified maximum Sharpe ratio portfolio, as defined in the first reference, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// The diversification measure used in the optimization procedure is the [Herfindahl-Hirschman Index](https://en.wikipedia.org/wiki/Herfindahl%E2%80%93Hirschman_index) of the assets weights.
		/// 
		/// References
		/// * [Alejandro Corvalan, 2005. Well Diversified Efficient Portfolios, Working Papers Central Bank of Chile 336, Central Bank of Chile](https://ideas.repec.org/p/chb/bcchwp/336.html)
		/// * [Bouchaud, Jean-Philippe and Potters, Marc and Aguilar, Jean-Pierre, Missing Information and Asset Allocation, arXiv, 1997](https://arxiv.org/abs/cond-mat/9707042)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPost portfolio/optimization/maximum-sharpe-ratio/diversified
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPostReturn> PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPostAsync(PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/maximum-sharpe-ratio/diversified";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Subset Resampling-Based Maximum Sharpe Ratio Portfolio
		/// Compute the asset weights of the susbet resampling-based maximum Sharpe ratio portfolio, following the methodology described in the first and the second references, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [CSSA, Random Subspace Optimization (RSO)](https://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/)
		/// * [Subset Optimization for Asset Allocation,Benjamin J. Gillen](https://www.bengillen.com/uploads/1/2/3/8/123891022/subsets.pdf)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPost portfolio/optimization/maximum-sharpe-ratio/subset-resampling-based
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPostReturn> PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPostAsync(PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/maximum-sharpe-ratio/subset-resampling-based";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Maximum Ulcer Performance Index Portfolio
		/// Compute the asset weights of the maximum Ulcer Performance Index portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// Notes:
		/// * This endpoint will return an error if the maximum Ulcer Performance Index portfolio has a negative Ulcer Performance Index
		/// 
		/// References
		/// * [Peter G. Martin, Ulcer Index, An Alternative Approach to the Measurement of Investment Risk & Risk-Adjusted Performance](http://www.tangotools.com/ui/ui.htm)
		/// * [A. Chekhlov, S. Uryasev, M. Zabarankin, Portfolio Optimization with Drawdown Constraints, Supply Chain and Finance, p 209-228](https://doi.org/10.1142/9789812562586_0013)
		/// * [A. Chekhlov, S. Uryasev, M. Zabarankin, Drawdown Measure in Portfolio Optimization, International Journal of Theoretical and Applied FinanceVol. 08, No. 01, pp. 13-58 (2005)](https://www.worldscientific.com/doi/10.1142/S0219024905002767)
		/// 
		/// PortfolioOptimizationMaximum_ulcer_performance_indexPost portfolio/optimization/maximum-ulcer-performance-index
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMaximum_ulcer_performance_indexPostReturn> PortfolioOptimizationMaximum_ulcer_performance_indexPostAsync(PortfolioOptimizationMaximum_ulcer_performance_indexPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/maximum-ulcer-performance-index";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMaximum_ulcer_performance_indexPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Mean-Variance Efficient Portfolio
		/// Compute the asset weights of a mean-variance efficient portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// > A mean-variance efficient portfolio is a portfolio belonging to [the mean-variance efficient frontier](#post-/portfolio/analysis/mean-variance/efficient-frontier).
		/// 
		/// References
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMean_variance_efficientPost portfolio/optimization/mean-variance-efficient
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMean_variance_efficientPostReturn> PortfolioOptimizationMean_variance_efficientPostAsync(PortfolioOptimizationMean_variance_efficientPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/mean-variance-efficient";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMean_variance_efficientPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Diversified Mean-Variance Efficient Portfolio
		/// Compute the asset weights of a diversified mean-variance efficient portfolio, as defined in the first reference, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// The diversification measure used in the optimization procedure is the [Herfindahl-Hirschman Index](https://en.wikipedia.org/wiki/Herfindahl%E2%80%93Hirschman_index) of the assets weights.
		/// 
		/// > A diversified mean-variance efficient portfolio does NOT belong to [the mean-variance efficient frontier](#post-/portfolio/analysis/mean-variance/efficient-frontier), but is close to this frontier.
		/// 
		/// References
		/// * [Alejandro Corvalan, 2005. Well Diversified Efficient Portfolios, Working Papers Central Bank of Chile 336, Central Bank of Chile](https://ideas.repec.org/p/chb/bcchwp/336.html)
		/// * [Bouchaud, Jean-Philippe and Potters, Marc and Aguilar, Jean-Pierre, Missing Information and Asset Allocation, arXiv, 1997](https://arxiv.org/abs/cond-mat/9707042)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMean_variance_efficientDiversifiedPost portfolio/optimization/mean-variance-efficient/diversified
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMean_variance_efficientDiversifiedPostReturn> PortfolioOptimizationMean_variance_efficientDiversifiedPostAsync(PortfolioOptimizationMean_variance_efficientDiversifiedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/mean-variance-efficient/diversified";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMean_variance_efficientDiversifiedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Subset Resampling-Based Mean-Variance Efficient Portfolio
		/// Compute the asset weights of a subset resampling-based  mean-variance efficient portfolio, following the methodology described in the first and the second references, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [CSSA, Random Subspace Optimization (RSO)](https://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/)
		/// * [Subset Optimization for Asset Allocation,Benjamin J. Gillen](https://www.bengillen.com/uploads/1/2/3/8/123891022/subsets.pdf)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPost portfolio/optimization/mean-variance-efficient/subset-resampling-based
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPostReturn> PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPostAsync(PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/mean-variance-efficient/subset-resampling-based";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Minimum Correlation Portfolio
		/// Compute the asset weights of the (heuristic) minimum correlation portfolio, which is a portfolio built using the Minimum Correlation Algorithm discovered by [David Varadi](https://cssanalytics.wordpress.com/).
		/// 
		/// References
		/// * [CSSA, Minimum Correlation Algorithm Paper Release](https://cssanalytics.wordpress.com/2012/09/21/minimum-correlation-algorithm-paper-release/)
		/// 
		/// PortfolioOptimizationMinimum_correlationPost portfolio/optimization/minimum-correlation
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMinimum_correlationPostReturn> PortfolioOptimizationMinimum_correlationPostAsync(PortfolioOptimizationMinimum_correlationPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/minimum-correlation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMinimum_correlationPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Minimum Ulcer Index Portfolio
		/// Compute the asset weights of the minimum Ulcer Index portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [Peter G. Martin, Ulcer Index, An Alternative Approach to the Measurement of Investment Risk & Risk-Adjusted Performance](http://www.tangotools.com/ui/ui.htm)
		/// * [A. Chekhlov, S. Uryasev, M. Zabarankin, Portfolio Optimization with Drawdown Constraints, Supply Chain and Finance, p 209-228](https://doi.org/10.1142/9789812562586_0013)
		/// * [A. Chekhlov, S. Uryasev, M. Zabarankin, Drawdown Measure in Portfolio Optimization, International Journal of Theoretical and Applied FinanceVol. 08, No. 01, pp. 13-58 (2005)](https://www.worldscientific.com/doi/10.1142/S0219024905002767)
		/// 
		/// PortfolioOptimizationMinimum_ulcer_indexPost portfolio/optimization/minimum-ulcer-index
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMinimum_ulcer_indexPostReturn> PortfolioOptimizationMinimum_ulcer_indexPostAsync(PortfolioOptimizationMinimum_ulcer_indexPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/minimum-ulcer-index";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMinimum_ulcer_indexPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Minimum Variance Portfolio
		/// Compute the asset weights of the minimum variance portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMinimum_variancePost portfolio/optimization/minimum-variance
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMinimum_variancePostReturn> PortfolioOptimizationMinimum_variancePostAsync(PortfolioOptimizationMinimum_variancePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/minimum-variance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMinimum_variancePostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Diversified Minimum Variance Portfolio
		/// Compute the asset weights of the diversified minimum variance portfolio, as defined in the first reference, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// The diversification measure used in the optimization procedure is the [Herfindahl-Hirschman Index](https://en.wikipedia.org/wiki/Herfindahl%E2%80%93Hirschman_index) of the assets weights.
		/// 
		/// References
		/// * [Alejandro Corvalan, 2005. Well Diversified Efficient Portfolios, Working Papers Central Bank of Chile 336, Central Bank of Chile](https://ideas.repec.org/p/chb/bcchwp/336.html)
		/// * [Bouchaud, Jean-Philippe and Potters, Marc and Aguilar, Jean-Pierre, Missing Information and Asset Allocation, arXiv, 1997](https://arxiv.org/abs/cond-mat/9707042)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMinimum_varianceDiversifiedPost portfolio/optimization/minimum-variance/diversified
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMinimum_varianceDiversifiedPostReturn> PortfolioOptimizationMinimum_varianceDiversifiedPostAsync(PortfolioOptimizationMinimum_varianceDiversifiedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/minimum-variance/diversified";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMinimum_varianceDiversifiedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Subset Resampling-Based Minimum Variance Portfolio
		/// Compute the asset weights of the subset resampling-based minimum variance portfolio, following the methodology described in the first and the second references, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [CSSA, Random Subspace Optimization (RSO)](https://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/)
		/// * [Subset Optimization for Asset Allocation,Benjamin J. Gillen](https://www.bengillen.com/uploads/1/2/3/8/123891022/subsets.pdf)
		/// * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
		/// 
		/// PortfolioOptimizationMinimum_varianceSubset_resampling_basedPost portfolio/optimization/minimum-variance/subset-resampling-based
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMinimum_varianceSubset_resampling_basedPostReturn> PortfolioOptimizationMinimum_varianceSubset_resampling_basedPostAsync(PortfolioOptimizationMinimum_varianceSubset_resampling_basedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/minimum-variance/subset-resampling-based";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMinimum_varianceSubset_resampling_basedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Most Diversified Portfolio
		/// Compute the asset weights of the most diversified portfolio, optionally subject to:
		/// * Minimum and maximum weights constraints
		/// * Maximum group weights constraints
		/// * Minimum and maximum portfolio exposure constraints
		/// 
		/// References
		/// * [Yves Choueifaty and Yves Coignard, Toward Maximum Diversification, The Journal of Portfolio Management Fall 2008, 35 (1) 40-51](https://doi.org/10.3905/JPM.2008.35.1.40)
		/// 
		/// PortfolioOptimizationMost_diversifiedPost portfolio/optimization/most-diversified
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioOptimizationMost_diversifiedPostReturn> PortfolioOptimizationMost_diversifiedPostAsync(PortfolioOptimizationMost_diversifiedPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/optimization/most-diversified";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioOptimizationMost_diversifiedPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Drift-weight Portfolio Rebalancing
		/// Simulate the evolution of one or several portfolio(s) over one or several time period(s), the portfolio(s) being never rebalanced (a.k.a. buy and hold).
		/// 
		/// References
		/// * [Hillion, Pierre, The Ex-Ante Rebalancing Premium (March 11, 2016). INSEAD Working Paper No. 2016/15/FIN](https://ssrn.com/abstract=2746471)
		/// 
		/// PortfolioSimulationRebalancingDrift_weightPost portfolio/simulation/rebalancing/drift-weight
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioSimulationRebalancingDrift_weightPostReturn> PortfolioSimulationRebalancingDrift_weightPostAsync(PortfolioSimulationRebalancingDrift_weightPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/simulation/rebalancing/drift-weight";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioSimulationRebalancingDrift_weightPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Fixed-weight Portfolio Rebalancing
		/// Simulate the evolution of one or several portfolio(s) over one or several time period(s), the portfolio(s) being rebalanced toward fixed weights at the beginning of each time period.
		/// 
		/// References
		/// * [Hillion, Pierre, The Ex-Ante Rebalancing Premium (March 11, 2016). INSEAD Working Paper No. 2016/15/FIN](https://ssrn.com/abstract=2746471)
		/// 
		/// PortfolioSimulationRebalancingFixed_weightPost portfolio/simulation/rebalancing/fixed-weight
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioSimulationRebalancingFixed_weightPostReturn> PortfolioSimulationRebalancingFixed_weightPostAsync(PortfolioSimulationRebalancingFixed_weightPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/simulation/rebalancing/fixed-weight";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioSimulationRebalancingFixed_weightPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Random-weight Portfolio Rebalancing
		/// Simulate the evolution of one or several portfolio(s) over one or several time period(s), the portfolio(s) being rebalanced toward random weights at the beginning of each time period.
		/// 
		/// References
		/// * [R Stein, Not fooled by randomness: Using random portfolios to analyse investment funds, Investment Analysts Journal, 43:79, 1-15, DOI: 10.1080/10293523.2014.11082564](https://www.tandfonline.com/doi/abs/10.1080/10293523.2014.11082564)
		/// 
		/// PortfolioSimulationRebalancingRandom_weightPost portfolio/simulation/rebalancing/random-weight
		/// </summary>
		/// <returns>OK</returns>
		public async Task<PortfolioSimulationRebalancingRandom_weightPostReturn> PortfolioSimulationRebalancingRandom_weightPostAsync(PortfolioSimulationRebalancingRandom_weightPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "portfolio/simulation/rebalancing/random-weight";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PortfolioSimulationRebalancingRandom_weightPostReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public class AssetsAnalysisAbsorption_ratioPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrixEigenvectors")]
		public AssetsAnalysisAbsorption_ratioPostPostBodyAssetsCovarianceMatrixEigenvectors AssetsCovarianceMatrixEigenvectors { get; set; }
	}
	
	public class AssetsAnalysisAbsorption_ratioPostPostBodyAssetsCovarianceMatrixEigenvectors
	{
		
		/// <summary>
		/// The number of eigenvectors to retain in the numerator of the absorption ratio, which must be lower than the number of assets; defaults to [1/5-th] the number of assets
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eigenvectorsRetained")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> EigenvectorsRetained { get; set; }
	}
	
	public class AssetsAnalysisAbsorption_ratioPostReturn
	{
		
		/// <summary>
		/// The absorption ratio of the universe of assets
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsAbsorptionRatio")]
		public double AssetsAbsorptionRatio { get; set; }
	}
	
	public class AssetsAnalysisTurbulence_indexPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsAverageReturns[i] is the average return of asset i over an historical reference period
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsAverageReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsAverageReturns { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j over an historical reference period
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the return of asset i over a period different from the historical reference period
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
	}
	
	public class AssetsAnalysisTurbulence_indexPostReturn
	{
		
		/// <summary>
		/// the turbulence index of the universe of assets
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsTurbulenceIndex")]
		public double AssetsTurbulenceIndex { get; set; }
	}
	
	public class AssetsCorrelationMatrixPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public AssetsCorrelationMatrixPostPostBodyAssets[] AssetsCorrelationMatrixPostPostBodyAssets { get; set; }
	}
	
	public class AssetsCorrelationMatrixPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t; all the assetReturns arrays must have the same length
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsCorrelationMatrixPostReturn
	{
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
	}
	
	public class AssetsCorrelationMatrixBoundsPostReturn
	{
		
		/// <summary>
		/// assetsCorrelationMatrixLowerBounds[i][j] is the lower bound of the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrixLowerBounds")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrixLowerBounds { get; set; }
		
		/// <summary>
		/// assetsCorrelationMatrixUpperBounds[i][j] is the upper bound of the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrixUpperBounds")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrixUpperBounds { get; set; }
	}
	
	public class AssetsCorrelationMatrixDenoisedPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
		
		/// <summary>
		/// The aspect ratio of the asset correlation matrix, defined as the number of assets divided by the number of asset returns per asset used to compute the asset correlation matrix
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrixAspectRatio")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AssetsCorrelationMatrixAspectRatio { get; set; }
		
		/// <summary>
		/// The method used to denoise the asset correlation matrix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="denoisingMethod")]
		public System.Nullable<AssetsCorrelationMatrixDenoisedPostPostBodyDenoisingMethod> DenoisingMethod { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetsCorrelationMatrixDenoisedPostPostBodyDenoisingMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="eigenvaluesClipping")]
		eigenvaluesClipping = 0,
	}
	
	public class AssetsCorrelationMatrixDenoisedPostReturn
	{
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j; assetsCorrelationMatrix is possibly null in case the denoising method did not manage to denoise the provided asset correlation matrix
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
	}
	
	public class AssetsCorrelationMatrixDistancePostReturn
	{
		
		/// <summary>
		/// The computed distance between the two correlation matrices
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrixDistance")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AssetsCorrelationMatrixDistance { get; set; }
	}
	
	public class AssetsCorrelationMatrixEffective_rankPostReturn
	{
		
		/// <summary>
		/// The effective rank of the asset correlation matrix
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrixEffectiveRank")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrixEffectiveRank { get; set; }
	}
	
	public class AssetsCorrelationMatrixInformativenessPostReturn
	{
		
		/// <summary>
		/// The informativeness of the asset correlation matrix
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrixInformativeness")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AssetsCorrelationMatrixInformativeness { get; set; }
	}
	
	public class AssetsCorrelationMatrixNearestPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsApproximateCorrelationMatrix[i][i] is the approximate correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsApproximateCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsApproximateCorrelationMatrix { get; set; }
		
		/// <summary>
		/// assetsFixedCorrelations[k] is the couple of indices (i,j) of the assets i and j for which to keep the approximate correlation assetsApproximateCorrelationMatrix[i][j] fixed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsFixedCorrelations")]
		public string[] AssetsFixedCorrelations { get; set; }
	}
	
	public class AssetsCorrelationMatrixNearestPostReturn
	{
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
	}
	
	public class AssetsCorrelationMatrixRandomPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
	}
	
	public class AssetsCorrelationMatrixRandomPostReturn
	{
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
	}
	
	public class AssetsCorrelationMatrixShrinkagePostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
		
		/// <summary>
		/// The shrinkage factor
		/// Required
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shrinkageFactor")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public double ShrinkageFactor { get; set; }
		
		/// <summary>
		/// The shrinkage target correlation matrix
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetEquicorrelationMatrix")]
		public AssetsCorrelationMatrixShrinkagePostPostBodyTargetEquicorrelationMatrix TargetEquicorrelationMatrix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetsCorrelationMatrixShrinkagePostPostBodyTargetEquicorrelationMatrix
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="minimumEquicorrelationMatrix")]
		minimumEquicorrelationMatrix = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zeroEquicorrelationMatrix")]
		zeroEquicorrelationMatrix = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="maximumEquicorrelationMatrix")]
		maximumEquicorrelationMatrix = 2,
	}
	
	public class AssetsCorrelationMatrixShrinkagePostReturn
	{
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
	}
	
	public class AssetsCorrelationMatrixTheory_impliedPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public AssetsCorrelationMatrixTheory_impliedPostPostBodyAssets[] AssetsCorrelationMatrixTheory_impliedPostPostBodyAssets { get; set; }
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
		
		/// <summary>
		/// The hierarchical clustering method to use
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusteringMethod")]
		public System.Nullable<AssetsCorrelationMatrixTheory_impliedPostPostBodyClusteringMethod> ClusteringMethod { get; set; }
	}
	
	public class AssetsCorrelationMatrixTheory_impliedPostPostBodyAssets
	{
		
		/// <summary>
		/// assetHierarchicalClassification[i] is the i+1-th level of the hierarchical classification of the asset, from the most generic classification to the most specific classification; all the assetHierarchicalClassification arrays must have the same length
		/// Required
		/// Minimum items: 1
		/// Maximum items: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetHierarchicalClassification")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(4)]
		public string[] AssetHierarchicalClassification { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetsCorrelationMatrixTheory_impliedPostPostBodyClusteringMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="singleLinkage")]
		singleLinkage = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="averageLinkage")]
		averageLinkage = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="completeLinkage")]
		completeLinkage = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="wardLinkage")]
		wardLinkage = 3,
	}
	
	public class AssetsCorrelationMatrixTheory_impliedPostReturn
	{
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
	}
	
	public class AssetsCorrelationMatrixValidationPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
	}
	
	public class AssetsCorrelationMatrixValidationPostReturn
	{
		
		/// <summary>
		/// Indicates whether the matrix is a valid correlation matrix
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public AssetsCorrelationMatrixValidationPostReturnMessage Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetsCorrelationMatrixValidationPostReturnMessage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="valid correlation matrix")]
		valid_correlation_matrix = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="invalid correlation matrix - non symmetric matrix")]
		invalid_correlation_matrix_Minus_non_symmetric_matrix = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="invalid correlation matrix - non positive diagonal elements")]
		invalid_correlation_matrix_Minus_non_positive_diagonal_elements = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="invalid correlation matrix - non positive semi-definite matrix")]
		invalid_correlation_matrix_Minus_non_positive_semiMinusdefinite_matrix = 3,
	}
	
	public class AssetsCovarianceMatrixPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public AssetsCovarianceMatrixPostPostBodyAssets[] AssetsCovarianceMatrixPostPostBodyAssets { get; set; }
	}
	
	public class AssetsCovarianceMatrixPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t; all the assetReturns arrays must have the same length
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsCovarianceMatrixPostReturn
	{
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
	}
	
	public class AssetsCovarianceMatrixEffective_rankPostReturn
	{
		
		/// <summary>
		/// The effective rank of the asset covariance matrix
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrixEffectiveRank")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrixEffectiveRank { get; set; }
	}
	
	public class AssetsCovarianceMatrixExponentially_weightedPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public AssetsCovarianceMatrixExponentially_weightedPostPostBodyAssets[] AssetsCovarianceMatrixExponentially_weightedPostPostBodyAssets { get; set; }
		
		/// <summary>
		/// The exponential decay factor
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="decayFactor")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> DecayFactor { get; set; }
	}
	
	public class AssetsCovarianceMatrixExponentially_weightedPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t; all the assetReturns arrays must have the same length
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsCovarianceMatrixExponentially_weightedPostReturn
	{
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the sample covariance between the asset i returns and the asset j returns
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
	}
	
	public class AssetsCovarianceMatrixValidationPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
	}
	
	public class AssetsCovarianceMatrixValidationPostReturn
	{
		
		/// <summary>
		/// Indicates whether the matrix is a valid covariance matrix
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public AssetsCovarianceMatrixValidationPostReturnMessage Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetsCovarianceMatrixValidationPostReturnMessage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="valid covariance matrix")]
		valid_covariance_matrix = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="invalid covariance matrix - non symmetric matrix")]
		invalid_covariance_matrix_Minus_non_symmetric_matrix = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="invalid covariance matrix - non positive diagonal elements")]
		invalid_covariance_matrix_Minus_non_positive_diagonal_elements = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="invalid covariance matrix - non positive semi-definite matrix")]
		invalid_covariance_matrix_Minus_non_positive_semiMinusdefinite_matrix = 3,
	}
	
	public class AssetsKurtosisPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsKurtosisPostPostBodyAssets[] AssetsKurtosisPostPostBodyAssets { get; set; }
	}
	
	public class AssetsKurtosisPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t
		/// Required
		/// Minimum items: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(4)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsKurtosisPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsKurtosisPostReturnAssets[] AssetsKurtosisPostReturnAssets { get; set; }
	}
	
	public class AssetsKurtosisPostReturnAssets
	{
		
		/// <summary>
		/// The kurtosis of the asset
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetKurtosis")]
		public double AssetKurtosis { get; set; }
	}
	
	public class AssetsPricesAdjustedPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsPricesAdjustedPostPostBodyAssets[] AssetsPricesAdjustedPostPostBodyAssets { get; set; }
	}
	
	public class AssetsPricesAdjustedPostPostBodyAssets
	{
		
		/// <summary>
		/// assetDividends[t] contains dividend information for the asset at the date t
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetDividends")]
		public AssetsPricesAdjustedPostPostBodyAssetsAssetDividends[] AssetsPricesAdjustedPostPostBodyAssetsAssetDividends { get; set; }
		
		/// <summary>
		/// assetPrices[t] contains price information for the asset at the date t
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsPricesAdjustedPostPostBodyAssetsAssetPrices[] AssetsPricesAdjustedPostPostBodyAssetsAssetPrices { get; set; }
		
		/// <summary>
		/// assetSplits[t] contains split information for the asset at the date t
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetSplits")]
		public AssetsPricesAdjustedPostPostBodyAssetsAssetSplits[] AssetsPricesAdjustedPostPostBodyAssetsAssetSplits { get; set; }
	}
	
	public class AssetsPricesAdjustedPostPostBodyAssetsAssetDividends
	{
		
		/// <summary>
		/// The dividend amount distributed by the asset at the date t
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="amount")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double Amount { get; set; }
		
		/// <summary>
		/// The date corresponding to the date t in format YYYY-MM-DD, which is usually the ex-distribution date
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
	}
	
	public class AssetsPricesAdjustedPostPostBodyAssetsAssetPrices
	{
		
		/// <summary>
		/// The unadjusted close price of the asset at the date t
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="close")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double Close { get; set; }
		
		/// <summary>
		/// The date corresponding to the date t in format YYYY-MM-DD
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
	}
	
	public class AssetsPricesAdjustedPostPostBodyAssetsAssetSplits
	{
		
		/// <summary>
		/// The date corresponding to the date t in format YYYY-MM-DD, which is usually the ex-distribution date
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		/// <summary>
		/// The split factor of the asset at the date t
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="factor")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double Factor { get; set; }
	}
	
	public class AssetsPricesAdjustedPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsPricesAdjustedPostReturnAssets[] AssetsPricesAdjustedPostReturnAssets { get; set; }
	}
	
	public class AssetsPricesAdjustedPostReturnAssets
	{
		
		/// <summary>
		/// assetAdjustedPrices[t] contains adjusted price information for the asset at the date t
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetAdjustedPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsPricesAdjustedPostReturnAssetsAssetAdjustedPrices[] AssetsPricesAdjustedPostReturnAssetsAssetAdjustedPrices { get; set; }
	}
	
	public class AssetsPricesAdjustedPostReturnAssetsAssetAdjustedPrices
	{
		
		/// <summary>
		/// The date corresponding to the date t in format YYYY-MM-DD
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		/// <summary>
		/// The dividend(s) adjusted close price of the asset at the date t, only present if dividend(s) information are provided
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dividendAdjustedClose")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DividendAdjustedClose { get; set; }
		
		/// <summary>
		/// The dividend(s) and split(s) adjusted close price of the asset at the date t
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fullyAdjustedClose")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double FullyAdjustedClose { get; set; }
		
		/// <summary>
		/// The split(s) adjusted close price of the asset at the date t, only present if split(s) information are provided
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splitAdjustedClose")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> SplitAdjustedClose { get; set; }
	}
	
	public class AssetsPricesAdjustedForwardPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsPricesAdjustedForwardPostPostBodyAssets[] AssetsPricesAdjustedForwardPostPostBodyAssets { get; set; }
	}
	
	public class AssetsPricesAdjustedForwardPostPostBodyAssets
	{
		
		/// <summary>
		/// assetDividends[t] contains dividend information for the asset at the date t
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetDividends")]
		public AssetsPricesAdjustedForwardPostPostBodyAssetsAssetDividends[] AssetsPricesAdjustedForwardPostPostBodyAssetsAssetDividends { get; set; }
		
		/// <summary>
		/// assetPrices[t] contains price information for the asset at the date t
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsPricesAdjustedForwardPostPostBodyAssetsAssetPrices[] AssetsPricesAdjustedForwardPostPostBodyAssetsAssetPrices { get; set; }
		
		/// <summary>
		/// assetSplits[t] contains split information for the asset at the date t
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetSplits")]
		public AssetsPricesAdjustedForwardPostPostBodyAssetsAssetSplits[] AssetsPricesAdjustedForwardPostPostBodyAssetsAssetSplits { get; set; }
	}
	
	public class AssetsPricesAdjustedForwardPostPostBodyAssetsAssetDividends
	{
		
		/// <summary>
		/// The dividend amount distributed by the asset at the date t
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="amount")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double Amount { get; set; }
		
		/// <summary>
		/// The date corresponding to the date t in format YYYY-MM-DD, which is usually the ex-distribution date
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
	}
	
	public class AssetsPricesAdjustedForwardPostPostBodyAssetsAssetPrices
	{
		
		/// <summary>
		/// The unadjusted close price of the asset at the date t
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="close")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double Close { get; set; }
		
		/// <summary>
		/// The date corresponding to the date t in format YYYY-MM-DD
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
	}
	
	public class AssetsPricesAdjustedForwardPostPostBodyAssetsAssetSplits
	{
		
		/// <summary>
		/// The date corresponding to the date t in format YYYY-MM-DD, which is usually the ex-distribution date
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		/// <summary>
		/// The split factor of the asset at the date t
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="factor")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double Factor { get; set; }
	}
	
	public class AssetsPricesAdjustedForwardPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsPricesAdjustedForwardPostReturnAssets[] AssetsPricesAdjustedForwardPostReturnAssets { get; set; }
	}
	
	public class AssetsPricesAdjustedForwardPostReturnAssets
	{
		
		/// <summary>
		/// assetAdjustedPrices[t] contains adjusted price information for the asset at the date t
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetAdjustedPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsPricesAdjustedForwardPostReturnAssetsAssetAdjustedPrices[] AssetsPricesAdjustedForwardPostReturnAssetsAssetAdjustedPrices { get; set; }
	}
	
	public class AssetsPricesAdjustedForwardPostReturnAssetsAssetAdjustedPrices
	{
		
		/// <summary>
		/// The date corresponding to the date t in format YYYY-MM-DD
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		/// <summary>
		/// The dividend(s) adjusted close price of the asset at the date t, only present if dividend(s) information are provided
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dividendAdjustedClose")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DividendAdjustedClose { get; set; }
		
		/// <summary>
		/// The dividend(s) and split(s) adjusted close price of the asset at the date t
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fullyAdjustedClose")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double FullyAdjustedClose { get; set; }
		
		/// <summary>
		/// The split(s) adjusted close price of the asset at the date t, only present if split(s) information are provided
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splitAdjustedClose")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> SplitAdjustedClose { get; set; }
	}
	
	public class AssetsReturnsPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsReturnsPostPostBodyAssets[] AssetsReturnsPostPostBodyAssets { get; set; }
	}
	
	public class AssetsReturnsPostPostBodyAssets
	{
		
		/// <summary>
		/// assetPrices[t] is the price of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetPrices { get; set; }
	}
	
	public class AssetsReturnsPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsReturnsPostReturnAssets[] AssetsReturnsPostReturnAssets { get; set; }
	}
	
	public class AssetsReturnsPostReturnAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the arithmetic return of the asset from the time t-1 to the time t, in percentage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsReturnsAveragePostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsReturnsAveragePostPostBodyAssets[] AssetsReturnsAveragePostPostBodyAssets { get; set; }
	}
	
	public class AssetsReturnsAveragePostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsReturnsAveragePostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsReturnsAveragePostReturnAssets[] AssetsReturnsAveragePostReturnAssets { get; set; }
	}
	
	public class AssetsReturnsAveragePostReturnAssets
	{
		
		/// <summary>
		/// The arithmetic average return of the asset
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetAverageReturn")]
		public double AssetAverageReturn { get; set; }
	}
	
	public class AssetsReturnsLogarithmicPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsReturnsLogarithmicPostPostBodyAssets[] AssetsReturnsLogarithmicPostPostBodyAssets { get; set; }
	}
	
	public class AssetsReturnsLogarithmicPostPostBodyAssets
	{
		
		/// <summary>
		/// assetPrices[t] is the price of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetPrices { get; set; }
	}
	
	public class AssetsReturnsLogarithmicPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsReturnsLogarithmicPostReturnAssets[] AssetsReturnsLogarithmicPostReturnAssets { get; set; }
	}
	
	public class AssetsReturnsLogarithmicPostReturnAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the logarithmic return of the asset from the time t-1 to the time t, in percentage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsReturnsSimulationBootstrapPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public AssetsReturnsSimulationBootstrapPostPostBodyAssets[] AssetsReturnsSimulationBootstrapPostPostBodyAssets { get; set; }
		
		/// <summary>
		/// The average length of the blocks to use in case the bootstrap method is 'stationaryBlock', in time periods; if not provided, defaults to the inverse of 3.15 * the common length of the assetReturns arrays^1/3
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootstrapAverageBlockLength")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Double.MaxValue)]
		public System.Nullable<System.Double> BootstrapAverageBlockLength { get; set; }
		
		/// <summary>
		/// The length of the blocks to use in case the bootstrap method is 'circularBlock', in time periods; if not provided, defaults to [3.15 * the common length of the assetReturns arrays^1/3]
		/// Minimum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootstrapBlockLength")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> BootstrapBlockLength { get; set; }
		
		/// <summary>
		/// The bootstrap method to use
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootstrapMethod")]
		public System.Nullable<AssetsReturnsSimulationBootstrapPostPostBodyBootstrapMethod> BootstrapMethod { get; set; }
		
		/// <summary>
		/// The number of simulations to perform
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simulations")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Simulations { get; set; }
		
		/// <summary>
		/// The number of time period(s) to simulate per simulation; if not provided, defaults to the common length of the assetReturns arrays
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simulationsLength")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SimulationsLength { get; set; }
	}
	
	public class AssetsReturnsSimulationBootstrapPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset over the time period t; all the assetReturns arrays must have the same length
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetReturns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetsReturnsSimulationBootstrapPostPostBodyBootstrapMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="iid")]
		iid = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="circularBlock")]
		circularBlock = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="stationaryBlock")]
		stationaryBlock = 2,
	}
	
	public class AssetsReturnsSimulationBootstrapPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="simulations")]
		public AssetsReturnsSimulationBootstrapPostReturnSimulations[] AssetsReturnsSimulationBootstrapPostReturnSimulations { get; set; }
	}
	
	public class AssetsReturnsSimulationBootstrapPostReturnSimulations
	{
		
		/// <summary>
		/// assets[i] is the data for the i-th asset
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsReturnsSimulationBootstrapPostReturnSimulationsAssets[] AssetsReturnsSimulationBootstrapPostReturnSimulationsAssets { get; set; }
	}
	
	public class AssetsReturnsSimulationBootstrapPostReturnSimulationsAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the simulated return of the i-th asset for the t-th time period
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloCornish_fisherPostPostBody
	{
		
		/// <summary>
		/// The mean parameter of the Cornish-Fisher distribution, corresponding to the arithmetic average return of the asset
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetAverageReturnParameter")]
		public double AssetAverageReturnParameter { get; set; }
		
		/// <summary>
		/// The (excess) kurtosis parameter of the Cornish-Fisher distribution, corresponding approximately to the (excess) kurtosis of the asset returns
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetKurtosisParameter")]
		public double AssetKurtosisParameter { get; set; }
		
		/// <summary>
		/// The skewness parameter of the Cornish-Fisher distribution, corresponding approximately to the skewness of the asset returns
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetSkewnessParameter")]
		public double AssetSkewnessParameter { get; set; }
		
		/// <summary>
		/// The volatility parameter of the Cornish-Fisher distribution, corresponding approximately to the volatility of the asset returns
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetVolatilityParameter")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AssetVolatilityParameter { get; set; }
		
		/// <summary>
		/// The number of simulations to perform
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simulations")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Simulations { get; set; }
		
		/// <summary>
		/// The number of time period(s) to simulate per simulation
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simulationsLength")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SimulationsLength { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloCornish_fisherPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="simulations")]
		public AssetsReturnsSimulationMonte_carloCornish_fisherPostReturnSimulations[] AssetsReturnsSimulationMonte_carloCornish_fisherPostReturnSimulations { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloCornish_fisherPostReturnSimulations
	{
		
		/// <summary>
		/// assets[i] is the data for the i-th asset
		/// Required
		/// Minimum items: 1
		/// Maximum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1)]
		public AssetsReturnsSimulationMonte_carloCornish_fisherPostReturnSimulationsAssets[] AssetsReturnsSimulationMonte_carloCornish_fisherPostReturnSimulationsAssets { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloCornish_fisherPostReturnSimulationsAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the simulated return of the i-th asset for the t-th time period
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostPostBody
	{
		
		/// <summary>
		/// The arithmetic average return of the asset, corresponding to the mean of the corrected Cornish-Fisher distribution
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetAverageReturn")]
		public double AssetAverageReturn { get; set; }
		
		/// <summary>
		/// The kurtosis of the asset returns, corresponding to the kurtosis of the Cornish-Fisher distribution
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetKurtosis")]
		public double AssetKurtosis { get; set; }
		
		/// <summary>
		/// The skewness of the asset returns, corresponding to the skewness of the Cornish-Fisher distribution
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetSkewness")]
		public double AssetSkewness { get; set; }
		
		/// <summary>
		/// The volatility of the asset returns, corresponding to the volatility of the Cornish-Fisher distribution
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AssetVolatility { get; set; }
		
		/// <summary>
		/// The number of simulations to perform
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simulations")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Simulations { get; set; }
		
		/// <summary>
		/// The number of time period(s) to simulate per simulation
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simulationsLength")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SimulationsLength { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="simulations")]
		public AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturnSimulations[] AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturnSimulations { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturnSimulations
	{
		
		/// <summary>
		/// assets[i] is the data for the i-th asset
		/// Required
		/// Minimum items: 1
		/// Maximum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1)]
		public AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturnSimulationsAssets[] AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturnSimulationsAssets { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloCornish_fisherCorrectedPostReturnSimulationsAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the simulated return of the i-th asset for the t-th time period
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloGaussianPostPostBody
	{
		
		/// <summary>
		/// The arithmetic average return of the asset, corresponding to the mean of the Gaussian distribution
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetAverageReturn")]
		public double AssetAverageReturn { get; set; }
		
		/// <summary>
		/// The volatility of the asset returns, corresponding to the standard deviation of the Gaussian distribution
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AssetVolatility { get; set; }
		
		/// <summary>
		/// The number of simulations to perform
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simulations")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Simulations { get; set; }
		
		/// <summary>
		/// The number of time period(s) to simulate per simulation
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="simulationsLength")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SimulationsLength { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloGaussianPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="simulations")]
		public AssetsReturnsSimulationMonte_carloGaussianPostReturnSimulations[] AssetsReturnsSimulationMonte_carloGaussianPostReturnSimulations { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloGaussianPostReturnSimulations
	{
		
		/// <summary>
		/// assets[i] is the data for the i-th asset
		/// Required
		/// Minimum items: 1
		/// Maximum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(1)]
		public AssetsReturnsSimulationMonte_carloGaussianPostReturnSimulationsAssets[] AssetsReturnsSimulationMonte_carloGaussianPostReturnSimulationsAssets { get; set; }
	}
	
	public class AssetsReturnsSimulationMonte_carloGaussianPostReturnSimulationsAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the simulated return of the i-th asset for the t-th time period
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsReturnsTurbulence_partitionedPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsReturnsTurbulence_partitionedPostPostBodyAssets[] AssetsReturnsTurbulence_partitionedPostPostBodyAssets { get; set; }
		
		/// <summary>
		/// The turbulence threshold(s), in percentage; in case several turbulence thresholds are provided, they must be provided in increasing order
		/// Required
		/// Minimum items: 1
		/// Maximum items: 3
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="turbulenceThresholds")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(3)]
		public double[] TurbulenceThresholds { get; set; }
		
		/// <summary>
		/// The method to use to convert the turbulence threshold(s) into turbulence score(s)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="turbulenceThresholdsConversionMethod")]
		public System.Nullable<AssetsReturnsTurbulence_partitionedPostPostBodyTurbulenceThresholdsConversionMethod> TurbulenceThresholdsConversionMethod { get; set; }
	}
	
	public class AssetsReturnsTurbulence_partitionedPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t; all the assetReturns arrays must have the same length
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetReturns { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AssetsReturnsTurbulence_partitionedPostPostBodyTurbulenceThresholdsConversionMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="empiricalQuantileDistribution")]
		empiricalQuantileDistribution = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="chisquareInverseDistribution")]
		chisquareInverseDistribution = 1,
	}
	
	public class AssetsReturnsTurbulence_partitionedPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsReturnsTurbulence_partitionedPostReturnAssets[] AssetsReturnsTurbulence_partitionedPostReturnAssets { get; set; }
	}
	
	public class AssetsReturnsTurbulence_partitionedPostReturnAssets
	{
		
		/// <summary>
		/// assetTurbulencePartitionedReturns[k] corresponds to all the asset returns whose turbulence index is lower than or equal to the turbulence score associated with the turbulence threshold turbulenceThresholds[k]; the length of the array assetTurbulencePartitionedReturns is equal to the length of the array turbulenceThresholds plus 1
		/// Required
		/// Minimum items: 2
		/// Maximum items: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetTurbulencePartitionedReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(4)]
		public AssetsReturnsTurbulence_partitionedPostReturnAssetsAssetTurbulencePartitionedReturns[] AssetsReturnsTurbulence_partitionedPostReturnAssetsAssetTurbulencePartitionedReturns { get; set; }
	}
	
	public class AssetsReturnsTurbulence_partitionedPostReturnAssetsAssetTurbulencePartitionedReturns
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at a time t; the array assetReturns is possibly empty in case no asset returns have a turbulence index lower than or equal to the turbulence score associated with the turbulence threshold turbulenceThresholds[k]
		/// Required
		/// Minimum items: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsSkewnessPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsSkewnessPostPostBodyAssets[] AssetsSkewnessPostPostBodyAssets { get; set; }
	}
	
	public class AssetsSkewnessPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t
		/// Required
		/// Minimum items: 3
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsSkewnessPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsSkewnessPostReturnAssets[] AssetsSkewnessPostReturnAssets { get; set; }
	}
	
	public class AssetsSkewnessPostReturnAssets
	{
		
		/// <summary>
		/// The skewness of the asset
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetSkewness")]
		public double AssetSkewness { get; set; }
	}
	
	public class AssetsVariancePostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsVariancePostPostBodyAssets[] AssetsVariancePostPostBodyAssets { get; set; }
	}
	
	public class AssetsVariancePostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsVariancePostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsVariancePostReturnAssets[] AssetsVariancePostReturnAssets { get; set; }
	}
	
	public class AssetsVariancePostReturnAssets
	{
		
		/// <summary>
		/// The variance of the asset
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetVariance")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AssetVariance { get; set; }
	}
	
	public class AssetsVolatilityPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public AssetsVolatilityPostPostBodyAssets[] AssetsVolatilityPostPostBodyAssets { get; set; }
	}
	
	public class AssetsVolatilityPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetReturns { get; set; }
	}
	
	public class AssetsVolatilityPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public AssetsVolatilityPostReturnAssets[] AssetsVolatilityPostReturnAssets { get; set; }
	}
	
	public class AssetsVolatilityPostReturnAssets
	{
		
		/// <summary>
		/// The volatility of the asset
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double AssetVolatility { get; set; }
	}
	
	public class FactorsResidualizationPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="factors")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public FactorsResidualizationPostPostBodyFactors[] FactorsResidualizationPostPostBodyFactors { get; set; }
		
		/// <summary>
		/// The index of the factor to residualize
		/// Required
		/// Minimum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="residualizedFactor")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public int ResidualizedFactor { get; set; }
	}
	
	public class FactorsResidualizationPostPostBodyFactors
	{
		
		/// <summary>
		/// factorReturns[t] is the return of the factor at the time t; all the factorReturns arrays must have the same length
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="factorReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] FactorReturns { get; set; }
	}
	
	public class FactorsResidualizationPostReturn
	{
		
		/// <summary>
		/// residualizedFactorReturns[t] is the return of the residualized factor at the time t
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="residualizedFactorReturns")]
		public double[] ResidualizedFactorReturns { get; set; }
	}
	
	public class PortfolioAnalysisAlphaPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisAlphaPostReturnPortfolios[] PortfolioAnalysisAlphaPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisAlphaPostReturnPortfolios
	{
		
		/// <summary>
		/// The portfolio Jensen's alpha, which correponds to the portfolio excess return adjusted for the systematic risk in the Capital Asset Pricing Model (CAPM)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioAlpha")]
		public double PortfolioAlpha { get; set; }
	}
	
	public class PortfolioAnalysisBetaPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisBetaPostReturnPortfolios[] PortfolioAnalysisBetaPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisBetaPostReturnPortfolios
	{
		
		/// <summary>
		/// The portfolio beta, which correponds to the portfolio systematic risk in the Capital Asset Pricing Model (CAPM)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioBeta")]
		public double PortfolioBeta { get; set; }
	}
	
	public class PortfolioAnalysisContributionsReturnPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisContributionsReturnPostPostBodyPortfolios[] PortfolioAnalysisContributionsReturnPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisContributionsReturnPostPostBodyPortfolios
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioAnalysisContributionsReturnPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisContributionsReturnPostReturnPortfolios[] PortfolioAnalysisContributionsReturnPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisContributionsReturnPostReturnPortfolios
	{
		
		/// <summary>
		/// assetsGroupsReturnContributions[k] is the return contribution of the group of assets k to the return of the portfolio
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsReturnContributions")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsGroupsReturnContributions { get; set; }
		
		/// <summary>
		/// assetsReturnContributions[i] is the return contribution of the asset i to the return of the portfolio
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturnContributions")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturnContributions { get; set; }
	}
	
	public class PortfolioAnalysisContributionsRiskPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisContributionsRiskPostPostBodyPortfolios[] PortfolioAnalysisContributionsRiskPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisContributionsRiskPostPostBodyPortfolios
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioAnalysisContributionsRiskPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisContributionsRiskPostReturnPortfolios[] PortfolioAnalysisContributionsRiskPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisContributionsRiskPostReturnPortfolios
	{
		
		/// <summary>
		/// assetsGroupsRiskContributions[k] is the risk contribution of the group of assets k to the risk of the portfolio
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsRiskContributions")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsGroupsRiskContributions { get; set; }
		
		/// <summary>
		/// assetsRiskContributions[i] is the risk contribution of the asset i to the risk of the portfolio
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsRiskContributions")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsRiskContributions { get; set; }
	}
	
	public class PortfolioAnalysisCorrelation_spectrumPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisCorrelation_spectrumPostReturnPortfolios[] PortfolioAnalysisCorrelation_spectrumPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisCorrelation_spectrumPostReturnPortfolios
	{
		
		/// <summary>
		/// The correlation spectrum of the portfolio
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioCorrelationSpectrum")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] PortfolioCorrelationSpectrum { get; set; }
	}
	
	public class PortfolioAnalysisDiversification_ratioPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisDiversification_ratioPostReturnPortfolios[] PortfolioAnalysisDiversification_ratioPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisDiversification_ratioPostReturnPortfolios
	{
		
		/// <summary>
		/// The diversification ratio of the portfolio
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioDiversificationRatio")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double PortfolioDiversificationRatio { get; set; }
	}
	
	public class PortfolioAnalysisDrawdownsPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisDrawdownsPostPostBodyPortfolios[] PortfolioAnalysisDrawdownsPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisDrawdownsPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisDrawdownsPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisDrawdownsPostReturnPortfolios[] PortfolioAnalysisDrawdownsPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisDrawdownsPostReturnPortfolios
	{
		
		/// <summary>
		/// portfolioDrawdowns[t] is the value of the drawdown function at the time t
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioDrawdowns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] PortfolioDrawdowns { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioWorstDrawdowns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisDrawdownsPostReturnPortfoliosPortfolioWorstDrawdowns[] PortfolioAnalysisDrawdownsPostReturnPortfoliosPortfolioWorstDrawdowns { get; set; }
	}
	
	public class PortfolioAnalysisDrawdownsPostReturnPortfoliosPortfolioWorstDrawdowns
	{
		
		/// <summary>
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="drawdownBottom")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public int DrawdownBottom { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="drawdownDepth")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double DrawdownDepth { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="drawdownEnd")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public int DrawdownEnd { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="drawdownStart")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Int32.MaxValue)]
		public int DrawdownStart { get; set; }
	}
	
	public class PortfolioAnalysisEffective_number_of_betsPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// The method used to extract the uncorrelated risk factors from the asset covariance matrix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="factorsExtractionMethod")]
		public System.Nullable<PortfolioAnalysisEffective_number_of_betsPostPostBodyFactorsExtractionMethod> FactorsExtractionMethod { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisEffective_number_of_betsPostPostBodyPortfolios[] PortfolioAnalysisEffective_number_of_betsPostPostBodyPortfolios { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PortfolioAnalysisEffective_number_of_betsPostPostBodyFactorsExtractionMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="principalComponentAnalysis")]
		principalComponentAnalysis = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="exactMinimumLinearTorsion")]
		exactMinimumLinearTorsion = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="approximateMinimumLinearTorsion")]
		approximateMinimumLinearTorsion = 2,
	}
	
	public class PortfolioAnalysisEffective_number_of_betsPostPostBodyPortfolios
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioAnalysisEffective_number_of_betsPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisEffective_number_of_betsPostReturnPortfolios[] PortfolioAnalysisEffective_number_of_betsPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisEffective_number_of_betsPostReturnPortfolios
	{
		
		/// <summary>
		/// The effective number of bets of the portfolio
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioEffectiveNumberOfBets")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double PortfolioEffectiveNumberOfBets { get; set; }
	}
	
	public class PortfolioAnalysisFactorsExposuresPostPostBody
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="factors")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisFactorsExposuresPostPostBodyFactors[] PortfolioAnalysisFactorsExposuresPostPostBodyFactors { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisFactorsExposuresPostPostBodyPortfolios[] PortfolioAnalysisFactorsExposuresPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisFactorsExposuresPostPostBodyFactors
	{
		
		/// <summary>
		/// factorReturns[t] is the return of the factor at the time t; all the factorReturns arrays must have the same length, equal to the common length of the portfolioReturns arrays
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="factorReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] FactorReturns { get; set; }
	}
	
	public class PortfolioAnalysisFactorsExposuresPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioReturns[t] is the return of the portfolio at the time t, all the portfolioReturns arrays must have the same length, equal to the common length of the factorReturns arrays
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] PortfolioReturns { get; set; }
	}
	
	public class PortfolioAnalysisFactorsExposuresPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisFactorsExposuresPostReturnPortfolios[] PortfolioAnalysisFactorsExposuresPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisFactorsExposuresPostReturnPortfolios
	{
		
		/// <summary>
		/// The portfolio alpha, which correponds to the portion of the portfolio returns that cannot be explained by the portfolio factor exposures
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioAlpha")]
		public double PortfolioAlpha { get; set; }
		
		/// <summary>
		/// The portfolio betas, which correspond to the portfolio factor exposures
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioBetas")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] PortfolioBetas { get; set; }
		
		/// <summary>
		/// The portfolio R^2, which indicates how much of the variability in the portfolio returns can be explained by the portfolio factor exposures; generally, the higher the R^2 the better the portfolio factor exposures explain the portfolio returns
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioRSquared")]
		public double PortfolioRSquared { get; set; }
	}
	
	public class PortfolioAnalysisMean_varianceEfficient_frontierPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioAnalysisMean_varianceEfficient_frontierPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The number of portfolios to compute on the mean-variance efficient frontier
		/// Minimum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Portfolios { get; set; }
	}
	
	public class PortfolioAnalysisMean_varianceEfficient_frontierPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioAnalysisMean_varianceEfficient_frontierPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisMean_varianceEfficient_frontierPostReturnPortfolios[] PortfolioAnalysisMean_varianceEfficient_frontierPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisMean_varianceEfficient_frontierPostReturnPortfolios
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
		
		/// <summary>
		/// The arithmetic return of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioReturn")]
		public double PortfolioReturn { get; set; }
		
		/// <summary>
		/// The volatility of the portfolio
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double PortfolioVolatility { get; set; }
	}
	
	public class PortfolioAnalysisMean_varianceMinimum_variance_frontierPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioAnalysisMean_varianceMinimum_variance_frontierPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The number of portfolios to compute on the mean-variance minimum variance frontier
		/// Minimum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Portfolios { get; set; }
	}
	
	public class PortfolioAnalysisMean_varianceMinimum_variance_frontierPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioAnalysisMean_varianceMinimum_variance_frontierPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisMean_varianceMinimum_variance_frontierPostReturnPortfolios[] PortfolioAnalysisMean_varianceMinimum_variance_frontierPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisMean_varianceMinimum_variance_frontierPostReturnPortfolios
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
		
		/// <summary>
		/// The arithmetic return of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioReturn")]
		public double PortfolioReturn { get; set; }
		
		/// <summary>
		/// The volatility of the portfolio
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double PortfolioVolatility { get; set; }
	}
	
	public class PortfolioAnalysisReturnPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisReturnPostReturnPortfolios[] PortfolioAnalysisReturnPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisReturnPostReturnPortfolios
	{
		
		/// <summary>
		/// The arithmetic return of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioReturn")]
		public double PortfolioReturn { get; set; }
	}
	
	public class PortfolioAnalysisReturnsAveragePostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisReturnsAveragePostPostBodyPortfolios[] PortfolioAnalysisReturnsAveragePostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisReturnsAveragePostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisReturnsAveragePostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisReturnsAveragePostReturnPortfolios[] PortfolioAnalysisReturnsAveragePostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisReturnsAveragePostReturnPortfolios
	{
		
		/// <summary>
		/// The arithmetic average return of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioAverageReturn")]
		public double PortfolioAverageReturn { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioPostReturnPortfolios[] PortfolioAnalysisSharpe_ratioPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioPostReturnPortfolios
	{
		
		/// <summary>
		/// The Sharpe ratio of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioSharpeRatio")]
		public double PortfolioSharpeRatio { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioBias_adjustedPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioBias_adjustedPostPostBodyPortfolios[] PortfolioAnalysisSharpe_ratioBias_adjustedPostPostBodyPortfolios { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioBias_adjustedPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(4)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioBias_adjustedPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioBias_adjustedPostReturnPortfolios[] PortfolioAnalysisSharpe_ratioBias_adjustedPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioBias_adjustedPostReturnPortfolios
	{
		
		/// <summary>
		/// The bias-adjusted Sharpe ratio of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioBiasAdjustedSharpeRatio")]
		public double PortfolioBiasAdjustedSharpeRatio { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioConfidence_intervalPostPostBody
	{
		
		/// <summary>
		/// The type of confidence interval to build
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceIntervalType")]
		public System.Nullable<PortfolioAnalysisSharpe_ratioConfidence_intervalPostPostBodyConfidenceIntervalType> ConfidenceIntervalType { get; set; }
		
		/// <summary>
		/// The confidence level of the confidence interval to build, in percentage
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioConfidence_intervalPostPostBodyPortfolios[] PortfolioAnalysisSharpe_ratioConfidence_intervalPostPostBodyPortfolios { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PortfolioAnalysisSharpe_ratioConfidence_intervalPostPostBodyConfidenceIntervalType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="twoSided")]
		twoSided = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lowerOneSided")]
		lowerOneSided = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="upperOneSided")]
		upperOneSided = 2,
	}
	
	public class PortfolioAnalysisSharpe_ratioConfidence_intervalPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(4)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioConfidence_intervalPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioConfidence_intervalPostReturnPortfolios[] PortfolioAnalysisSharpe_ratioConfidence_intervalPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioConfidence_intervalPostReturnPortfolios
	{
		
		/// <summary>
		/// portfolioSharpeRatioConfidenceInterval[0] (resp. portfolioSharpeRatioConfidenceInterval[1]) is the lower (resp. upper) bound of the built confidence interval, possibly equal to null in case of a negative infinite (resp. positive infinite) bound
		/// Required
		/// Minimum items: 2
		/// Maximum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioSharpeRatioConfidenceInterval")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		[System.ComponentModel.DataAnnotations.MaxLength(2)]
		public double[] PortfolioSharpeRatioConfidenceInterval { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioProbabilisticPostPostBody
	{
		
		/// <summary>
		/// The Sharpe ratio of the benchmark, in the same sampling frequency as the sampling frequency of the portfolio values
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="benchmarkSharpeRatio")]
		public double BenchmarkSharpeRatio { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioProbabilisticPostPostBodyPortfolios[] PortfolioAnalysisSharpe_ratioProbabilisticPostPostBodyPortfolios { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioProbabilisticPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(4)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioProbabilisticPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioProbabilisticPostReturnPortfolios[] PortfolioAnalysisSharpe_ratioProbabilisticPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioProbabilisticPostReturnPortfolios
	{
		
		/// <summary>
		/// The probabilistic Sharpe ratio of the portfolio, in percentage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioProbabilisticSharpeRatio")]
		public double PortfolioProbabilisticSharpeRatio { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostPostBody
	{
		
		/// <summary>
		/// The Sharpe ratio of the benchmark, in the same sampling frequency as the sampling frequency of the portfolio values
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="benchmarkSharpeRatio")]
		public double BenchmarkSharpeRatio { get; set; }
		
		/// <summary>
		/// The confidence level of the minimum track record length, in percentage
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostPostBodyPortfolios[] PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostPostBodyPortfolios { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 4
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(4)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostReturnPortfolios[] PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisSharpe_ratioProbabilisticMinimum_track_record_lengthPostReturnPortfolios
	{
		
		/// <summary>
		/// The minimum track record length of the portfolio, in number of required arithmetic returns, possibly equal to null in case the minimum track record length does not exist
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioSharpeRatioMinimumTrackRecordLength")]
		public double PortfolioSharpeRatioMinimumTrackRecordLength { get; set; }
	}
	
	public class PortfolioAnalysisTracking_errorPostPostBody
	{
		
		/// <summary>
		/// benchmarkReturns[t] is the return of the benchmark at the time t; the benchmarkReturns array must have the same length as all the portfolioReturns arrays
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="benchmarkReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] BenchmarkReturns { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisTracking_errorPostPostBodyPortfolios[] PortfolioAnalysisTracking_errorPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisTracking_errorPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioReturns[t] is the return of the portfolio at the time t, the portfolioReturns must have the same length as the benchmarkReturns array
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] PortfolioReturns { get; set; }
	}
	
	public class PortfolioAnalysisTracking_errorPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisTracking_errorPostReturnPortfolios[] PortfolioAnalysisTracking_errorPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisTracking_errorPostReturnPortfolios
	{
		
		/// <summary>
		/// The tracking error of the portfolio
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioTrackingError")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double PortfolioTrackingError { get; set; }
	}
	
	public class PortfolioAnalysisUlcer_indexPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisUlcer_indexPostPostBodyPortfolios[] PortfolioAnalysisUlcer_indexPostPostBodyPortfolios { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioAnalysisUlcer_indexPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisUlcer_indexPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisUlcer_indexPostReturnPortfolios[] PortfolioAnalysisUlcer_indexPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisUlcer_indexPostReturnPortfolios
	{
		
		/// <summary>
		/// The Ulcer Index of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioUlcerIndex")]
		public double PortfolioUlcerIndex { get; set; }
	}
	
	public class PortfolioAnalysisUlcer_performance_indexPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisUlcer_performance_indexPostPostBodyPortfolios[] PortfolioAnalysisUlcer_performance_indexPostPostBodyPortfolios { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioAnalysisUlcer_performance_indexPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisUlcer_performance_indexPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioAnalysisUlcer_performance_indexPostReturnPortfolios[] PortfolioAnalysisUlcer_performance_indexPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisUlcer_performance_indexPostReturnPortfolios
	{
		
		/// <summary>
		/// The Ulcer Performance Index of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioUlcerPerformanceIndex")]
		public double PortfolioUlcerPerformanceIndex { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostPostBody
	{
		
		/// <summary>
		/// The confidence level
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostPostBodyPortfolios[] PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 5
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostReturnPortfolios[] PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalCornish_fisherPostReturnPortfolios
	{
		
		/// <summary>
		/// The conditional value at risk of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioConditionalValueAtRisk")]
		public double PortfolioConditionalValueAtRisk { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostPostBody
	{
		
		/// <summary>
		/// The confidence level
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostPostBodyPortfolios[] PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 5
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostReturnPortfolios[] PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalCornish_fisherCorrectedPostReturnPortfolios
	{
		
		/// <summary>
		/// The conditional value at risk of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioConditionalValueAtRisk")]
		public double PortfolioConditionalValueAtRisk { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalGaussianPostPostBody
	{
		
		/// <summary>
		/// The confidence level
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskConditionalGaussianPostPostBodyPortfolios[] PortfolioAnalysisValue_at_riskConditionalGaussianPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalGaussianPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 3
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalGaussianPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskConditionalGaussianPostReturnPortfolios[] PortfolioAnalysisValue_at_riskConditionalGaussianPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalGaussianPostReturnPortfolios
	{
		
		/// <summary>
		/// The conditional value at risk of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioConditionalValueAtRisk")]
		public double PortfolioConditionalValueAtRisk { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalHistoricalPostPostBody
	{
		
		/// <summary>
		/// The confidence level
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskConditionalHistoricalPostPostBodyPortfolios[] PortfolioAnalysisValue_at_riskConditionalHistoricalPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalHistoricalPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalHistoricalPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskConditionalHistoricalPostReturnPortfolios[] PortfolioAnalysisValue_at_riskConditionalHistoricalPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskConditionalHistoricalPostReturnPortfolios
	{
		
		/// <summary>
		/// The conditional value at risk of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioConditionalValueAtRisk")]
		public double PortfolioConditionalValueAtRisk { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskCornish_fisherPostPostBody
	{
		
		/// <summary>
		/// The confidence level
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskCornish_fisherPostPostBodyPortfolios[] PortfolioAnalysisValue_at_riskCornish_fisherPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskCornish_fisherPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 5
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskCornish_fisherPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskCornish_fisherPostReturnPortfolios[] PortfolioAnalysisValue_at_riskCornish_fisherPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskCornish_fisherPostReturnPortfolios
	{
		
		/// <summary>
		/// The value at risk of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValueAtRisk")]
		public double PortfolioValueAtRisk { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostPostBody
	{
		
		/// <summary>
		/// The confidence level
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostPostBodyPortfolios[] PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 5
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(5)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostReturnPortfolios[] PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskCornish_fisherCorrectedPostReturnPortfolios
	{
		
		/// <summary>
		/// The value at risk of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValueAtRisk")]
		public double PortfolioValueAtRisk { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskGaussianPostPostBody
	{
		
		/// <summary>
		/// The confidence level
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskGaussianPostPostBodyPortfolios[] PortfolioAnalysisValue_at_riskGaussianPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskGaussianPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 3
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(3)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskGaussianPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskGaussianPostReturnPortfolios[] PortfolioAnalysisValue_at_riskGaussianPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskGaussianPostReturnPortfolios
	{
		
		/// <summary>
		/// The value at risk of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValueAtRisk")]
		public double PortfolioValueAtRisk { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskHistoricalPostPostBody
	{
		
		/// <summary>
		/// The confidence level
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidenceLevel")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> ConfidenceLevel { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskHistoricalPostPostBodyPortfolios[] PortfolioAnalysisValue_at_riskHistoricalPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskHistoricalPostPostBodyPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskHistoricalPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisValue_at_riskHistoricalPostReturnPortfolios[] PortfolioAnalysisValue_at_riskHistoricalPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisValue_at_riskHistoricalPostReturnPortfolios
	{
		
		/// <summary>
		/// The value at risk of the portfolio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValueAtRisk")]
		public double PortfolioValueAtRisk { get; set; }
	}
	
	public class PortfolioAnalysisVolatilityPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioAnalysisVolatilityPostReturnPortfolios[] PortfolioAnalysisVolatilityPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioAnalysisVolatilityPostReturnPortfolios
	{
		
		/// <summary>
		/// The volatility of the portfolio
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double PortfolioVolatility { get; set; }
	}
	
	public class PortfolioConstructionInvestablePostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsWeights[i] is the desired weight of the assets group k in the portfolio, in percentage (can be null to indicate no specific desire); requires assetsGroups to be present
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// assetsMinimumNotionalValues[i] is the minimum monetary value that the position in the asset i is required to represent when the asset i is included in the portfolio
		/// Minimum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsMinimumNotionalValues")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsMinimumNotionalValues { get; set; }
		
		/// <summary>
		/// assetsMinimumPositions[i] is the minimum number of shares of the asset i that is required to purchase when the asset i is included in the portfolio (usual values are the same as for assetsSizeLots)
		/// Minimum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsMinimumPositions")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsMinimumPositions { get; set; }
		
		/// <summary>
		/// assetsPrices[i] is the price of the asset i
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsPrices { get; set; }
		
		/// <summary>
		/// assetsSizeLots[i] is the number of shares by which it is required to purchase the asset i (usual values are 1 if the asset needs to be purchased share by share, 100 if the asset needs to be purchased by an integer multiple of 100 shares, and 1/1000000 - e.g. for Robinhood broker - if the asset can be purchased by fractional shares)
		/// Minimum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsSizeLots")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsSizeLots { get; set; }
		
		/// <summary>
		/// assetsWeights[i] is the desired weight of the asset i in the portfolio, in percentage (can be null to indicate no specific desire)
		/// Minimum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum desired weight of the assets group k in the portfolio, in percentage (can be null to indicate no specific desire); requires assetsGroups to be present
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// The monetary value of the portfolio
		/// Required
		/// Minimum: 0
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValue")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public double PortfolioValue { get; set; }
	}
	
	public class PortfolioConstructionInvestablePostReturn
	{
		
		/// <summary>
		/// assetsPositions[i] is the number of shares of the asset i in the portfolio
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsPositions")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsPositions { get; set; }
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioConstructionMimickingPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public PortfolioConstructionMimickingPostPostBodyAssets[] PortfolioConstructionMimickingPostPostBodyAssets { get; set; }
		
		/// <summary>
		/// benchmarkReturns[t] is the return of the benchmark at the time t; the benchmarkReturns array must have the same length as all the assetReturns arrays
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="benchmarkReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] BenchmarkReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioConstructionMimickingPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioConstructionMimickingPostPostBodyAssets
	{
		
		/// <summary>
		/// assetReturns[t] is the return of the asset at the time t; all the assetReturns arrays must have the same length
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetReturns { get; set; }
	}
	
	public class PortfolioConstructionMimickingPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioConstructionMimickingPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioConstructionRandomPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioConstructionRandomPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The number of portfolios to construct
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Portfolios { get; set; }
	}
	
	public class PortfolioConstructionRandomPostPostBodyConstraints
	{
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioConstructionRandomPostReturn
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioConstructionRandomPostReturnPortfolios[] PortfolioConstructionRandomPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioConstructionRandomPostReturnPortfolios
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationEqual_risk_contributionsPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationEqual_risk_contributionsPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationEqual_risk_contributionsPostPostBodyConstraints
	{
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationEqual_risk_contributionsPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationEqual_sharpe_ratio_contributionsPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsReturns { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioOptimizationEqual_sharpe_ratio_contributionsPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationEqual_volatility_weightedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsVolatilities[i] is the volatility of the asset i
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsVolatilities")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsVolatilities { get; set; }
	}
	
	public class PortfolioOptimizationEqual_volatility_weightedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationEqual_weightedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
	}
	
	public class PortfolioOptimizationEqual_weightedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationHierarchical_risk_parityPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// The hierarchical clustering method to use
		/// </summary>
		[System.ComponentModel.DefaultValue(AssetsCorrelationMatrixTheory_impliedPostPostBodyClusteringMethod.singleLinkage)]
		[System.Runtime.Serialization.DataMember(Name="clusteringMethod")]
		public AssetsCorrelationMatrixTheory_impliedPostPostBodyClusteringMethod ClusteringMethod { get; set; } = AssetsCorrelationMatrixTheory_impliedPostPostBodyClusteringMethod.singleLinkage;
		
		/// <summary>
		/// The order to impose on the hierarchical clustering tree leaves
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusteringOrdering")]
		public System.Nullable<PortfolioOptimizationHierarchical_risk_parityPostPostBodyClusteringOrdering> ClusteringOrdering { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationHierarchical_risk_parityPostPostBodyConstraints Constraints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PortfolioOptimizationHierarchical_risk_parityPostPostBodyClusteringOrdering
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="r-hclust")]
		rMinushclust = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="optimal")]
		optimal = 1,
	}
	
	public class PortfolioOptimizationHierarchical_risk_parityPostPostBodyConstraints
	{
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationHierarchical_risk_parityPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBody
	{
		
		/// <summary>
		/// The allocation method to use across clusters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acrossClusterAllocationMethod")]
		public System.Nullable<PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyAcrossClusterAllocationMethod> AcrossClusterAllocationMethod { get; set; }
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// The hierarchical clustering method to use
		/// </summary>
		[System.ComponentModel.DefaultValue(AssetsCorrelationMatrixTheory_impliedPostPostBodyClusteringMethod.wardLinkage)]
		[System.Runtime.Serialization.DataMember(Name="clusteringMethod")]
		public AssetsCorrelationMatrixTheory_impliedPostPostBodyClusteringMethod ClusteringMethod { get; set; } = AssetsCorrelationMatrixTheory_impliedPostPostBodyClusteringMethod.wardLinkage;
		
		/// <summary>
		/// The order to impose on the hierarchical clustering tree leaves
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusteringOrdering")]
		public System.Nullable<PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyClusteringOrdering> ClusteringOrdering { get; set; }
		
		/// <summary>
		/// The number of clusters to use in the hierarchical clustering tree; if not provided, the number of clusters to use is computed using the gap statistic method, as described in the first reference
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusters")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Clusters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The allocation method to use within clusters
		/// </summary>
		[System.ComponentModel.DefaultValue(PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyAcrossClusterAllocationMethod.equalWeighting)]
		[System.Runtime.Serialization.DataMember(Name="withinClusterAllocationMethod")]
		public PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyAcrossClusterAllocationMethod WithinClusterAllocationMethod { get; set; } = PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyAcrossClusterAllocationMethod.equalWeighting;
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyAcrossClusterAllocationMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="equalWeighting")]
		equalWeighting = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="inverseVolatility")]
		inverseVolatility = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="inverseVariance")]
		inverseVariance = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyClusteringOrdering
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="r-hclust")]
		rMinushclust = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="optimal")]
		optimal = 1,
	}
	
	public class PortfolioOptimizationHierarchical_risk_parityClustering_basedPostPostBodyConstraints
	{
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationHierarchical_risk_parityClustering_basedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationInverse_variance_weightedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsVariances[i] is the variance of the asset i
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsVariances")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsVariances { get; set; }
	}
	
	public class PortfolioOptimizationInverse_variance_weightedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationInverse_volatility_weightedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsVolatilities[i] is the volatility of the asset i
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsVolatilities")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsVolatilities { get; set; }
	}
	
	public class PortfolioOptimizationInverse_volatility_weightedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMarket_capitalization_weightedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsMarketCapitalizations[i] is the market capitalization of the asset i
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsMarketCapitalizations")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsMarketCapitalizations { get; set; }
	}
	
	public class PortfolioOptimizationMarket_capitalization_weightedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_decorrelationPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMaximum_decorrelationPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_decorrelationPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_decorrelationPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_returnPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Minimum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMaximum_returnPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_returnPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_returnPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_returnDiversifiedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Minimum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMaximum_returnDiversifiedPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_returnDiversifiedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// The relative tolerance over the maximum return portfolio return
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaReturn")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DeltaReturn { get; set; }
		
		/// <summary>
		/// The relative tolerance over the maximum return portfolio volatility, if applicable
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DeltaVolatility { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_returnDiversifiedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Minimum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The number of subset portfolios to compute; only applicable if the enumeration method for the subset portfolios is random sampling
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetPortfolios")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SubsetPortfolios { get; set; }
		
		/// <summary>
		/// The method to aggregate the subset portfolios
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetPortfoliosAggregationMethod")]
		public System.Nullable<PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod> SubsetPortfoliosAggregationMethod { get; set; }
		
		/// <summary>
		/// The method to enumerate the subset portfolios
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetPortfoliosEnumerationMethod")]
		public System.Nullable<PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod> SubsetPortfoliosEnumerationMethod { get; set; }
		
		/// <summary>
		/// The number of assets to include in each subset portfolio; defaults to a value of order the square root of the total number of assets
		/// Minimum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetSize")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SubsetSize { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="average")]
		average = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="median")]
		median = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="complete")]
		complete = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="randomSampling")]
		randomSampling = 1,
	}
	
	public class PortfolioOptimizationMaximum_returnSubset_resampling_basedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMaximum_sharpe_ratioPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// The relative tolerance over the maximum Sharpe ratio portfolio return
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaReturn")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DeltaReturn { get; set; }
		
		/// <summary>
		/// The relative tolerance over the maximum Sharpe ratio portfolio volatility
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DeltaVolatility { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioDiversifiedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
		
		/// <summary>
		/// The number of subset portfolios to compute; only applicable if the enumeration method for the subset portfolios is random sampling
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetPortfolios")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SubsetPortfolios { get; set; }
		
		/// <summary>
		/// The method to aggregate the subset portfolios
		/// </summary>
		[System.ComponentModel.DefaultValue(PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod.average)]
		[System.Runtime.Serialization.DataMember(Name="subsetPortfoliosAggregationMethod")]
		public PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod SubsetPortfoliosAggregationMethod { get; set; } = PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod.average;
		
		/// <summary>
		/// The method to enumerate the subset portfolios
		/// </summary>
		[System.ComponentModel.DefaultValue(PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod.randomSampling)]
		[System.Runtime.Serialization.DataMember(Name="subsetPortfoliosEnumerationMethod")]
		public PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod SubsetPortfoliosEnumerationMethod { get; set; } = PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod.randomSampling;
		
		/// <summary>
		/// The number of assets to include in each subset portfolio; defaults to a value of order the square root of the total number of assets
		/// Minimum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetSize")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SubsetSize { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_sharpe_ratioSubset_resampling_basedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_ulcer_performance_indexPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioOptimizationMaximum_ulcer_performance_indexPostPostBodyAssets[] PortfolioOptimizationMaximum_ulcer_performance_indexPostPostBodyAssets { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMaximum_ulcer_performance_indexPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The risk free rate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="riskFreeRate")]
		public double RiskFreeRate { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_ulcer_performance_indexPostPostBodyAssets
	{
		
		/// <summary>
		/// assetPrices[t] is the price of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetPrices { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_ulcer_performance_indexPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMaximum_ulcer_performance_indexPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMean_variance_efficientPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
		
		/// <summary>
		/// The portfolio return; exclusive with portfolioVolatility and riskTolerance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolioReturn")]
		public System.Nullable<System.Double> PortfolioReturn { get; set; }
		
		/// <summary>
		/// The portfolio volatility; exclusive with portfolioReturn and riskTolerance
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolioVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> PortfolioVolatility { get; set; }
		
		/// <summary>
		/// The portfolio risk tolerance; exclusive with portfolioReturn and portfolioVolatility
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riskTolerance")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> RiskTolerance { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientDiversifiedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMean_variance_efficientDiversifiedPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientDiversifiedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// The relative tolerance over the mean-variance efficient portfolio return
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaReturn")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DeltaReturn { get; set; }
		
		/// <summary>
		/// The relative tolerance over the mean-variance efficient portfolio volatility
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DeltaVolatility { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
		
		/// <summary>
		/// The portfolio return; exclusive with portfolioVolatility and riskTolerance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolioReturn")]
		public System.Nullable<System.Double> PortfolioReturn { get; set; }
		
		/// <summary>
		/// The portfolio volatility; exclusive with portfolioReturn and riskTolerance
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolioVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> PortfolioVolatility { get; set; }
		
		/// <summary>
		/// The portfolio risk tolerance; exclusive with portfolioReturn and portfolioVolatility
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riskTolerance")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> RiskTolerance { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientDiversifiedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The number of subset portfolios to compute; only applicable if the enumeration method for the subset portfolios is random sampling
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetPortfolios")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SubsetPortfolios { get; set; }
		
		/// <summary>
		/// The method to aggregate the subset portfolios
		/// </summary>
		[System.ComponentModel.DefaultValue(PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod.average)]
		[System.Runtime.Serialization.DataMember(Name="subsetPortfoliosAggregationMethod")]
		public PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod SubsetPortfoliosAggregationMethod { get; set; } = PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod.average;
		
		/// <summary>
		/// The method to enumerate the subset portfolios
		/// </summary>
		[System.ComponentModel.DefaultValue(PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod.randomSampling)]
		[System.Runtime.Serialization.DataMember(Name="subsetPortfoliosEnumerationMethod")]
		public PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod SubsetPortfoliosEnumerationMethod { get; set; } = PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod.randomSampling;
		
		/// <summary>
		/// The number of assets to include in each subset portfolio; defaults to a value of order the square root of the total number of assets
		/// Minimum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetSize")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SubsetSize { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
		
		/// <summary>
		/// The portfolio return; exclusive with portfolioVolatility and riskTolerance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolioReturn")]
		public System.Nullable<System.Double> PortfolioReturn { get; set; }
		
		/// <summary>
		/// The portfolio volatility; exclusive with portfolioReturn and riskTolerance
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolioVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> PortfolioVolatility { get; set; }
		
		/// <summary>
		/// The portfolio risk tolerance; exclusive with portfolioReturn and portfolioVolatility
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riskTolerance")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> RiskTolerance { get; set; }
	}
	
	public class PortfolioOptimizationMean_variance_efficientSubset_resampling_basedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_correlationPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCorrelationMatrix[i][j] is the correlation between the asset i and the asset j; required if assetsReturns is not provided
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCorrelationMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCorrelationMatrix { get; set; }
		
		/// <summary>
		/// assetsVariances[i] is the volatility of the asset i; required if assetsCorrelationMatrix is provided and assetsVariances is not provided
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsVolatilities")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsVolatilities { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_correlationPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_ulcer_indexPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioOptimizationMinimum_ulcer_indexPostPostBodyAssets[] PortfolioOptimizationMinimum_ulcer_indexPostPostBodyAssets { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMinimum_ulcer_indexPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_ulcer_indexPostPostBodyAssets
	{
		
		/// <summary>
		/// assetPrices[t] is the price of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetPrices { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_ulcer_indexPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_ulcer_indexPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_variancePostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMinimum_variancePostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_variancePostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_variancePostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_varianceDiversifiedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMinimum_varianceDiversifiedPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_varianceDiversifiedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// The relative tolerance over the minimum variance portfolio return, if applicable
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaReturn")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DeltaReturn { get; set; }
		
		/// <summary>
		/// The relative tolerance over the minimum variance portfolio volatility
		/// Minimum: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deltaVolatility")]
		[System.ComponentModel.DataAnnotations.Range(0, System.Double.MaxValue)]
		public System.Nullable<System.Double> DeltaVolatility { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_varianceDiversifiedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_varianceSubset_resampling_basedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		/// <summary>
		/// assetsReturns[i] is the arithmetic return of asset i
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsReturns")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsReturns { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMinimum_varianceSubset_resampling_basedPostPostBodyConstraints Constraints { get; set; }
		
		/// <summary>
		/// The number of subset portfolios to compute; only applicable if the enumeration method for the subset portfolios is random sampling
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetPortfolios")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SubsetPortfolios { get; set; }
		
		/// <summary>
		/// The method to aggregate the subset portfolios
		/// </summary>
		[System.ComponentModel.DefaultValue(PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod.average)]
		[System.Runtime.Serialization.DataMember(Name="subsetPortfoliosAggregationMethod")]
		public PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod SubsetPortfoliosAggregationMethod { get; set; } = PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosAggregationMethod.average;
		
		/// <summary>
		/// The method to enumerate the subset portfolios
		/// </summary>
		[System.ComponentModel.DefaultValue(PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod.randomSampling)]
		[System.Runtime.Serialization.DataMember(Name="subsetPortfoliosEnumerationMethod")]
		public PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod SubsetPortfoliosEnumerationMethod { get; set; } = PortfolioOptimizationMaximum_returnSubset_resampling_basedPostPostBodySubsetPortfoliosEnumerationMethod.randomSampling;
		
		/// <summary>
		/// The number of assets to include in each subset portfolio; defaults to a value of order the square root of the total number of assets
		/// Minimum: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetSize")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> SubsetSize { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_varianceSubset_resampling_basedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMinimum_varianceSubset_resampling_basedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioOptimizationMost_diversifiedPostPostBody
	{
		
		/// <summary>
		/// The number of assets
		/// Required
		/// Minimum: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.Range(2, System.Int32.MaxValue)]
		public int Assets { get; set; }
		
		/// <summary>
		/// assetsCovarianceMatrix[i][j] is the covariance between the asset i and the asset j
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsCovarianceMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public string[] AssetsCovarianceMatrix { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public PortfolioOptimizationMost_diversifiedPostPostBodyConstraints Constraints { get; set; }
	}
	
	public class PortfolioOptimizationMost_diversifiedPostPostBodyConstraints
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroups")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroups { get; set; }
		
		/// <summary>
		/// assetsGroupsMatrix[k][i] is the weight of the asset i in the group of assets k; exclusive with assetsGroups
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assetsGroupsMatrix")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] AssetsGroupsMatrix { get; set; }
		
		/// <summary>
		/// maximumAssetsGroupsWeights[k] is the maximum weight of the assets group k in the portfolio, in percentage between 0 and 1 if assetsGroups is provided
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsGroupsWeights")]
		public double[] MaximumAssetsGroupsWeights { get; set; }
		
		/// <summary>
		/// maximumAssetsWeights[i] is the maximum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumAssetsWeights")]
		public double[] MaximumAssetsWeights { get; set; }
		
		/// <summary>
		/// The maximum portfolio exposure; must be higher than or equal to minimumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MaximumPortfolioExposure { get; set; }
		
		/// <summary>
		/// minimumAssetsWeights[i] is the minimum weight of the asset i in the portfolio, in percentage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumAssetsWeights")]
		public double[] MinimumAssetsWeights { get; set; }
		
		/// <summary>
		/// The minimum portfolio exposure; must be lower than or equal to maximumPortfolioExposure
		/// Minimum: 0
		/// Maximum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumPortfolioExposure")]
		[System.ComponentModel.DataAnnotations.Range(0, 1)]
		public System.Nullable<System.Double> MinimumPortfolioExposure { get; set; }
	}
	
	public class PortfolioOptimizationMost_diversifiedPostReturn
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioSimulationRebalancingDrift_weightPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioSimulationRebalancingDrift_weightPostPostBodyAssets[] PortfolioSimulationRebalancingDrift_weightPostPostBodyAssets { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioSimulationRebalancingDrift_weightPostPostBodyPortfolios[] PortfolioSimulationRebalancingDrift_weightPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioSimulationRebalancingDrift_weightPostPostBodyAssets
	{
		
		/// <summary>
		/// assetPrices[t] is the price of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetPrices { get; set; }
	}
	
	public class PortfolioSimulationRebalancingDrift_weightPostPostBodyPortfolios
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioSimulationRebalancingDrift_weightPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioSimulationRebalancingDrift_weightPostReturnPortfolios[] PortfolioSimulationRebalancingDrift_weightPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioSimulationRebalancingDrift_weightPostReturnPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioSimulationRebalancingFixed_weightPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioSimulationRebalancingFixed_weightPostPostBodyAssets[] PortfolioSimulationRebalancingFixed_weightPostPostBodyAssets { get; set; }
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioSimulationRebalancingFixed_weightPostPostBodyPortfolios[] PortfolioSimulationRebalancingFixed_weightPostPostBodyPortfolios { get; set; }
	}
	
	public class PortfolioSimulationRebalancingFixed_weightPostPostBodyAssets
	{
		
		/// <summary>
		/// assetPrices[t] is the price of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetPrices { get; set; }
	}
	
	public class PortfolioSimulationRebalancingFixed_weightPostPostBodyPortfolios
	{
		
		/// <summary>
		/// assetsWeights[i] is the weight of the asset i in the portfolio, in percentage
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetsWeights")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public double[] AssetsWeights { get; set; }
	}
	
	public class PortfolioSimulationRebalancingFixed_weightPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioSimulationRebalancingFixed_weightPostReturnPortfolios[] PortfolioSimulationRebalancingFixed_weightPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioSimulationRebalancingFixed_weightPostReturnPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		public double[] PortfolioValues { get; set; }
	}
	
	public class PortfolioSimulationRebalancingRandom_weightPostPostBody
	{
		
		/// <summary>
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assets")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public PortfolioSimulationRebalancingRandom_weightPostPostBodyAssets[] PortfolioSimulationRebalancingRandom_weightPostPostBodyAssets { get; set; }
		
		/// <summary>
		/// The number of portfolios to simulate
		/// Minimum: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		[System.ComponentModel.DataAnnotations.Range(1, System.Int32.MaxValue)]
		public System.Nullable<System.Int32> Portfolios { get; set; }
	}
	
	public class PortfolioSimulationRebalancingRandom_weightPostPostBodyAssets
	{
		
		/// <summary>
		/// assetPrices[t] is the price of the asset at the time t
		/// Required
		/// Minimum items: 2
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assetPrices")]
		[System.ComponentModel.DataAnnotations.MinLength(2)]
		public double[] AssetPrices { get; set; }
	}
	
	public class PortfolioSimulationRebalancingRandom_weightPostReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolios")]
		public PortfolioSimulationRebalancingRandom_weightPostReturnPortfolios[] PortfolioSimulationRebalancingRandom_weightPostReturnPortfolios { get; set; }
	}
	
	public class PortfolioSimulationRebalancingRandom_weightPostReturnPortfolios
	{
		
		/// <summary>
		/// portfolioValues[t] is the value of the portfolio at the time t
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="portfolioValues")]
		public double[] PortfolioValues { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
