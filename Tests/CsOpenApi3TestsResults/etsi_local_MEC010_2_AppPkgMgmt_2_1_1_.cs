//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// 'Identifies the action of the MEC host data plane, when a packet matches the trafficFilter.'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Action
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DROP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORWARD_DECAPSULATED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORWARD_AS_IS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PASSTHROUGH = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DUPLICATED_DECAPSULATED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DUPLICATE_AS_IS = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppD
	{
		
		/// <summary>
		/// Identifier of this MEC application descriptor. This attribute shall be globally unique. See note 1.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appDId")]
		public string AppDId { get; set; }
		
		/// <summary>
		/// Describes DNS rules the MEC application requires.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appDNSRule")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public DNSRuleDescriptor[] AppDNSRule { get; set; }
		
		/// <summary>
		/// Identifies the version of the application descriptor.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appDVersion")]
		public string AppDVersion { get; set; }
		
		/// <summary>
		/// Human readable description of the MEC application.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appDescription")]
		public string AppDescription { get; set; }
		
		/// <summary>
		/// Describes external interface(s) exposed by this MEC application.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appExtCpd")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public AppExternalCpd[] AppExtCpd { get; set; }
		
		/// <summary>
		/// Describes features a MEC application may use if available.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appFeatureOptional")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public FeatureDependency[] AppFeatureOptional { get; set; }
		
		/// <summary>
		/// Describes features a MEC application requires to run.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appFeatureRequired")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public FeatureDependency[] AppFeatureRequired { get; set; }
		
		/// <summary>
		/// Human readable name for the MEC application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appInfoName")]
		public string AppInfoName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="appLatency")]
		public LatencyDescriptor AppLatency { get; set; }
		
		/// <summary>
		/// Name to identify the MEC application.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appName")]
		public string AppName { get; set; }
		
		/// <summary>
		/// Provider of the application and of the AppD.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appProvider")]
		public string AppProvider { get; set; }
		
		/// <summary>
		/// Describes services a MEC application may use if available.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appServiceOptional")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public ServiceDependency[] AppServiceOptional { get; set; }
		
		/// <summary>
		/// Describes services a MEC application is able to produce to the platform or other MEC applications. Only relevant for service-producing apps.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appServiceProduced")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public ServiceDescriptor[] AppServiceProduced { get; set; }
		
		/// <summary>
		/// Describes services a MEC application requires to run.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appServiceRequired")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public ServiceDependency[] AppServiceRequired { get; set; }
		
		/// <summary>
		/// Identifies the version of software of the MEC application.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appSoftVersion")]
		public string AppSoftVersion { get; set; }
		
		/// <summary>
		/// Describes traffic rules the MEC application requires.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appTrafficRule")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public TrafficRuleDescriptor[] AppTrafficRule { get; set; }
		
		/// <summary>
		/// NFV
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="changeAppInstanceStateOpConfig")]
		public string ChangeAppInstanceStateOpConfig { get; set; }
		
		/// <summary>
		/// Identifies version(s) of MEC system compatible with the MEC application described in this version of the AppD.
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mecVersion")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] MecVersion { get; set; }
		
		/// <summary>
		/// Ref NFV
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="swImageDescriptor")]
		public string SwImageDescriptor { get; set; }
		
		/// <summary>
		/// NFV
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="terminateAppInstanceOpConfig")]
		public string TerminateAppInstanceOpConfig { get; set; }
		
		/// <summary>
		/// Transports, if any, that this application requires to be provided by the platform. These transports will be used by the application to deliver services provided by this application. Only relevant for service-producing apps. See note 2.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transportDependencies")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public TransportDependency[] TransportDependencies { get; set; }
		
		/// <summary>
		/// Ref NFV
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="virtualComputeDescriptor")]
		public string VirtualComputeDescriptor { get; set; }
		
		/// <summary>
		/// Defines descriptors of virtual storage resources to be used by the MEC application.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualStorageDescriptor")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] VirtualStorageDescriptor { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DNSRuleDescriptor
	{
		
		/// <summary>
		/// Identifies the DNS Rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dnsRuleId")]
		public string DnsRuleId { get; set; }
		
		/// <summary>
		/// FQDN of the DNS rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domainName")]
		public string DomainName { get; set; }
		
		/// <summary>
		/// IP address given by the DNS rule
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Specifies the IP address type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipAddressType")]
		public DNSRuleDescriptorIpAddressType IpAddressType { get; set; }
		
		/// <summary>
		/// Time-to-live value
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DNSRuleDescriptorIpAddressType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP_V6 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP_V4 = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppExternalCpd
	{
		
		/// <summary>
		/// All attributes inherited from Cpd.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="inherited_attributes")]
		public string Inherited_attributes { get; set; }
		
		/// <summary>
		/// Specifies requirements on a virtual network interface realizing the CPs instantiated from this CPD.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualNetworkInterfaceRequirements")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] VirtualNetworkInterfaceRequirements { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FeatureDependency
	{
		
		/// <summary>
		/// The name of the feature, for example, UserApps, UEIdentity, etc.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="featureName")]
		public string FeatureName { get; set; }
		
		/// <summary>
		/// The version of the feature.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LatencyDescriptor
	{
		
		/// <summary>
		/// The value of the maximum latency in nano seconds tolerated by the MEC application. See note.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxLatency")]
		public string MaxLatency { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceDependency
	{
		
		/// <summary>
		/// Requested permissions regarding the access of the application to the service. See clause 8.2 of ETSI GS MEC 009 [4].
		///The format of this attribute is left for the data model design stage.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedPermissions")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] RequestedPermissions { get; set; }
		
		/// <summary>
		/// See MEC011
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serCategory")]
		public CategoryRef SerCategory { get; set; }
		
		/// <summary>
		/// The name of the service, for example, RNIS, LocationService, etc.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serName")]
		public string SerName { get; set; }
		
		/// <summary>
		/// Indicates transport and serialization format dependencies of consuming the service. Defaults to REST + JSON if absent. See note.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serTransportDependencies")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public TransportDependency[] SerTransportDependencies { get; set; }
		
		/// <summary>
		/// The version of the service.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TransportDependency
	{
		
		/// <summary>
		/// Set of labels that allow to define groups of transport bindings. The mechanism of the grouping is defined below this table.
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Labels { get; set; }
		
		/// <summary>
		/// Information about the serializers in this transport binding, as defined in the SerializerTypes type in ETSI GS MEC 011 [i.4]. Support for at least one of the entries is required in conjunction with the transport.
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serializers")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Serializers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transport")]
		public TransportDescriptor Transport { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TransportDescriptor
	{
		
		/// <summary>
		/// The name of the protocol used. Shall be set to HTTP for a REST API.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public string Protocol { get; set; }
		
		/// <summary>
		/// See MEC011
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="security")]
		public SecurityInfo Security { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// The version of the protocol used.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// 'The ServiceDescriptor data type describes a MEC service produced by a service-providing MEC application.'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceDescriptor
	{
		
		/// <summary>
		/// See MEC011
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serCategory")]
		public CategoryRef SerCategory { get; set; }
		
		/// <summary>
		/// The name of the service, for example, RNIS, LocationService, etc.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serName")]
		public string SerName { get; set; }
		
		/// <summary>
		/// 'Indicates transports and serialization formats supported made available to the service-consuming application. Defaults to REST + JSON if absent.'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transportsSupported")]
		public TransportsSupported TransportsSupported { get; set; }
		
		/// <summary>
		/// The version of the service.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// 'Indicates transports and serialization formats supported made available to the service-consuming application. Defaults to REST + JSON if absent.'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TransportsSupported
	{
		
		/// <summary>
		/// 'Information about the serializers in this binding, as defined in the SerializerTypes type in ETSI GS MEC 011 '
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serializers")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Serializers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transport")]
		public TransportDescriptor Transport { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TrafficRuleDescriptor
	{
		
		/// <summary>
		/// 'Identifies the action of the MEC host data plane, when a packet matches the trafficFilter.'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Action Action { get; set; }
		
		/// <summary>
		/// Minimum items: 0
		/// Maximum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstInterface")]
		[System.ComponentModel.DataAnnotations.Length(0, 2)]
		public InterfaceDescriptor[] DstInterface { get; set; }
		
		/// <summary>
		/// Definition of filter type: per FLOW or PACKET
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="filterType")]
		public TrafficRuleDescriptorFilterType FilterType { get; set; }
		
		/// <summary>
		/// Priority of this traffic rule. If traffic rule conflicts, the one with higher priority take precedence.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public int Priority { get; set; }
		
		/// <summary>
		/// The filter used to identify specific flow/packets that need to be handled by the MEC host.
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trafficFilter")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public TrafficFilter[] TrafficFilter { get; set; }
		
		/// <summary>
		/// Identifies the traffic rule.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trafficRuleId")]
		public string TrafficRuleId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InterfaceDescriptor
	{
		
		/// <summary>
		/// If the interface type is IP, the destination address identifies the IP address of the destination. Only used for dstInterface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstIPAddress")]
		public string DstIPAddress { get; set; }
		
		/// <summary>
		/// If the interface type is MAC, the destination address identifies the MAC address of the destination. Only used for dstInterface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstMACAddress")]
		public string DstMACAddress { get; set; }
		
		/// <summary>
		/// Type of interface.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interfaceType")]
		public InterfaceDescriptorInterfaceType InterfaceType { get; set; }
		
		/// <summary>
		/// If the interface type is MAC, the source address identifies the MAC address of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcMACAddress")]
		public string SrcMACAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tunnelInfo")]
		public TunnelInfo TunnelInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum InterfaceDescriptorInterfaceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TUNNEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TunnelInfo
	{
		
		/// <summary>
		/// Destination address of the tunnel.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tunnelDstAddress")]
		public string TunnelDstAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tunnelSpecificData")]
		public string TunnelSpecificData { get; set; }
		
		/// <summary>
		/// Source address of the tunnel.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tunnelSrcAddress")]
		public string TunnelSrcAddress { get; set; }
		
		/// <summary>
		/// Type of tunnel.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tunnelType")]
		public TunnelInfoTunnelType TunnelType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TunnelInfoTunnelType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GTP-U")]
		GTPMinusU = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TrafficRuleDescriptorFilterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FLOW = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PACKET = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TrafficFilter
	{
		
		/// <summary>
		/// Used to match all IPv4 packets that have the same DSCP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dSCP")]
		public System.Nullable<System.Int32> DSCP { get; set; }
		
		/// <summary>
		/// A IP address or a range of IP addresses.For IPv4, the IP address could be an IP address plus mask, or an individual IP address, or a range of IP addresses.For IPv6, the IP address could be an IP prefix, or a range of IP prefixes.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstAddress")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] DstAddress { get; set; }
		
		/// <summary>
		/// A port or a range of ports.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstPort")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] DstPort { get; set; }
		
		/// <summary>
		/// Used for GTP tunnel based traffic rule.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dstTunnelPort")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] DstTunnelPort { get; set; }
		
		/// <summary>
		/// Specify the protocol of the traffic filter.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] Protocol { get; set; }
		
		/// <summary>
		/// Used to match all packets that have the same QCI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="qCI")]
		public System.Nullable<System.Int32> QCI { get; set; }
		
		/// <summary>
		/// An IP address or a range of IP addresses.For IPv4, the IP address could be an IP address plus mask, or an individual IP address, or a range of IP addresses.For IPv6, the IP address could be an IP prefix, or a range of IP prefixes.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcAddress")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] SrcAddress { get; set; }
		
		/// <summary>
		/// A port or a range of ports.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPort")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] SrcPort { get; set; }
		
		/// <summary>
		/// Used for GTP tunnel based traffic rule.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcTunnelAddress")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] SrcTunnelAddress { get; set; }
		
		/// <summary>
		/// Used for GTP tunnel based traffic rule.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcTunnelPort")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] SrcTunnelPort { get; set; }
		
		/// <summary>
		/// Used to match all IPv6 packets that have the same TC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tC")]
		public System.Nullable<System.Int32> TC { get; set; }
		
		/// <summary>
		/// Used for tag based traffic rule.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] Tag { get; set; }
		
		/// <summary>
		/// Used for GTP tunnel based traffic rule.
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tgtTunnelAddress")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public string[] TgtTunnelAddress { get; set; }
	}
	
	/// <summary>
	/// Discriminator for the different notification types
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AppPkgNotificationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPackageOnBoarded = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPacakgeEnabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPacakgeDisabled = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPackageDeleted = 3,
	}
	
	/// <summary>
	/// Operational state of the onboarded application package: Ã¢â‚¬Â¢ENABLED: the application package can be used for instantiation of new application instances. Ã¢â‚¬Â¢DISABLED: the application package cannot be used for further application instantiation requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AppPkgOperationalState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	/// <summary>
	/// Subscribed notification type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AppPkgSubscriptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPackageOnBoarding = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPacakgeOperationChange = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPackageDeletion = 2,
	}
	
	/// <summary>
	/// Additional information of application package artifacts that are not application software images. Type is TBD
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgArtifactInfo
	{
	}
	
	/// <summary>
	/// 'The data type AppPkgInfo represents the parameters for an application package resource'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgInfo
	{
		
		/// <summary>
		/// Links to resources related to this resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AppPkgInfolinks _links { get; set; }
		
		/// <summary>
		/// Additional information of application package artifacts that are not application software images. Type is TBD
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalArtifacts")]
		public AppPkgArtifactInfo AdditionalArtifacts { get; set; }
		
		/// <summary>
		/// Identifier of this MEC application descriptor. This attribute shall be globally unique.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appDId")]
		public string AppDId { get; set; }
		
		/// <summary>
		/// Identifies the version of the application descriptor.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appDVersion")]
		public string AppDVersion { get; set; }
		
		/// <summary>
		/// Name to identify the MEC application.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appName")]
		public string AppName { get; set; }
		
		/// <summary>
		/// Provider of the application and of the AppD.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appProvider")]
		public string AppProvider { get; set; }
		
		/// <summary>
		/// Software version of the application. This is updated when there is any change to the software in the onboarded application package.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appSoftwareVersion")]
		public string AppSoftwareVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="checksum")]
		public Checksum Checksum { get; set; }
		
		/// <summary>
		/// Identifier of the onboarded application package.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Onboarding state of application package
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="onboardingState")]
		public AppPkgInfoOnboardingState OnboardingState { get; set; }
		
		/// <summary>
		/// Operational state of the onboarded application package: Ã¢â‚¬Â¢ENABLED: the application package can be used for instantiation of new application instances. Ã¢â‚¬Â¢DISABLED: the application package cannot be used for further application instantiation requests.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationalState")]
		public AppPkgOperationalState OperationalState { get; set; }
		
		/// <summary>
		/// Information of application software image in application package. Type is TBD
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="softwareImages")]
		public AppPkgSWImageInfo SoftwareImages { get; set; }
		
		/// <summary>
		/// Usage state of the onboarded instance of the application package
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="usageState")]
		public AppPkgInfoUsageState UsageState { get; set; }
		
		/// <summary>
		/// 'This data type represents a list of key-value pairs. The order of the pairs in the list is not significant. In JSON, a set of key-value pairs is represented as an object. It shall comply with the provisions defined in clause 4 of IETF RFC 8259'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userDefinedData")]
		public KeyValuePairs UserDefinedData { get; set; }
	}
	
	/// <summary>
	/// Links to resources related to this resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgInfolinks
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appD")]
		public LinkType AppD { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appPkgContent")]
		public LinkType AppPkgContent { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public LinkType Self { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LinkType
	{
		
		/// <summary>
		/// URI referring to a resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Checksum
	{
		
		/// <summary>
		///  Name of the algorithm used to generate the checksum,  as defined in ETSI GS NFV-SOL 004. For example, SHA-256, SHA-512.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algorithm")]
		public string Algorithm { get; set; }
		
		/// <summary>
		/// 'String 1 The hexadecimal value of the checksum'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hash")]
		public string Hash { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AppPkgInfoOnboardingState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPLOADING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROCESSING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONBOARDED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AppPkgInfoUsageState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_USE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_IN_USE = 1,
	}
	
	/// <summary>
	/// 'This data type represents a list of key-value pairs. The order of the pairs in the list is not significant. In JSON, a set of key-value pairs is represented as an object. It shall comply with the provisions defined in clause 4 of IETF RFC 8259'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class KeyValuePairs
	{
	}
	
	/// <summary>
	/// 'The data type represents the operational state for an application package resource'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgInfoModifications
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationState")]
		public AppPkgInfoModificationsOperationState OperationState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AppPkgInfoModificationsOperationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 1,
	}
	
	/// <summary>
	/// 'This data type represents an application package management notification for informing the subscribers about onboarding application package resources. The notification is triggered when a new application package is onboarded'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgNotification
	{
		
		/// <summary>
		/// Links to resources related to this resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AppPkgNotificationlinks _links { get; set; }
		
		/// <summary>
		/// Identifier of this MEC application descriptor. This attribute shall be globally unique.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appDId")]
		public string AppDId { get; set; }
		
		/// <summary>
		/// Identifier of the onboarded application package.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appPkgId")]
		public string AppPkgId { get; set; }
		
		/// <summary>
		/// ''
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Discriminator for the different notification types
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationType")]
		public AppPkgNotificationType NotificationType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationalState")]
		public AppPkgInfoModificationsOperationState OperationalState { get; set; }
		
		/// <summary>
		/// Identifier of the subscription related to this notification.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptionId")]
		public string SubscriptionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeStamp")]
		public TimeStamp TimeStamp { get; set; }
	}
	
	/// <summary>
	/// Links to resources related to this resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgNotificationlinks
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public LinkType Subscription { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeStamp
	{
		
		/// <summary>
		/// The nanoseconds part of the Time. Time is defined as Unix-time since January 1, 1970, 00:00:00 UTC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nanoSeconds")]
		public string NanoSeconds { get; set; }
		
		/// <summary>
		/// The seconds part of the Time. Time is defined as Unix-time since January 1, 1970, 00:00:00 UTC.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seconds")]
		public string Seconds { get; set; }
	}
	
	/// <summary>
	/// Information of application software image in application package. Type is TBD
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgSWImageInfo
	{
	}
	
	/// <summary>
	/// 'The data type represents the input parameters of "subscription operation" to notification of application package management for the onboarding, or operational state change of application package.'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgSubscription
	{
		
		[System.Runtime.Serialization.DataMember(Name="appPkgFilter")]
		public string[] AppPkgFilter { get; set; }
		
		/// <summary>
		/// The URI of the endpoint for the notification to be sent to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="callbackUri")]
		public string CallbackUri { get; set; }
		
		/// <summary>
		/// 'Subscribed notification type'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subsctiptionType")]
		public AppPkgSubscriptionType SubsctiptionType { get; set; }
	}
	
	/// <summary>
	/// 'The data type represents a subscription to notification of application package management for the onboarding, or operational state change of application package'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgSubscriptionInfo
	{
		
		/// <summary>
		/// Links to resources related to this resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AppPkgSubscriptionInfolinks _links { get; set; }
		
		/// <summary>
		/// The URI of the endpoint for the notification to be sent to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="callbackUri")]
		public string CallbackUri { get; set; }
		
		/// <summary>
		/// ''
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Subscribed notification type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscriptionType")]
		public AppPkgSubscriptionType SubscriptionType { get; set; }
	}
	
	/// <summary>
	/// Links to resources related to this resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgSubscriptionInfolinks
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public LinkType Self { get; set; }
	}
	
	/// <summary>
	/// 'The data type represents a subscription link list of notification on application package management'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgSubscriptionLinkList
	{
		
		/// <summary>
		/// Links to resources related to this resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public AppPkgSubscriptionLinkListlinks _links { get; set; }
	}
	
	/// <summary>
	/// Links to resources related to this resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppPkgSubscriptionLinkListlinks
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="self")]
		public LinkType Self { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscriptions")]
		public SubscriptionsAppPkgSubscription[] Subscriptions { get; set; }
	}
	
	/// <summary>
	/// 'The data type represents the input parameters of "subscription operation" to notification of application package management for the onboarding, or operational state change of application package.'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SubscriptionsAppPkgSubscription
	{
		
		/// <summary>
		/// The URI referring to the subscription.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
		
		/// <summary>
		/// 'Subscribed notification type'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subsctiptionType")]
		public AppPkgSubscriptionType SubsctiptionType { get; set; }
	}
	
	/// <summary>
	/// See MEC011
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CategoryRef
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateAppPkg
	{
		
		/// <summary>
		/// Name of the application package to be onboarded.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appPkgName")]
		public string AppPkgName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appPkgPath")]
		public string AppPkgPath { get; set; }
		
		/// <summary>
		/// Version of the application package to be onboarded.
		///The appPkgName with appPkgVersion can be used to uniquely identify the application package.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="appPkgVersion")]
		public string AppPkgVersion { get; set; }
		
		/// <summary>
		/// The provider's name of the application package to be onboarded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appProvider")]
		public string AppProvider { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="checksum")]
		public Checksum Checksum { get; set; }
		
		/// <summary>
		/// 'This data type represents a list of key-value pairs. The order of the pairs in the list is not significant. In JSON, a set of key-value pairs is represented as an object. It shall comply with the provisions defined in clause 4 of IETF RFC 8259'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userDefinedData")]
		public KeyValuePairs UserDefinedData { get; set; }
	}
	
	/// <summary>
	/// Definition of filter type: per FLOW or PACKET
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FilterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FLOW = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PACKET = 1,
	}
	
	/// <summary>
	/// Type of interface.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum InterfaceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TUNNEL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP = 2,
	}
	
	/// <summary>
	/// Specifies the IP address type
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum IpAddressType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP_V6 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP_V4 = 1,
	}
	
	/// <summary>
	/// Onboarding state of application package
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OnboardingState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPLOADING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROCESSING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONBOARDED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ProblemDetails
	{
		
		/// <summary>
		/// A human-readable explanation specific to this occurrence of the problem
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// A URI reference that identifies the specific occurrence of the problem
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		/// <summary>
		/// The HTTP status code for this occurrence of the problem
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.UInt32> Status { get; set; }
		
		/// <summary>
		/// A short, human-readable summary of the problem type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// A URI reference according to IETF RFC 3986 that identifies the problem type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// See MEC011
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SecurityInfo
	{
	}
	
	/// <summary>
	/// 'Subscribed notification type'
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SubsctiptionTypeAppPkg
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPackageOnBoarding = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPacakgeOperationChange = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AppPackageDeletion = 2,
	}
	
	/// <summary>
	/// Type of tunnel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TunnelType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GTP-U")]
		GTPMinusU = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRE = 1,
	}
	
	/// <summary>
	/// Usage state of the onboarded instance of the application package
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UsageState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_USE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_IN_USE = 1,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Queries information relating to on-boarded application packages in the MEO
		/// queries information relating to on-boarded application packages in the MEO
		/// App_packagesGET app_packages
		/// </summary>
		/// <param name="filter">Attribute-based filtering parameters according to ETSI GS MEC 009</param>
		/// <param name="all_fields">Include all complex attributes in the response.</param>
		/// <param name="fields">Complex attributes of AppPkgInfo to be included into the response</param>
		/// <param name="exclude_fields">Complex attributes of AppPkgInfo to be excluded from the response.</param>
		/// <param name="exclude_default">Indicates to exclude the following complex attributes of AppPkgInfo from the response.</param>
		/// <returns>Contains a representation of the application package resource</returns>
		public async Task<AppPkgInfo[]> App_packagesGETAsync(string filter, string all_fields, string fields, string exclude_fields, string exclude_default, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app_packages?filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&all_fields=" + (all_fields==null? "" : System.Uri.EscapeDataString(all_fields))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&exclude_fields=" + (exclude_fields==null? "" : System.Uri.EscapeDataString(exclude_fields))+"&exclude_default=" + (exclude_default==null? "" : System.Uri.EscapeDataString(exclude_default));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AppPkgInfo[]>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a resource for on-boarding an application package to a MEO
		/// Create a resource for on-boarding an application package to a MEO
		/// App_packagesPOST app_packages
		/// </summary>
		/// <param name="requestBody">Resource to be created</param>
		public async Task App_packagesPOSTAsync(CreateAppPkg requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app_packages";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes an individual application package resources
		/// Deletes an individual application package resources
		/// App_packageDELETE app_packages/{appPkgId}
		/// </summary>
		public async Task App_packageDELETEAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app_packages/{appPkgId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Queries the information related to individual application package resources
		/// Queries the information related to individual application package resources
		/// App_packageGET app_packages/{appPkgId}
		/// </summary>
		/// <returns>Contains a representation of the application package resource</returns>
		public async Task<AppPkgInfo> App_packageGETAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app_packages/{appPkgId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AppPkgInfo>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the operational state of an individual application package resource
		/// Updates the operational state of an individual application package resources
		/// App_packagePATCH app_packages/{appPkgId}
		/// </summary>
		/// <param name="requestBody">Operational state to be set</param>
		/// <returns>Shows that the operation has been completed successfully</returns>
		public async Task<AppPkgInfoModifications> App_packagePATCHAsync(AppPkgInfoModifications requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app_packages/{appPkgId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AppPkgInfoModifications>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reads the content of the AppD of on-boarded individual application package resources.
		/// Reads the content of the AppD of on-boarded individual application package resources.
		/// AppPkgIdGET app_packages/{appPkgId}/appd
		/// </summary>
		/// <param name="filter">Attribute-based filtering parameters according to ETSI GS MEC 009</param>
		/// <param name="all_fields">Include all complex attributes in the response.</param>
		/// <param name="fields">Complex attributes of AppPkgInfo to be included into the response</param>
		/// <param name="exclude_fields">Complex attributes of AppPkgInfo to be excluded from the response.</param>
		/// <param name="exclude_default">Indicates to exclude the following complex attributes of AppPkgInfo from the response.</param>
		/// <returns>Content of the AppD is returned.</returns>
		public async Task<string> AppPkgIdGETAsync(string filter, string all_fields, string fields, string exclude_fields, string exclude_default, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app_packages/{appPkgId}/appd?filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&all_fields=" + (all_fields==null? "" : System.Uri.EscapeDataString(all_fields))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&exclude_fields=" + (exclude_fields==null? "" : System.Uri.EscapeDataString(exclude_fields))+"&exclude_default=" + (exclude_default==null? "" : System.Uri.EscapeDataString(exclude_default));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Fetch the onboarded application package content identified by appPkgId or appDId.
		/// Fetch the onboarded application package content identified by appPkgId or appDId.
		/// AppPkgGET app_packages/{appPkgId}/package_content
		/// </summary>
		/// <returns>The payload body shall contain a copy of the file representing the AppD or a ZIP file that contains the file or multiple files representing the AppD.</returns>
		public async Task AppPkgGETAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "app_packages/{appPkgId}/package_content";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reads the content of the AppD of on-boarded individual application package resources.
		/// Reads the content of the AppD of on-boarded individual application package resources.
		/// AppDGET onboarded_app_packages/{appDId}/appd
		/// </summary>
		/// <param name="filter">Attribute-based filtering parameters according to ETSI GS MEC 009</param>
		/// <param name="all_fields">Include all complex attributes in the response.</param>
		/// <param name="fields">Complex attributes of AppPkgInfo to be included into the response</param>
		/// <param name="exclude_fields">Complex attributes of AppPkgInfo to be excluded from the response.</param>
		/// <param name="exclude_default">Indicates to exclude the following complex attributes of AppPkgInfo from the response.</param>
		/// <returns>Content of the AppD is returned.</returns>
		public async Task<string> AppDGETAsync(string filter, string all_fields, string fields, string exclude_fields, string exclude_default, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "onboarded_app_packages/{appDId}/appd?filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&all_fields=" + (all_fields==null? "" : System.Uri.EscapeDataString(all_fields))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&exclude_fields=" + (exclude_fields==null? "" : System.Uri.EscapeDataString(exclude_fields))+"&exclude_default=" + (exclude_default==null? "" : System.Uri.EscapeDataString(exclude_default));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<string>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Fetch the onboarded application package content identified by appPkgId or appDId.
		/// Fetch the onboarded application package content identified by appPkgId or appDId.
		/// AppDIdGET onboarded_app_packages/{appDId}/package_content
		/// </summary>
		/// <returns>The payload body shall contain a copy of the file representing the AppD or a ZIP file that contains the file or multiple files representing the AppD.</returns>
		public async Task AppDIdGETAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "onboarded_app_packages/{appDId}/package_content";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// used to retrieve the information of subscriptions to individual application package resource in MEO
		/// used to retrieve the information of subscriptions to individual application package resource in MEO package
		/// SubscriptionsGET subscriptions
		/// </summary>
		/// <returns>List of zero or more subscriptions</returns>
		public async Task<AppPkgSubscriptionLinkList> SubscriptionsGETAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AppPkgSubscriptionLinkList>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Subscribe to notifications about on-boarding an application package
		/// Subscribe to notifications about on-boarding an application package
		/// SubscriptionsPOST subscriptions
		/// </summary>
		/// <param name="requestBody">The input parameters of subscribe operation to notifications</param>
		public async Task SubscriptionsPOSTAsync(AppPkgSubscription requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes the individual subscription to notifications about application package changes in MEO.
		/// Deletes the individual subscription to notifications about application package changes in MEO.
		/// IndividualSubscriptionDELETE subscriptions/{subscriptionId}
		/// </summary>
		public async Task IndividualSubscriptionDELETEAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions/{subscriptionId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Used to represent an individual subscription to notifications about application package changes.
		/// Used to represent an individual subscription to notifications about application package changes.
		/// IndividualSubscriptionGET subscriptions/{subscriptionId}
		/// </summary>
		/// <returns>Representation of the resource.</returns>
		public async Task<AppPkgSubscriptionInfo> IndividualSubscriptionGETAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions/{subscriptionId}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AppPkgSubscriptionInfo>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Registers a notification endpoint to notify application package operations
		/// Registers a notification endpoint to notify application package operations
		/// App_pkg_notificationPOST user_defined_notification
		/// </summary>
		/// <param name="requestBody">Notification endpoint to be created</param>
		public async Task App_pkg_notificationPOSTAsync(AppPkgNotification requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user_defined_notification";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
