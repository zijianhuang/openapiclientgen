//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Activity
	{
		
		/// <summary>
		/// Address of activity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public ResponseAddress Address { get; set; }
		
		/// <summary>
		/// Arrival date time with offset like this 1970-01-01T01:00+01:00. If you do not use time-dependent optimization, this is `null`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="arr_date_time")]
		public System.Nullable<System.DateTimeOffset> Arr_date_time { get; set; }
		
		/// <summary>
		/// Arrival time at this activity in seconds. If type is `start`, this is not available (since it makes no sense to have `arr_time` at start). However, `end_time` is available and actually means \"departure time\" at start location. It is important to note that `arr_time` does not necessarily mean \"start of underlying activity\", it solely means arrival time at activity location. If this activity has no time windows and if there are no further preparation times, `arr_time` is equal to activity start time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="arr_time")]
		public System.Nullable<System.Int64> Arr_time { get; set; }
		
		/// <summary>
		/// cumulated distance from start to this activity in m
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public System.Nullable<System.Int64> Distance { get; set; }
		
		/// <summary>
		/// cumulated driving time from start to this driver activity in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="driving_time")]
		public System.Nullable<System.Int64> Driving_time { get; set; }
		
		/// <summary>
		/// End date time with offset like this 1970-01-01T01:00+01:00. If you do not use time-dependent optimization, this is `null`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_date_time")]
		public System.Nullable<System.DateTimeOffset> End_date_time { get; set; }
		
		/// <summary>
		/// End time of and thus departure time at this activity. If type is `end`, this is not available (since it makes no sense to have an `end_time` at end) `end_time` at each activity is equal to the departure time at the activity location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="end_time")]
		public System.Nullable<System.Int64> End_time { get; set; }
		
		/// <summary>
		/// Id referring to the underlying service or shipment, i.e. the shipment or service this activity belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Array with size/capacity dimensions after this activity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="load_after")]
		public int[] Load_after { get; set; }
		
		/// <summary>
		/// Array with size/capacity dimensions before this activity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="load_before")]
		public int[] Load_before { get; set; }
		
		/// <summary>
		/// Id that refers to address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location_id")]
		public string Location_id { get; set; }
		
		/// <summary>
		/// preparation time at this activity in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preparation_time")]
		public System.Nullable<System.Int64> Preparation_time { get; set; }
		
		/// <summary>
		/// type of activity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ActivityType> Type { get; set; }
		
		/// <summary>
		/// Waiting time at this activity in seconds. A waiting time can occur if the activity has at least one time window. If `arr_time` < `time_window.earliest` a waiting time of `time_window_earliest` - `arr_time` occurs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="waiting_time")]
		public System.Nullable<System.Int64> Waiting_time { get; set; }
	}
	
	/// <summary>
	/// Address of activity
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResponseAddress
	{
		
		/// <summary>
		/// Latitude of location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Double> Lat { get; set; }
		
		/// <summary>
		/// Specifies the id of the location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location_id")]
		public string Location_id { get; set; }
		
		/// <summary>
		/// Longitude of location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lon")]
		public System.Nullable<System.Double> Lon { get; set; }
		
		/// <summary>
		/// Name of location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Access point to the (road)network. It is only available if `return_snapped_waypoints` is true (be default it is false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapped_waypoint")]
		public SnappedWaypoint Snapped_waypoint { get; set; }
		
		/// <summary>
		/// Optional parameter. Specifies a hint for each address to better snap the coordinates (lon,lat) to road network. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="street_hint")]
		public string Street_hint { get; set; }
	}
	
	/// <summary>
	/// Access point to the (road)network. It is only available if `return_snapped_waypoints` is true (be default it is false).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SnappedWaypoint
	{
		
		/// <summary>
		/// Latitude of location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Double> Lat { get; set; }
		
		/// <summary>
		/// Longitude of location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lon")]
		public System.Nullable<System.Double> Lon { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ActivityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		start = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		end = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		service = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pickupShipment = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deliverShipment = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pickup = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delivery = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="break")]
		_break = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Address
	{
		
		/// <summary>
		/// Optional parameter. Specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. Only supported for motor vehicles and OpenStreetMap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="curbside")]
		public System.Nullable<AddressCurbside> Curbside { get; set; }
		
		/// <summary>
		/// Latitude of location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public double Lat { get; set; }
		
		/// <summary>
		/// Specifies the id of the location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location_id")]
		public string Location_id { get; set; }
		
		/// <summary>
		/// Longitude of location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lon")]
		public double Lon { get; set; }
		
		/// <summary>
		/// Name of location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional parameter. Specifies a hint for each address to better snap the coordinates (lon,lat) to road network. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="street_hint")]
		public string Street_hint { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AddressCurbside
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		right = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		left = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		any = 2,
	}
	
	/// <summary>
	/// Use `objectives` instead.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Algorithm
	{
		
		[System.Runtime.Serialization.DataMember(Name="objective")]
		public System.Nullable<AlgorithmObjective> Objective { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="problem_type")]
		public System.Nullable<AlgorithmProblem_type> Problem_type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AlgorithmObjective
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		transport_time = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completion_time = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AlgorithmProblem_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		min = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="min-max")]
		minMinusmax = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BadRequest
	{
		
		/// <summary>
		/// Optional error information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hints")]
		public ErrorMessage[] Hints { get; set; }
		
		/// <summary>
		/// Short error message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// status
		/// </summary>
		[System.ComponentModel.DefaultValue("finished")]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; } = "finished";
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ErrorMessage
	{
		
		/// <summary>
		/// Details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
		
		/// <summary>
		/// error message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Cluster
	{
		
		/// <summary>
		/// Array of customer ids assigned to this specific cluster
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// Cluster size
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quantity")]
		public string Quantity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClusterConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="clustering")]
		public ClusterConfigurationClustering Clustering { get; set; }
		
		/// <summary>
		/// Specifies the response format. You can either choose `geojson` or `json`.
		/// </summary>
		[System.ComponentModel.DefaultValue("json")]
		[System.Runtime.Serialization.DataMember(Name="response_type")]
		public string Response_type { get; set; } = "json";
		
		[System.Runtime.Serialization.DataMember(Name="routing")]
		public ClusterConfigurationRouting Routing { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClusterConfigurationClustering
	{
		
		/// <summary>
		/// Specifies max. quantity in a cluster
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_quantity")]
		public string Max_quantity { get; set; }
		
		/// <summary>
		/// Specifies min. quantity in a cluster
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="min_quantity")]
		public string Min_quantity { get; set; }
		
		/// <summary>
		/// Specifies the number of clusters
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="num_clusters")]
		public string Num_clusters { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClusterConfigurationRouting
	{
		
		/// <summary>
		/// Cost per meter (travel distance)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost_per_meter")]
		public System.Nullable<System.Double> Cost_per_meter { get; set; }
		
		/// <summary>
		/// Cost per second (travel time)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost_per_second")]
		public System.Nullable<System.Double> Cost_per_second { get; set; }
		
		/// <summary>
		/// The routing profile for which the travel times and distances should be calculated. Other profiles are listed [here](#section/Map-Data-and-Routing-Profiles/OpenStreetMap)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public string Profile { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClusterCustomer
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public ClusterCustomerAddress Address { get; set; }
		
		/// <summary>
		/// id of customer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// demand of customer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quantity")]
		public string Quantity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClusterCustomerAddress
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Double> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lon")]
		public System.Nullable<System.Double> Lon { get; set; }
		
		/// <summary>
		/// Optional parameter. Specifies a hint for each address to better snap the coordinates (lon,lat) to road network. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="street_hint")]
		public string Street_hint { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClusterRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="configuration")]
		public ClusterConfiguration Configuration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="customers")]
		public ClusterCustomer[] Customers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClusterResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="clusters")]
		public Cluster[] Clusters { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="copyrights")]
		public string[] Copyrights { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="processing_time")]
		public System.Nullable<System.Double> Processing_time { get; set; }
		
		/// <summary>
		/// Indicates the current status of the job
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ClusterResponseStatus> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="waiting_time_in_queue")]
		public System.Nullable<System.Double> Waiting_time_in_queue { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ClusterResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		waiting_in_queue = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		processing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		finished = 2,
	}
	
	/// <summary>
	/// Specifies general configurations that are taken into account when solving the vehicle routing problem.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Configuration
	{
		
		/// <summary>
		/// This contains all routing specific configurations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routing")]
		public Routing Routing { get; set; }
	}
	
	/// <summary>
	/// This contains all routing specific configurations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Routing
	{
		
		/// <summary>
		/// It lets you specify whether the API should provide you with route geometries for vehicle routes or not. Thus, you do not need to do extra routing to get the polyline for each route.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="calc_points")]
		public System.Nullable<System.Boolean> Calc_points { get; set; }
		
		/// <summary>
		/// indicates whether historical traffic information should be considered
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consider_traffic")]
		public System.Nullable<System.Boolean> Consider_traffic { get; set; }
		
		/// <summary>
		/// In some cases curbside constraints cannot be fulfilled. For example in one-way streets you cannot arrive at a building that is on the left side of the street such that the building is to the right of you (unless you drove the one-way street the wrong/illegal way). You can set the `curbside_strictness` to `soft` to ignore the curbside constraint in such cases or set it to `strict` to get an error response instead. You can also set it to `ignore` to ignore all curbside constraints (this is useful to compare the results with and without constraints without modifying every single address).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="curbside_strictness")]
		public System.Nullable<RoutingCurbside_strictness> Curbside_strictness { get; set; }
		
		/// <summary>
		/// indicates whether matrix calculation should fail fast when points cannot be connected
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fail_fast")]
		public System.Nullable<System.Boolean> Fail_fast { get; set; }
		
		/// <summary>
		/// specifies the data provider, read more about it [here](#section/Map-Data-and-Routing-Profiles).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network_data_provider")]
		public System.Nullable<RoutingNetwork_data_provider> Network_data_provider { get; set; }
		
		/// <summary>
		/// Indicates whether a solution includes snapped waypoints. In contrary to the address coordinate a snapped waypoint is the access point to the (road) network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="return_snapped_waypoints")]
		public System.Nullable<System.Boolean> Return_snapped_waypoints { get; set; }
		
		/// <summary>
		/// Prevents snapping locations to road links of specified road types, e.g. to motorway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snap_preventions")]
		public string[] Snap_preventions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RoutingCurbside_strictness
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		soft = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		strict = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RoutingNetwork_data_provider
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		openstreetmap = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tomtom = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CostMatrix
	{
		
		/// <summary>
		/// JSON data of matrix response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public CostMatrixData Data { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location_ids")]
		public string[] Location_ids { get; set; }
		
		/// <summary>
		/// vehicle profile or empty if catch all fallback
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public string Profile { get; set; }
		
		/// <summary>
		/// type of cost matrix, currently default or google are supported
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<CostMatrixType> Type { get; set; }
	}
	
	public class CostMatrixData
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distances")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Distances { get; set; }
		
		/// <summary>
		/// Additional information for your request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="info")]
		public CostMatrixDataInfo Info { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="times")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Times { get; set; }
	}
	
	public class CostMatrixDataInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="copyrights")]
		public string[] Copyrights { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="took")]
		public System.Nullable<System.Double> Took { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CostMatrixType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		google = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Detail
	{
		
		/// <summary>
		/// Reason code
		///
		///Code   |  Reason
		///:------|:---------
		///1 | cannot serve required skill
		///2 | cannot be visited within time window
		///3 | does not fit into any vehicle due to capacity
		///4 | cannot be assigned due to max distance constraint of vehicles
		///21 | could not be assigned due to relation constraint
		///22 | could not be assigned due to allowed vehicle constraint
		///23 | could not be assigned due to max-time-in-vehicle constraint
		///24 | driver does not need a break
		///25 | could not be assigned due to disallowed vehicle constraint
		///26 | could not be assigned due to max drive time constraint
		///27 | could not be assigned due to max job constraint
		///28 | could not be assigned due to max activity constraint
		///50 | underlying location cannot be accessed over road network by at least one vehicle
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// Id of unassigned service/shipment
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Human readable reason as listed above
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DriveTimeBreak
	{
		
		/// <summary>
		/// Specifies the duration of the break in seconds.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public long Duration { get; set; }
		
		/// <summary>
		/// Specifies the initial (current) driving time of a driver to allow dynamic adaptations in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initial_driving_time")]
		public System.Nullable<System.Int64> Initial_driving_time { get; set; }
		
		/// <summary>
		/// Specifies the max driving time (in a row) without break in seconds.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_driving_time")]
		public long Max_driving_time { get; set; }
		
		/// <summary>
		/// Array specifying how a break duration (in seconds) can be split into several smaller breaks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="possible_split")]
		public int[] Possible_split { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GHError
	{
		
		/// <summary>
		/// Optional error information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hints")]
		public GHErrorHints[] GHErrorHints { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class GHErrorHints
	{
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GeocodingLocation
	{
		
		/// <summary>
		/// The city of the address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// The country of the address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// The housenumber of the address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="housenumber")]
		public string Housenumber { get; set; }
		
		/// <summary>
		/// The name of the entity. Can be a boundary, POI, address, etc
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The OSM ID of the entity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osm_id")]
		public string Osm_id { get; set; }
		
		/// <summary>
		/// The OSM key of the entity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osm_key")]
		public string Osm_key { get; set; }
		
		/// <summary>
		/// N = node, R = relation, W = way
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osm_type")]
		public string Osm_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="point")]
		public GeocodingPoint Point { get; set; }
		
		/// <summary>
		/// The postcode of the address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postcode")]
		public string Postcode { get; set; }
		
		/// <summary>
		/// The state of the address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// The street of the address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="street")]
		public string Street { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GeocodingPoint
	{
		
		/// <summary>
		/// Latitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lat")]
		public System.Nullable<System.Double> Lat { get; set; }
		
		/// <summary>
		/// Longitude
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lng")]
		public System.Nullable<System.Double> Lng { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GeocodingResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="hits")]
		public GeocodingLocation[] Hits { get; set; }
		
		/// <summary>
		/// in ms
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="took")]
		public string Took { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GroupRelation
	{
		
		/// <summary>
		/// An array of groups that should be related
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public string[] Groups { get; set; }
		
		/// <summary>
		/// Specifies the type of relation. It must be either of type `in_sequence` or `in_direct_sequence`.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Information about the server and the geographical area that it covers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InfoResponse
	{
		
		/// <summary>
		/// The bounding box of the geographical area covered by this GraphHopper instance. Format: `"minLon,minLat,maxLon,maxLat"
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bbox")]
		public string Bbox { get; set; }
		
		/// <summary>
		/// The supported features, such as elevation, per vehicle profile.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="features")]
		public string Features { get; set; }
		
		/// <summary>
		/// The version of the GraphHopper server that provided this response. This is not related to the API version.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InternalErrorMessage
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// Details
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IsochroneResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="copyrights")]
		public string[] Copyrights { get; set; }
		
		/// <summary>
		/// The list of polygons in GeoJson format. It can be used e.g. in the Leaflet framework:
		///
		///```
		///L.geoJson(json.polygons).addTo(map)
		///```
		///
		///The number of polygon is identical to the specified buckets in the query. Every polygon contains the bucket number in the properties section of the GeoJson.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="polygons")]
		public IsochroneResponsePolygon[] Polygons { get; set; }
	}
	
	/// <summary>
	/// A found path
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IsochroneResponsePolygon
	{
		
		[System.Runtime.Serialization.DataMember(Name="geometry")]
		public Polygon Geometry { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public IsochroneResponsePolygonProperties Properties { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Polygon
	{
		
		[System.Runtime.Serialization.DataMember(Name="coordinates")]
		public string[] Coordinates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class IsochroneResponsePolygonProperties
	{
		
		[System.Runtime.Serialization.DataMember(Name="bucket")]
		public System.Nullable<System.Int32> Bucket { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobId
	{
		
		/// <summary>
		/// UUID. Unique id for your job/request with which you can fetch your solution
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="job_id")]
		public string Job_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobRelation
	{
		
		/// <summary>
		/// Specifies an array of shipment and/or service ids that are in relation. If you deal with services then you need to use the id of your services in ids. To also consider sequences of the pickups and deliveries of your shipments, you need to use a special ID, i.e. use your shipment id plus the keyword `_pickup` or `_delivery`. If you want to place a service or shipment activity at the beginning of your route, use the special ID `start`. In turn, use `end` to place it at the end of the route.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public string[] Ids { get; set; }
		
		/// <summary>
		/// Specifies the type of relation. It must be either of type `in_same_route`, `in_sequence` or `in_direct_sequence`.
		///
		///`in_same_route`: As the name suggest, it enforces the specified services or shipments to be in the same route. It can be specified as follows:
		///
		///```json
		///{
		///   "type": "in_same_route",
		///   "ids": ["serv_i_id","serv_j_id"]
		///}
		///```
		///
		///This enforces service i to be in the same route as service j no matter which vehicle will be employed. If a specific vehicle (driver) is required to conduct this, just add a `vehicle_id` like this:
		///
		///```
		///{
		///   "type": "in_same_route",
		///   "ids": ["serv_i_id","serv_j_id"],
		///   "vehicle_id": "vehicle1"
		///}
		///```
		///
		///This not only enforce service i and j to be in the same route, but also makes sure that both services are in the route of `vehicle1`.
		///
		///*Tip*: This way initial loads and vehicle routes can be modelled. For example, if your vehicles are already on the road and new orders come in, then vehicles can still be rescheduled subject to the orders that have already been assigned to these vehicles.
		///
		///
		///
		///`in_sequence`: This relation type enforces n jobs to be in sequence. It can be specified as
		///
		///```json
		///{
		///   "type": "in_sequence",
		///   "ids": ["serv_i_id","serv_j_id"]
		///}
		///```
		///
		///which means that service j need to be in the same route as service i AND it needs to occur somewhere after service i. As described above if a specific vehicle needs to conduct this, just add `vehicle_id`.
		///
		///
		///`in_direct_sequence`: This enforces n services or shipments to be in direct sequence. It can be specified as
		///
		///```json
		///{
		///   "type": "in_direct_sequence",
		///   "ids": ["serv_i_id","serv_j_id","serv_k_id"]
		///}
		///```
		///
		///yielding service j to occur directly after service i, and service k to occur directly after service j i.e. in strong order. Again, a vehicle can be assigned a priority by adding a `vehicle_id` to the relation.
		///
		///
		///*Special IDs*:
		///If you look at the previous example and you want service i to be the first in the route, use the special ID `start` as follows:
		///
		///```json
		///{
		///   "type": "in_direct_sequence",
		///   "ids": ["start","serv_i_id","serv_j_id","serv_k_id"]
		///}
		///```
		///
		///Latter enforces the direct sequence of i, j and k at the beginning of the route. If this sequence should be bound to the end of the route, use the special ID `end` like this:
		///
		///```json
		///{
		///   "type": "in_direct_sequence",
		///   "ids": ["serv_i_id","service_j_id","serv_k_id","end"]
		///}
		///```
		///
		///If you deal with services then you need to use the 'id' of your services in the field 'ids'. To also consider sequences of the pickups and deliveries of your shipments, you need to use a special ID, i.e. use the shipment id plus the keyword `_pickup` or `_delivery`. For example, to ensure that the pickup and delivery of the shipment with the id 'my_shipment' are direct neighbors, you need the following specification:
		///
		///```
		///{
		///   "type": "in_direct_sequence",
		///   "ids": ["my_ship_pickup","my_ship_delivery"]
		///}
		///```
		///
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Id of pre-assigned vehicle, i.e. the vehicle id that is determined to conduct the services and shipments in this relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vehicle_id")]
		public string Vehicle_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LineString
	{
		
		/// <summary>
		/// A list of coordinate pairs or triples, `[lon,lat]` or `[lon,lat,elevation]`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coordinates")]
		public string[] Coordinates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MatrixRequest
	{
		
		/// <summary>
		/// Specifies whether or not the matrix calculation should return with an error as soon as possible in case some points cannot be found or some points are not connected. If set to `false` the time/weight/distance matrix will be calculated for all valid points and contain the `null` value for all entries that could not be calculated. The `hint` field of the response will also contain additional information about what went wrong (see its documentation).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fail_fast")]
		public System.Nullable<System.Boolean> Fail_fast { get; set; }
		
		/// <summary>
		/// See `curbsides`of symmetrical matrix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from_curbsides")]
		public string[] From_curbsides { get; set; }
		
		/// <summary>
		/// See `point_hints`of symmetrical matrix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from_point_hints")]
		public string[] From_point_hints { get; set; }
		
		/// <summary>
		/// The starting points for the routes in an array of `[longitude,latitude]`. For instance, if you want to calculate three routes from point A such as A->1, A->2, A->3 then you have one `from_point` parameter and three `to_point` parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from_points")]
		public string[] From_points { get; set; }
		
		/// <summary>
		/// Specifies which matrices should be included in the response. Specify one or more of the following options `weights`, `times`, `distances`. The units of the entries of `distances` are meters, of `times` are seconds and of `weights` is arbitrary and it can differ for different vehicles or versions of this API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="out_arrays")]
		public string[] Out_arrays { get; set; }
		
		/// <summary>
		/// See `snap_preventions` of symmetrical matrix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snap_preventions")]
		public string[] Snap_preventions { get; set; }
		
		/// <summary>
		/// See `curbsides`of symmetrical matrix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to_curbsides")]
		public string[] To_curbsides { get; set; }
		
		/// <summary>
		/// See `point_hints`of symmetrical matrix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to_point_hints")]
		public string[] To_point_hints { get; set; }
		
		/// <summary>
		/// The destination points for the routes in an array of `[longitude,latitude]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to_points")]
		public string[] To_points { get; set; }
		
		/// <summary>
		/// Specifies if turn restrictions should be considered. Enabling this option increases the matrix computation time. Only supported for motor vehicles and OpenStreetMap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="turn_costs")]
		public System.Nullable<System.Boolean> Turn_costs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vehicle")]
		public VehicleProfileId Vehicle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum VehicleProfileId
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		car = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		bike = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		foot = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hike = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		mtb = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		racingbike = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		scooter = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		truck = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		small_truck = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MatrixResponse
	{
		
		/// <summary>
		/// The distance matrix for the specified points in the same order as the time matrix. The distances are in meters. If `fail_fast=false` the matrix will contain `null` for connections that could not be found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distances")]
		public string[] Distances { get; set; }
		
		/// <summary>
		/// Optional. Additional response data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hints")]
		public MatrixResponseHints[] MatrixResponseHints { get; set; }
		
		/// <summary>
		/// Additional information for your request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="info")]
		public ResponseInfo Info { get; set; }
		
		/// <summary>
		/// The time matrix for the specified points in the order [[from1->to1, from1->to2, ...], [from2->to1, from2->to2, ...], ...]. The times are in seconds. If `fail_fast=false` the matrix will contain `null` for connections that could not be found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="times")]
		public string[] Times { get; set; }
		
		/// <summary>
		/// The weight matrix for the specified points in the same order as the time matrix. The weights for different vehicles can have a different unit but the weights array is perfectly suited as input for Vehicle Routing Problems as it is currently faster to calculate. If `fail_fast=false` the matrix will contain `null` for connections that could not be found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weights")]
		public string[] Weights { get; set; }
	}
	
	public class MatrixResponseHints
	{
		
		/// <summary>
		/// Details of this hint
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
		
		/// <summary>
		/// Optional. An array of from_point indices of points that could not be found. Will only be added if `fail_fast=false` and some `from_point`s were not found.`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invalid_from_points")]
		public double[] Invalid_from_points { get; set; }
		
		/// <summary>
		/// Optional. An array of to_point indices of points that could not be found. Will only be added if `fail_fast=false` and some `to_point`s were not found.`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invalid_to_points")]
		public double[] Invalid_to_points { get; set; }
		
		/// <summary>
		/// Short description of this hint
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Optional. An array of two-element arrays representing the from/to_point indices of points for which no connection could be found. Will only be added if `fail_fast=false` and some connections were not found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="point_pairs")]
		public string[] Point_pairs { get; set; }
	}
	
	/// <summary>
	/// Additional information for your request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResponseInfo
	{
		
		/// <summary>
		/// Attribution according to our documentation is necessary if no white-label option included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copyrights")]
		public string[] Copyrights { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="took")]
		public System.Nullable<System.Double> Took { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Objective
	{
		
		/// <summary>
		/// Type of objective function, i.e. `min` or `min-max`.
		///
		/// * `min`: Minimizes the objective value.
		/// * `min-max`: Minimizes the maximum objective value.
		///
		///For instance, `min` -> `vehicles` minimizes the number of employed vehicles.
		///`min` -> `completion_time` minimizes the sum of your vehicle routes' completion time.
		///
		///If you use, for example, `min-max` -> `completion_time`, it minimizes the maximum of your vehicle routes' completion time, i.e. it minimizes the overall makespan.
		///This only makes sense if you have more than one vehicle. In case of one vehicle, switching from `min` to `min-max` should not have any impact.
		///If you have more than one vehicle, then the algorithm tries to constantly move stops from one vehicle to another such that
		///the completion time of longest vehicle route can be further reduced. For example, if you have one vehicle that takes 8 hours
		///to serve all customers, adding another vehicle (and using `min-max`) might halve the time to serve all customers to 4 hours. However,
		///this usually comes with higher transport costs.
		///
		///If you want to minimize `vehicles` first and, second, `completion_time`, you can also combine different objectives like this:
		///
		///```json
		///"objectives" : [
		///   {
		///      "type": "min",
		///      "value": "vehicles"
		///   },
		///   {
		///      "type": "min",
		///      "value": "completion_time"
		///   }
		///]
		///```
		///
		///If you want to balance activities or the number of stops among all employed drivers, you need to specify it as follows:
		///
		///```json
		///"objectives" : [
		///   {
		///      "type": "min-max",
		///      "value": "completion_time"
		///   },
		///   {
		///      "type": "min-max",
		///      "value": "activities"
		///   }
		///]
		///```
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(ObjectiveType.min)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ObjectiveType Type { get; set; } = ObjectiveType.min;
		
		/// <summary>
		/// The value of the objective function.
		///The objective value `transport_time` solely considers the time
		///your drivers spend on the road, i.e. transport time. In contrary to `transport_time`, `completion_time` also takes waiting times at customer sites into account.
		///The `completion_time` of a route is defined as the time from starting to ending the route,
		///i.e. the route's transport time, the sum of waiting times plus the sum of activity durations.
		///Note that choosing `transport_time` or `completion_time` only makes a difference if you specified time windows for your services/shipments since only in
		///scenarios with time windows waiting times can occur.
		///The objective value `vehicles` can only be used along with `min` and minimizes vehicles.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(ObjectiveValue.transport_time)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public ObjectiveValue Value { get; set; } = ObjectiveValue.transport_time;
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ObjectiveType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		min = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="min-max")]
		minMinusmax = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ObjectiveValue
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		completion_time = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		transport_time = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vehicles = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		activities = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Pickup
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public Address Address { get; set; }
		
		/// <summary>
		/// Specifies the duration of the pickup or delivery in seconds, e.g. how long it takes unload items at the customer site.
		/// Minimum: 0
		/// Maximum: 604800
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		[System.ComponentModel.DataAnnotations.Range(0, 604800)]
		public System.Nullable<System.Int64> Duration { get; set; }
		
		/// <summary>
		/// Group this stop belongs to. See the group relation and [this post](https://discuss.graphhopper.com/t/4040) on how to utilize this.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// Specifies the preparation time in seconds. It can be used to model parking lot search time since if you have 3 identical locations in a row, it only falls due once.
		/// Minimum: 0
		/// Maximum: 604800
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preparation_time")]
		[System.ComponentModel.DataAnnotations.Range(0, 604800)]
		public System.Nullable<System.Int64> Preparation_time { get; set; }
		
		/// <summary>
		/// Specifies an array of time window objects (see time window object below). For example, if an item needs to be delivered between 7am and 10am then specify the array as follows: [ { "earliest": 25200, "latest" : 32400 } ] (starting the day from 0 in seconds).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time_windows")]
		public TimeWindow[] Time_windows { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeWindow
	{
		
		/// <summary>
		/// Specifies the opening time of the time window in seconds, i.e. the earliest time the service can start.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="earliest")]
		public System.Nullable<System.Int64> Earliest { get; set; }
		
		/// <summary>
		/// Specifies the closing time of the time window in seconds, i.e. the latest time the service can start.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latest")]
		public System.Nullable<System.Int64> Latest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Request
	{
		
		/// <summary>
		/// Use `objectives` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="algorithm")]
		public Algorithm Algorithm { get; set; }
		
		/// <summary>
		/// Specifies general configurations that are taken into account when solving the vehicle routing problem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configuration")]
		public Configuration Configuration { get; set; }
		
		/// <summary>
		/// Specifies your own tranport time and distance matrices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost_matrices")]
		public CostMatrix[] Cost_matrices { get; set; }
		
		/// <summary>
		/// Specifies an objective function. The vehicle routing problem is solved in such a way that this objective function is minimized.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectives")]
		public Objective[] Objectives { get; set; }
		
		/// <summary>
		/// Defines additional relationships between orders.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relations")]
		public string[] Relations { get; set; }
		
		/// <summary>
		/// Specifies the orders of the type "service". These are, for example, pick-ups, deliveries or other stops that are to be approached by the specified vehicles. Each of these orders contains only one location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="services")]
		public Service[] Services { get; set; }
		
		/// <summary>
		/// Specifies the available shipments. Each shipment contains a pickup and a delivery stop, which must be processed one after the other.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shipments")]
		public Shipment[] Shipments { get; set; }
		
		/// <summary>
		/// Specifies the available vehicle types. These types can be assigned to vehicles.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vehicle_types")]
		public VehicleType[] Vehicle_types { get; set; }
		
		/// <summary>
		/// Specifies the available vehicles.
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vehicles")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public Vehicle[] Vehicles { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Service
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public Address Address { get; set; }
		
		/// <summary>
		/// Specifies an array of allowed vehicles, i.e. array of vehicle ids. For example, if this service can only be conducted EITHER by `technician_peter` OR `technician_stefan` specify this as follows: `["technician_peter","technician_stefan"]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed_vehicles")]
		public string[] Allowed_vehicles { get; set; }
		
		/// <summary>
		/// Specifies an array of disallowed vehicles, i.e. array of vehicle ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disallowed_vehicles")]
		public string[] Disallowed_vehicles { get; set; }
		
		/// <summary>
		/// Specifies the duration of the service in seconds, i.e. how long it takes at the customer site.
		/// Minimum: 0
		/// Maximum: 604800
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		[System.ComponentModel.DataAnnotations.Range(0, 604800)]
		public System.Nullable<System.Int64> Duration { get; set; }
		
		/// <summary>
		/// Group this service belongs to. See the group relation and [this post](https://discuss.graphhopper.com/t/4040) on how to utilize this.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// Specifies the id of the service. Ids need to be unique so there must not be two services/shipments with the same id.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Specifies the maximum time in seconds a delivery can stay in the vehicle. Currently, it only works with services of "type":"delivery".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_time_in_vehicle")]
		public System.Nullable<System.Int64> Max_time_in_vehicle { get; set; }
		
		/// <summary>
		/// Meaningful name for service, e.g. `"deliver pizza"`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies the preparation time in seconds. It can be used to model parking lot search time since if you have 3 identical locations in a row, it only falls due once.
		/// Minimum: 0
		/// Maximum: 604800
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preparation_time")]
		[System.ComponentModel.DataAnnotations.Range(0, 604800)]
		public System.Nullable<System.Int64> Preparation_time { get; set; }
		
		/// <summary>
		/// Specifies the priority. Can be 1 = high priority to 10 = low priority. Often there are more services/shipments than the available vehicle fleet can handle. Then you can set priorities to differentiate high priority tasks from those that could be left unassigned. I.e. the lower the priority the earlier these tasks are omitted in the solution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// Specifies an array of required skills, i.e. array of string (not case sensitive). For example, if this service needs to be conducted by a technician having a `drilling_machine` and a `screw_driver` then specify the array as follows: `["drilling_machine","screw_driver"]`. This means that the service can only be done by a vehicle (technician) that has the skills `drilling_machine` AND `screw_driver` in its skill array. Otherwise it remains unassigned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_skills")]
		public string[] Required_skills { get; set; }
		
		/// <summary>
		/// Size can have multiple dimensions and should be in line with the capacity dimension array of the vehicle type. For example, if the item that needs to be delivered has two size dimension, volume and weight, then specify it as follow [ 20, 5 ] assuming a volume of 20 and a weight of 5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int[] Size { get; set; }
		
		/// <summary>
		/// Specifies an array of time window objects (see time_window object below). Specify the time either with the recommended Unix time stamp (the number of seconds since 1970-01-01) or you can also count the seconds relative to Monday morning 00:00 and define the whole week in seconds. For example, Monday 9am is then represented by 9hour * 3600sec/hour = 32400. In turn, Wednesday 1pm corresponds to 2day * 24hour/day * 3600sec/hour + 1day * 13hour/day * 3600sec/hour = 219600. See this tutorial for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time_windows")]
		public TimeWindow[] Time_windows { get; set; }
		
		/// <summary>
		/// Specifies type of service. This makes a difference if items are loaded or unloaded, i.e. if one of the size dimensions > 0. If it is specified as `service` or `pickup`, items are loaded and will stay in the vehicle for the rest of the route (and thus consumes capacity for the rest of the route). If it is a `delivery`, items are implicitly loaded at the beginning of the route and will stay in the route until delivery (and thus releases capacity for the rest of the route).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ServiceType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ServiceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		service = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pickup = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delivery = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Shipment
	{
		
		/// <summary>
		/// Specifies an array of allowed vehicles, i.e. array of vehicle ids. For example, if this shipment can only be conducted EITHER by "technician_peter" OR "technician_stefan" specify this as follows: ["technician_peter","technician_stefan"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed_vehicles")]
		public string[] Allowed_vehicles { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delivery")]
		public Stop Delivery { get; set; }
		
		/// <summary>
		/// Specifies an array of disallowed vehicles, i.e. array of vehicle ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disallowed_vehicles")]
		public string[] Disallowed_vehicles { get; set; }
		
		/// <summary>
		/// Specifies the id of the shipment. Ids need to be unique so there must not be two services/shipments with the same id.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Specifies the maximum time in seconds a shipment can stay in the vehicle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_time_in_vehicle")]
		public System.Nullable<System.Int64> Max_time_in_vehicle { get; set; }
		
		/// <summary>
		/// Meaningful name for shipment, e.g. "pickup and deliver pizza to Peter".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pickup")]
		public Stop Pickup { get; set; }
		
		/// <summary>
		/// Specifies the priority. Can be 1 = high priority to 10 = low priority. Often there are more services/shipments than the available vehicle fleet can handle. Then you can set priorities to differentiate high priority tasks from those that could be left unassigned. I.e. the lower the priority the earlier these tasks are omitted in the solution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// Specifies an array of required skills, i.e. array of string (not case sensitive). For example, if this shipment needs to be conducted by a technician having a `drilling_machine` and a `screw_driver` then specify the array as follows: `["drilling_machine","screw_driver"]`. This means that the service can only be done by a vehicle (technician) that has the skills `drilling_machine` AND `screw_driver` in its skill array. Otherwise it remains unassigned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required_skills")]
		public string[] Required_skills { get; set; }
		
		/// <summary>
		/// Size can have multiple dimensions and should be in line with the capacity dimension array of the vehicle type. For example, if the item that needs to be delivered has two size dimension, volume and weight, then specify it as follow [ 20, 5 ] assuming a volume of 20 and a weight of 5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int[] Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Stop
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public Address Address { get; set; }
		
		/// <summary>
		/// Specifies the duration of the pickup or delivery in seconds, e.g. how long it takes unload items at the customer site.
		/// Minimum: 0
		/// Maximum: 604800
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		[System.ComponentModel.DataAnnotations.Range(0, 604800)]
		public System.Nullable<System.Int64> Duration { get; set; }
		
		/// <summary>
		/// Group this stop belongs to. See the group relation and [this post](https://discuss.graphhopper.com/t/4040) on how to utilize this.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// Specifies the preparation time in seconds. It can be used to model parking lot search time since if you have 3 identical locations in a row, it only falls due once.
		/// Minimum: 0
		/// Maximum: 604800
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preparation_time")]
		[System.ComponentModel.DataAnnotations.Range(0, 604800)]
		public System.Nullable<System.Int64> Preparation_time { get; set; }
		
		/// <summary>
		/// Specifies an array of time window objects (see time window object below). For example, if an item needs to be delivered between 7am and 10am then specify the array as follows: [ { "earliest": 25200, "latest" : 32400 } ] (starting the day from 0 in seconds).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time_windows")]
		public TimeWindow[] Time_windows { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VehicleType
	{
		
		/// <summary>
		/// Specifies an array of capacity dimension values which need to be int values. For example, if there are two dimensions such as volume and weight then it needs to be defined as [ 1000, 300 ] assuming a maximum volume of 1000 and a maximum weight of 300.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capacity")]
		public int[] Capacity { get; set; }
		
		/// <summary>
		/// Specifies whether traffic should be considered. if "tomtom" is used and this is false, free flow travel times from "tomtom" are calculated. If this is true, historical traffic info are used. We do not yet have traffic data for "openstreetmap", thus, setting this true has no effect at all.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consider_traffic")]
		public System.Nullable<System.Boolean> Consider_traffic { get; set; }
		
		/// <summary>
		/// **_BETA feature_**! Cost parameter vehicle activation, i.e. fixed costs per vehicle
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost_per_activation")]
		public System.Nullable<System.Double> Cost_per_activation { get; set; }
		
		/// <summary>
		/// **_BETA feature_**! Cost parameter per distance unit, here meter is used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost_per_meter")]
		public System.Nullable<System.Double> Cost_per_meter { get; set; }
		
		/// <summary>
		/// **_BETA feature_**! Cost parameter per time unit, here second is used
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cost_per_second")]
		public System.Nullable<System.Double> Cost_per_second { get; set; }
		
		/// <summary>
		/// Specifies the network data provider. Either use [`openstreetmap`](#section/Map-Data-and-Routing-Profiles/OpenStreetMap) (default) or [`tomtom`](#section/Map-Data-and-Routing-Profiles/TomTom) (add-on required).
		/// </summary>
		[System.ComponentModel.DefaultValue(RoutingNetwork_data_provider.openstreetmap)]
		[System.Runtime.Serialization.DataMember(Name="network_data_provider")]
		public RoutingNetwork_data_provider Network_data_provider { get; set; } = RoutingNetwork_data_provider.openstreetmap;
		
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public object Profile { get; set; }
		
		/// <summary>
		/// Specifies a service time factor for this vehicle type. If the vehicle/driver that uses this type is able to conduct the service as double as fast as it is determined in the corresponding service or shipment then set it to 0.5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service_time_factor")]
		public System.Nullable<System.Double> Service_time_factor { get; set; }
		
		/// <summary>
		/// Specifies a speed factor for this vehicle type. If the vehicle that uses this type needs to be only half as fast as what is actually calculated with our routing engine then set the speed factor to 0.5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="speed_factor")]
		public System.Nullable<System.Double> Speed_factor { get; set; }
		
		/// <summary>
		/// Specifies the id of the vehicle type. If a vehicle needs to be of this type, it should refer to this with its type_id attribute.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type_id")]
		public string Type_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Vehicle
	{
		
		[System.Runtime.Serialization.DataMember(Name="break")]
		public TimeWindowBreak Break { get; set; }
		
		/// <summary>
		/// Earliest start of vehicle in seconds. It is recommended to use the unix timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="earliest_start")]
		public System.Nullable<System.Int64> Earliest_start { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="end_address")]
		public Address End_address { get; set; }
		
		/// <summary>
		/// Latest end of vehicle in seconds, i.e. the time the vehicle needs to be at its end location at latest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latest_end")]
		public System.Nullable<System.Int64> Latest_end { get; set; }
		
		/// <summary>
		/// Specifies the maximum number of activities a vehicle can conduct.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_activities")]
		public System.Nullable<System.Int32> Max_activities { get; set; }
		
		/// <summary>
		/// Specifies the maximum distance (in meters) a vehicle can go.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_distance")]
		public System.Nullable<System.Int64> Max_distance { get; set; }
		
		/// <summary>
		/// Specifies the maximum drive time (in seconds) a vehicle/driver can go, i.e. the maximum time on the road (service and waiting times are not included here)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_driving_time")]
		public System.Nullable<System.Int64> Max_driving_time { get; set; }
		
		/// <summary>
		/// Specifies the maximum number of jobs a vehicle can load.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_jobs")]
		public System.Nullable<System.Int32> Max_jobs { get; set; }
		
		/// <summary>
		/// Specifies the minimum number of jobs a vehicle should load. This is a soft constraint, i.e. if it is not possible to fulfill min_jobs, we will still try to get as close as possible to this constraint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="min_jobs")]
		public System.Nullable<System.Int32> Min_jobs { get; set; }
		
		/// <summary>
		/// Indicates whether a vehicle should be moved even though it has not been assigned any jobs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="move_to_end_address")]
		public System.Nullable<System.Boolean> Move_to_end_address { get; set; }
		
		/// <summary>
		/// If it is false, the algorithm decides where to end the vehicle route. It ends in one of your customers' locations. The end is chosen such that it contributes to the overall objective function, e.g. min transport_time. If it is true, you can either specify a specific end location (which is then regarded as end depot) or you can leave it and the driver returns to its start location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="return_to_depot")]
		public System.Nullable<System.Boolean> Return_to_depot { get; set; }
		
		/// <summary>
		/// Array of skills, i.e. array of string (not case sensitive).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="skills")]
		public string[] Skills { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start_address")]
		public Address Start_address { get; set; }
		
		/// <summary>
		/// The type ID assigns a vehicle type to this vehicle. You can specify types in the array of vehicle types. If you omit the type ID, the default type is used. The default type is a `car` with a capacity of 0.
		/// </summary>
		[System.ComponentModel.DefaultValue("default-type")]
		[System.Runtime.Serialization.DataMember(Name="type_id")]
		public string Type_id { get; set; } = "default-type";
		
		/// <summary>
		/// Specifies the ID of the vehicle. Ids must be unique, i.e. if there are two vehicles with the same ID, an error is returned.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vehicle_id")]
		public string Vehicle_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TimeWindowBreak
	{
		
		/// <summary>
		/// Specifies the duration of the break in seconds.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public long Duration { get; set; }
		
		/// <summary>
		/// Specifies the earliest start time of the break in seconds.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="earliest")]
		public long Earliest { get; set; }
		
		/// <summary>
		/// Specifies the latest start time of break in seconds.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latest")]
		public long Latest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Response
	{
		
		[System.Runtime.Serialization.DataMember(Name="copyrights")]
		public string[] Copyrights { get; set; }
		
		/// <summary>
		/// Processing time in ms. If job is still waiting in queue, processing_time is 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="processing_time")]
		public System.Nullable<System.Int64> Processing_time { get; set; }
		
		/// <summary>
		/// Only available if status field indicates `finished`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="solution")]
		public Solution Solution { get; set; }
		
		/// <summary>
		/// Indicates the current status of the job
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ClusterResponseStatus Status { get; set; }
		
		/// <summary>
		/// Waiting time in ms
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="waiting_time_in_queue")]
		public System.Nullable<System.Int64> Waiting_time_in_queue { get; set; }
	}
	
	/// <summary>
	/// Only available if status field indicates `finished`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Solution
	{
		
		/// <summary>
		/// Overall completion time in seconds, i.e. the sum of each routes/drivers operation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completion_time")]
		public System.Nullable<System.Int64> Completion_time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="costs")]
		public System.Nullable<System.Int32> Costs { get; set; }
		
		/// <summary>
		/// Overall distance travelled in meter, i.e. the sum of each route's transport distance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public System.Nullable<System.Int32> Distance { get; set; }
		
		/// <summary>
		/// Operation time of longest route in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_operation_time")]
		public System.Nullable<System.Int64> Max_operation_time { get; set; }
		
		/// <summary>
		/// Number of jobs that could not be assigned to final solution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="no_unassigned")]
		public System.Nullable<System.Int32> No_unassigned { get; set; }
		
		/// <summary>
		/// Number of employed vehicles.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="no_vehicles")]
		public System.Nullable<System.Int32> No_vehicles { get; set; }
		
		/// <summary>
		/// Overall preparation time in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preparation_time")]
		public System.Nullable<System.Int64> Preparation_time { get; set; }
		
		/// <summary>
		/// An array of routes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routes")]
		public Route[] Routes { get; set; }
		
		/// <summary>
		/// Overall service time in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service_duration")]
		public System.Nullable<System.Int64> Service_duration { get; set; }
		
		/// <summary>
		/// Use `transport_time` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Int64> Time { get; set; }
		
		/// <summary>
		/// Overall time travelled in seconds, i.e. the sum of each route's transport time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transport_time")]
		public System.Nullable<System.Int64> Transport_time { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unassigned")]
		public SolutionUnassigned Unassigned { get; set; }
		
		/// <summary>
		/// Overall waiting time in seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="waiting_time")]
		public System.Nullable<System.Int64> Waiting_time { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Route
	{
		
		/// <summary>
		/// Array of activities
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activities")]
		public Activity[] Activities { get; set; }
		
		/// <summary>
		/// Completion time of route in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completion_time")]
		public System.Nullable<System.Int64> Completion_time { get; set; }
		
		/// <summary>
		/// Distance of route in meter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public System.Nullable<System.Int64> Distance { get; set; }
		
		/// <summary>
		/// Array of route planning points
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="points")]
		public RoutePoint[] Points { get; set; }
		
		/// <summary>
		/// Preparation time of route in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preparation_time")]
		public System.Nullable<System.Int64> Preparation_time { get; set; }
		
		/// <summary>
		/// Service duration of route in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service_duration")]
		public System.Nullable<System.Int64> Service_duration { get; set; }
		
		/// <summary>
		/// Transport time of route in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transport_time")]
		public System.Nullable<System.Int64> Transport_time { get; set; }
		
		/// <summary>
		/// Id of vehicle that operates route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vehicle_id")]
		public string Vehicle_id { get; set; }
		
		/// <summary>
		/// Waiting time of route in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="waiting_time")]
		public System.Nullable<System.Int64> Waiting_time { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RoutePoint
	{
		
		[System.Runtime.Serialization.DataMember(Name="coordinates")]
		public string[] Coordinates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class SolutionUnassigned
	{
		
		/// <summary>
		/// An array of ids of unassigned breaks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="breaks")]
		public string[] Breaks { get; set; }
		
		/// <summary>
		/// An array of details, i.e. reason for unassigned services or shipments
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public Detail[] Details { get; set; }
		
		/// <summary>
		/// An array of ids of unassigned services
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="services")]
		public string[] Services { get; set; }
		
		/// <summary>
		/// An array of ids of unassigned shipments
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shipments")]
		public string[] Shipments { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RouteRequest
	{
		
		/// <summary>
		/// Rather than looking for the shortest or fastest path, this lets you solve two different problems related to routing:
		///With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
		///a bike trip), so we will add some randomness. This requires `ch.disable=true`.
		///With `alternative_route`, we give you not one but several routes that are close to optimal, but
		///not too similar to each other. You can control both of these features with additional parameters, see below.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="algorithm")]
		public System.Nullable<RouteRequestAlgorithm> Algorithm { get; set; }
		
		/// <summary>
		/// If `algorithm=alternative_route`, this parameter sets the number of maximum paths which should be calculated. Increasing can lead to worse alternatives.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alternative_route.max_paths")]
		public System.Nullable<System.Int32> Alternative_route_max_paths { get; set; }
		
		/// <summary>
		/// If `algorithm=alternative_route`, this parameter specifies how similar an alternative route can be to the optimal route. Increasing can lead to worse alternatives.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alternative_route.max_share_factor")]
		public System.Nullable<System.Double> Alternative_route_max_share_factor { get; set; }
		
		/// <summary>
		/// If `algorithm=alternative_route`, this parameter sets the factor by which the alternatives routes can be longer than the optimal route. Increasing can lead to worse alternatives.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alternative_route.max_weight_factor")]
		public System.Nullable<System.Double> Alternative_route_max_weight_factor { get; set; }
		
		/// <summary>
		/// Specify which road classes and environments you would like to avoid.
		///Possible values are `motorway`, `steps`, `track`, `toll`, `ferry`, `tunnel` and `bridge`.
		///Separate several values with `;`. Obviously not all the values make sense for all vehicle profiles e.g. `bike` is already forbidden on a `motorway`. Requires `ch.disable=true`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avoid")]
		public string Avoid { get; set; }
		
		/// <summary>
		/// Block road access via a point with the format `latitude,longitude`
		///or an area defined by a circle `lat,lon,radius` or a rectangle `lat1,lon1,lat2,lon2`.
		///Separate several values with `;`. Requires `ch.disable=true`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="block_area")]
		public string Block_area { get; set; }
		
		/// <summary>
		/// If the points for the route should be calculated at all.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="calc_points")]
		public System.Nullable<System.Boolean> Calc_points { get; set; }
		
		/// <summary>
		/// Use this parameter in combination with one or more parameters from below.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ch.disable")]
		public System.Nullable<System.Boolean> Ch_disable { get; set; }
		
		/// <summary>
		/// Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="curbsides")]
		public string[] Curbsides { get; set; }
		
		/// <summary>
		/// If `true`, the output will be formatted.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="debug")]
		public System.Nullable<System.Boolean> Debug { get; set; }
		
		/// <summary>
		/// Optional parameter to retrieve path details. You can request additional details for the route: `street_name`,
		///`time`, `distance`, `max_speed`, `toll`, `road_class`, `road_class_link`, `road_access`, `road_environment`, `lanes`, and `surface`. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// If `true`, a third coordinate, the altitude, is included with all positions in the response.
		///This changes the format of the `points` and `snapped_waypoints` fields of the response, in both their
		///encodings. Unless you switch off the `points_encoded` parameter, you need special code on the
		///client side that can handle three-dimensional coordinates.
		///A request can fail if the vehicle profile does not support elevation. See the features object for every vehicle profile.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="elevation")]
		public System.Nullable<System.Boolean> Elevation { get; set; }
		
		/// <summary>
		/// Time penalty in seconds for not obeying a specified heading. Requires `ch.disable=true`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="heading_penalty")]
		public System.Nullable<System.Int32> Heading_penalty { get; set; }
		
		/// <summary>
		/// Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points.
		///In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree.
		///This parameter also influences the tour generated with `algorithm=round_trip` and forces the initial direction.  Requires `ch.disable=true`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headings")]
		public int[] Headings { get; set; }
		
		/// <summary>
		/// If instructions should be calculated and returned
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instructions")]
		public System.Nullable<System.Boolean> Instructions { get; set; }
		
		/// <summary>
		/// The locale of the resulting turn instructions. E.g. `pt_PT` for Portuguese or `de` for German.
		///
		/// </summary>
		[System.ComponentModel.DefaultValue("en")]
		[System.Runtime.Serialization.DataMember(Name="locale")]
		public string Locale { get; set; } = "en";
		
		/// <summary>
		/// Normally, the calculated route will visit the points in the order you specified them.
		///If you have more than two points, you can set this parameter to `"true"` and the points may be re-ordered to minimize the total travel time.
		///Keep in mind that the limits on the number of locations of the Route Optimization API applies, and the request costs more credits.
		///
		/// </summary>
		[System.ComponentModel.DefaultValue("false")]
		[System.Runtime.Serialization.DataMember(Name="optimize")]
		public string Optimize { get; set; } = "false";
		
		/// <summary>
		/// If `true`, u-turns are avoided at via-points with regard to the `heading_penalty`. Requires `ch.disable=true`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pass_through")]
		public System.Nullable<System.Boolean> Pass_through { get; set; }
		
		/// <summary>
		/// Optional parameter. Specifies a hint for each point in the `points` array to prefer a certain street for the closest location lookup. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="point_hints")]
		public string[] Point_hints { get; set; }
		
		/// <summary>
		/// The points for the route in an array of `[longitude,latitude]`. For instance, if you want to calculate a route from point A to B to C
		///then you specify `points: [ [A_longitude, A_latitude], [B_longitude, B_latitude], [C_longitude, C_latitude]]
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="points")]
		public string[] Points { get; set; }
		
		/// <summary>
		/// Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact
		///but requires special client code to unpack. (We provide it in our JavaScript client library!)
		///Set this parameter to `false` to switch the encoding to simple coordinate pairs like `[lon,lat]`, or `[lon,lat,elevation]`.
		///See the description of the response format for more information.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="points_encoded")]
		public System.Nullable<System.Boolean> Points_encoded { get; set; }
		
		/// <summary>
		/// If `algorithm=round_trip`, this parameter configures approximative length of the resulting round trip. Requires `ch.disable=true`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="round_trip.distance")]
		public System.Nullable<System.Int32> Round_trip_distance { get; set; }
		
		/// <summary>
		/// If `algorithm=round_trip`, this sets the random seed. Change this to get a different tour for each value.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="round_trip.seed")]
		public System.Nullable<System.Int64> Round_trip_seed { get; set; }
		
		/// <summary>
		/// Optional parameter to avoid snapping to a certain road class or road environment. Current supported values `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snap_preventions")]
		public string[] Snap_preventions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vehicle")]
		public VehicleProfileId Vehicle { get; set; }
		
		/// <summary>
		/// Determines the way the ''best'' route is calculated. Default is `fastest`. Other options are `shortest` (e.g. for `vehicle=foot` or `bike`) and `short_fastest` which finds a reasonable balance between `shortest` and `fastest`. Requires `ch.disable=true`.
		///
		/// </summary>
		[System.ComponentModel.DefaultValue("fastest")]
		[System.Runtime.Serialization.DataMember(Name="weighting")]
		public string Weighting { get; set; } = "fastest";
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RouteRequestAlgorithm
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		round_trip = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		alternative_route = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RouteResponse
	{
		
		/// <summary>
		/// Additional information for your request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="info")]
		public ResponseInfo Info { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="paths")]
		public RouteResponsePath[] Paths { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RouteResponsePath
	{
		
		/// <summary>
		/// The total ascent, in meters.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ascend")]
		public System.Nullable<System.Double> Ascend { get; set; }
		
		/// <summary>
		/// The bounding box of the route geometry. Format: `[minLon, minLat, maxLon, maxLat]`.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bbox")]
		public double[] Bbox { get; set; }
		
		/// <summary>
		/// The total descent, in meters.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="descend")]
		public System.Nullable<System.Double> Descend { get; set; }
		
		/// <summary>
		/// Details, as requested with the `details` parameter. Consider the value `{"street_name": [[0,2,"Frankfurter Strae"],[2,6,"Zollweg"]]}`.
		///In this example, the route uses two streets: The first, Frankfurter Strae, is
		///used between `points[0]` and `points[2]`, and the second, Zollweg, between `points[2]` and `points[6]`.
		///See [here](https://discuss.graphhopper.com/t/2539) for discussion.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
		
		/// <summary>
		/// The total distance, in meters. To get this information for one 'leg' please read [this blog post](https://www.graphhopper.com/blog/2019/11/28/routing-api-using-path-details/).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public System.Nullable<System.Double> Distance { get; set; }
		
		/// <summary>
		/// The instructions for this route. This feature is under active development, and our instructions can sometimes be misleading,
		///so be mindful when using them for navigation.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instructions")]
		public RouteResponsePathInstructions[] RouteResponsePathInstructions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="points")]
		public object Points { get; set; }
		
		/// <summary>
		/// Whether the `points` and `snapped_waypoints` fields are polyline-encoded strings rather than JSON arrays
		///of coordinates. See the field description for more information on the two formats.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="points_encoded")]
		public System.Nullable<System.Boolean> Points_encoded { get; set; }
		
		/// <summary>
		/// An array of indices (zero-based), specifiying the order in which the input points are visited.
		///Only present if the `optimize` parameter was used.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="points_order")]
		public int[] Points_order { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snapped_waypoints")]
		public object Snapped_waypoints { get; set; }
		
		/// <summary>
		/// The total travel time, in milliseconds. To get this information for one 'leg' please read [this blog post](https://www.graphhopper.com/blog/2019/11/28/routing-api-using-path-details/).
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Int64> Time { get; set; }
	}
	
	public class RouteResponsePathInstructions
	{
		
		/// <summary>
		/// The distance for this instruction, in meters.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="distance")]
		public System.Nullable<System.Double> Distance { get; set; }
		
		/// <summary>
		/// Only available for roundabout instructions (sign is 6). The count of exits at which the route leaves the roundabout.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exit_number")]
		public System.Nullable<System.Int32> Exit_number { get; set; }
		
		/// <summary>
		/// Two indices into `points`, referring to the beginning and the end of the segment of the route
		///this instruction refers to.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public int[] Interval { get; set; }
		
		/// <summary>
		/// A number which specifies the sign to show:
		///
		///| sign | description  |
		///|---|---|
		///|-98| an U-turn without the knowledge if it is a right or left U-turn |
		///| -8| a left U-turn |
		///| -7| keep left |
		///| -6| **not yet used**: leave roundabout |
		///| -3| turn sharp left |
		///| -2| turn left |
		///| -1| turn slight left |
		///|  0| continue on street |
		///|  1| turn slight right |
		///|  2| turn right |
		///|  3| turn sharp right |
		///|  4| the finish instruction before the last point |
		///|  5| the instruction before a via point |
		///|  6| the instruction before entering a roundabout |
		///|  7| keep right |
		///|  8| a right U-turn |
		///|  *| **For future compatibility** it is important that all clients are able to handle also unknown instruction sign numbers
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sign")]
		public System.Nullable<System.Int32> Sign { get; set; }
		
		/// <summary>
		/// The name of the street to turn onto in order to follow the route.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="street_name")]
		public string Street_name { get; set; }
		
		/// <summary>
		/// A description what the user has to do in order to follow the route. The language depends on the locale parameter.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The duration for this instruction, in milliseconds.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="time")]
		public System.Nullable<System.Int32> Time { get; set; }
		
		/// <summary>
		/// Only available for roundabout instructions (sign is 6). The radian of the route within the roundabout `0 < r < 2*PI` for clockwise and
		///`-2*PI < r < 0` for counterclockwise turns.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="turn_angle")]
		public System.Nullable<System.Double> Turn_angle { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SymmetricalMatrixRequest
	{
		
		/// <summary>
		/// Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="curbsides")]
		public string[] Curbsides { get; set; }
		
		/// <summary>
		/// Specifies whether or not the matrix calculation should return with an error as soon as possible in case some points cannot be found or some points are not connected. If set to `false` the time/weight/distance matrix will be calculated for all valid points and contain the `null` value for all entries that could not be calculated. The `hint` field of the response will also contain additional information about what went wrong (see its documentation).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fail_fast")]
		public System.Nullable<System.Boolean> Fail_fast { get; set; }
		
		/// <summary>
		/// Specifies which matrices should be included in the response. Specify one or more of the following options `weights`, `times`, `distances`. The units of the entries of `distances` are meters, of `times` are seconds and of `weights` is arbitrary and it can differ for different vehicles or versions of this API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="out_arrays")]
		public string[] Out_arrays { get; set; }
		
		/// <summary>
		/// Optional parameter. Specifies a hint for each point in the `points` array to prefer a certain street for the closest location lookup. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="point_hints")]
		public string[] Point_hints { get; set; }
		
		/// <summary>
		/// Specify multiple points for which the weight-, route-, time- or distance-matrix should be calculated as follows: `[longitude,latitude]`. In this case the origins are identical to the destinations. Thus, if there are N points, NxN entries are calculated. The order of the point parameter is important. Specify at least three points. Cannot be used together with `from_point` or `to_point.`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="points")]
		public string[] Points { get; set; }
		
		/// <summary>
		/// Optional parameter to avoid snapping to a certain road class or road environment. Current supported values `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snap_preventions")]
		public string[] Snap_preventions { get; set; }
		
		/// <summary>
		/// Specifies if turn restrictions should be considered. Enabling this option increases the matrix computation time. Only supported for motor vehicles and OpenStreetMap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="turn_costs")]
		public System.Nullable<System.Boolean> Turn_costs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vehicle")]
		public VehicleProfileId Vehicle { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// POST Cluster Endpoint
		/// 
		/// The Cluster endpoint is used with a POST request towards
		/// `https://graphhopper.com/api/1/cluster?key=<your_key>`. The solution will be provided in the JSON response.
		/// Please note that for problems that take longer than 10 seconds a bad request error is returned.
		/// In this case please use the asynchronous [Batch Cluster Endpoint](#operation/asyncClusteringProblem) instead.
		/// 
		/// SolveClusteringProblem cluster
		/// </summary>
		/// <param name="requestBody">Request object that contains the problem to be solved</param>
		/// <returns>A response containing the solution</returns>
		public async Task<ClusterResponse> SolveClusteringProblemAsync(ClusterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ClusterResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Batch Cluster Endpoint
		/// 
		/// Prefer the [synchronous endpoint](#operation/solveClusteringProblem) and use this Batch Cluster endpoint for
		/// long running problems only. The work flow is asynchronous:
		/// 
		/// - send a POST request towards `https://graphhopper.com/api/1/cluster/calculate?key=<your_key>` and fetch the job_id.
		/// - poll the solution every 500ms until it gives `status=finished`. Do this with a GET request
		/// towards `https://graphhopper.com/api/1/cluster/solution/<job_id>?key=<your_key>`.
		/// 
		/// AsyncClusteringProblem cluster/calculate
		/// </summary>
		/// <param name="requestBody">Request object that contains the problem to be solved</param>
		/// <returns>A jobId you can use to retrieve your solution from the server - see solution endpoint.</returns>
		public async Task<JobId> AsyncClusteringProblemAsync(ClusterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/calculate";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<JobId>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// GET Batch Solution Endpoint
		/// This endpoint returns the solution of the clustering problems submitted to the [Batch Cluster endpoint](#operation/asyncClusteringProblem).
		/// You can fetch it with the job_id, you have been sent.
		/// 
		/// GetClusterSolution cluster/solution/{jobId}
		/// </summary>
		/// <param name="jobId">Request solution with jobId</param>
		/// <returns>A response containing the solution</returns>
		public async Task<ClusterResponse> GetClusterSolutionAsync(string jobId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "cluster/solution/"+ (jobId==null? "" : System.Uri.EscapeDataString(jobId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ClusterResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Geocoding Endpoint
		/// 
		/// ### Introduction
		/// 
		/// ![Geocoding Example](./img/geocoding-example.png)
		/// 
		/// _Geocoding_ describes the process of transforming an textual address representation to a coordinate (`latitude,longitude`).
		/// For example the conversion from `Berlin` to `52.5170365,13.3888599`.
		/// 
		/// _Reverse geocoding_ converts a coordinate to a textual address representation or place name. Find out more about Geocoding itself on [Wikipedia](http://en.wikipedia.org/wiki/Geocoding).
		/// 
		/// GetGeocode geocode
		/// </summary>
		/// <param name="q">If you do forward geocoding, this is `required` and is a textual description of the address you are looking for.</param>
		/// <param name="locale">Display the search results for the specified locale. Currently French (fr), English (en), German (de) and Italian (it) are supported. If the locale wasn't found the default (en) is used.</param>
		/// <param name="limit">Specify the maximum number of results to return</param>
		/// <param name="reverse">It is `required` to be `true` if you want to do a reverse geocoding request. If it is `true`, `point` must be defined as well, and `q` must not be used.</param>
		/// <param name="debug">If `true`, the output will be formatted.</param>
		/// <param name="point">_Forward geocoding_: The location bias in the format 'latitude,longitude' e.g. point=45.93272,11.58803. _Reverse geocoding_: The location to find amenities, cities.</param>
		/// <param name="provider">The provider parameter is currently under development and can fall back to `default` at any time.
		///The intend is to provide alternatives to our default geocoder. Each provider has its own strenghts and might fit better for certain scenarios, so it's worth to compare the different providers.
		///To try it append the `provider`parameter to the URL like `&provider=nominatim`,
		///the result structure should be identical in all cases - if not, please report this back to us.
		///Keep in mind that some providers do not support certain parameters or don't return some fields, for example `osm_id` and `osm_type` are not supported by every geocoding provider.
		///If you would like to use additional parameters of one of the providers, but it's not available for the GraphHopper Geocoding API, yet? Please contact us.
		///
		///The credit costs can be different for all providers - see [here](https://support.graphhopper.com/support/solutions/articles/44000718211-what-is-one-credit-) for more information about it.
		///
		///Currently, only the default provider and gisgraphy supports autocompletion of partial search strings.
		///
		///All providers support normal "forward" geocoding and reverse geocoding via `reverse=true`.
		///
		///#### Default (`provider=default`)
		///
		///This provider returns results of our internal geocoding engine, as described above.
		///In addition to the above documented parameters the following parameters are possible:
		///* `bbox` - the expected format is `minLon,minLat,maxLon,maxLat`
		///* `osm_tag` - you can filter `key:value` or exclude places with certain OpenStreetMap tags `!key:value`. E.g. `osm_tag=tourism:museum` or just the key `osm_tag=tourism`. To exclude multiple tags you add multiple `osm_tag` parameters.
		///
		///#### Nominatim (`provider=nominatim`)
		///
		///The GraphHopper Directions API uses a commercially hosted Nominatim geocoder. You can try this provider [here](https://nominatim.openstreetmap.org/). The provider does **not** fall under the [restrictions](https://operations.osmfoundation.org/policies/nominatim/) of the Nominatim instance hosted by OpenStreetMap.
		///
		///In addition to the above documented parameters Nominatim allows to use the following parameters, which can be used as documented [here](https://github.com/openstreetmap/Nominatim/blob/master/docs/api/Search.md#parameters):
		///
		///* `viewbox` - the expected format is `minLon,minLat,maxLon,maxLat`
		///* `bounded` - If 1 and a viewbox is given, restrict the result to items contained within that viewbox. Default is 0.
		///
		///#### Gisgraphy (`provider=gisgraphy`)
		///
		///This provider returns results from the Gisgraphy geocoder which you can try [here](https://services.gisgraphy.com/static/leaflet/index.html).
		///
		///**Limitations:** The `locale` parameter is not supported. Gisgraphy does not return OSM tags or an extent.
		///
		///Gisgraphy has a special autocomplete API, which you can use by adding `autocomplete=true` (does not work with `reverse=true`). The autocomplete API is optimized on predicting text input, but returns less information.
		///
		///In addition to the above documented parameters Gisgraphy allows to use the following parameters, which can be used as documented [here](https://www.gisgraphy.com/documentation/user-guide.php#geocodingservice):
		///
		///* `radius` - radius in meters
		///* `country` - restrict search for the specified country. The value must be the ISO 3166 Alpha 2 code of the country.
		///
		///#### NetToolKit (`provider=nettoolkit`)
		///
		///This provider returns results from the NetToolKit provider which is specialized for US addresses and provides a wrapper around Nominatim for other addresses. You can try it [here](https://www.nettoolkit.com/geo/demo).
		///
		///The following additional NetToolKit parameters are supported (read [here](https://www.nettoolkit.com/docs/geo/geocoding) for more details):
		///- `source`: User can choose which source provider to geocode the address, this value is "NetToolKit" by default
		///- `country_code`: an iso-3166-2 country code (e.g : US) filter the results to the specify country code
		///
		///**Limitations:** NetToolKit does not support the `locale` parameter. NetToolKit does not return OSM tags (e.g. osm_id, osm_type, osm_value).
		///
		///#### OpenCage Data (`provider=opencagedata`)
		///
		///This provider returns results from the OpenCageData geocoder which you can try [here](https://geocoder.opencagedata.com/demo).
		///
		///In addition to the above documented parameters OpenCage Data allows to use the following parameters, which can be used as documented [here](https://geocoder.opencagedata.com/api#forward-opt):
		///
		///* countrycode - The country code is a two letter code as defined by the ISO 3166-1 Alpha 2 standard. E.g. gb for the United Kingdom, fr for France, us for United States. 
		///* bounds - the expected format is `minLon,minLat,maxLon,maxLat`
		///</param>
		/// <returns>An array found locations</returns>
		public async Task<GeocodingResponse> GetGeocodeAsync(string q, string locale, int limit, bool reverse, bool debug, string point, string provider, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "geocode?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&limit="+limit+"&reverse="+reverse+"&debug="+debug+"&point=" + (point==null? "" : System.Uri.EscapeDataString(point))+"&provider=" + (provider==null? "" : System.Uri.EscapeDataString(provider));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<GeocodingResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Isochrone Endpoint
		/// ### Example
		/// You can get an example response via:
		/// 
		/// ```
		/// curl "https://graphhopper.com/api/1/isochrone?point=51.131108,12.414551&key=[YOUR_KEY]"
		/// ```
		/// 
		/// Don't forget to replace the placeholder with your own key.
		/// 
		/// ### Introduction
		/// ![Isochrone screenshot](./img/isochrone-example.png)
		/// 
		/// An isochrone of a location is ''a line connecting points at which a vehicle arrives at the same time'', see Wikipedia.
		/// With the same API you can also calculate isodistances, just use the parameter distance_limit instead of time_limit`.
		/// 
		/// ### Use Cases
		/// Some possible areas in which this API may be useful to you:
		/// 
		/// - real estate analysis
		/// - realtors
		/// - vehicle scheduling
		/// - geomarketing
		/// - reach of electric vehicles
		/// - transport planning
		/// - logistics (distribution and retail network planning)
		/// 
		/// ### API Clients and Examples
		/// See the [clients](#section/API-Clients) section in the main documentation, and [live examples](https://graphhopper.com/api/1/examples/#isochrone).
		/// 
		/// GetIsochrone isochrone
		/// </summary>
		/// <param name="point">Specify the start coordinate</param>
		/// <param name="time_limit">Specify which time the vehicle should travel. In seconds.</param>
		/// <param name="distance_limit">Specify which distance the vehicle should travel. In meters.</param>
		/// <param name="vehicle">The vehicle profile for which the route should be calculated.
		///</param>
		/// <param name="buckets">Number by which to divide the given `time_limit` to create `buckets` nested isochrones of time intervals `time_limit-n*time_limit/buckets`. Applies analogously to `distance_limit`.</param>
		/// <param name="reverse_flow">If `false` the flow goes from point to the polygon, if `true` the flow goes from the polygon "inside" to the point.
		///Example use case for `false`&#58; *How many potential customer can be reached within 30min travel time from your store* vs. `true`&#58; *How many customers can reach your store within 30min travel time.*
		///</param>
		/// <param name="weighting">Use `"shortest"` to get an isodistance line instead of an isochrone.</param>
		/// <returns>Isochrone Result</returns>
		public async Task<IsochroneResponse> GetIsochroneAsync(string point, int time_limit, int distance_limit, VehicleProfileId vehicle, int buckets, bool reverse_flow, GetIsochroneWeighting weighting, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "isochrone?point=" + (point==null? "" : System.Uri.EscapeDataString(point))+"&time_limit="+time_limit+"&distance_limit="+distance_limit+"&vehicle=" + vehicle+"&buckets="+buckets+"&reverse_flow="+reverse_flow+"&weighting=" + weighting;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<IsochroneResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Map-match a GPX file
		/// ### Example
		/// You get an example response for a GPX via:
		/// 
		/// ```
		/// curl -XPOST -H "Content-Type: application/gpx+xml" "https://graphhopper.com/api/1/match?vehicle=car&key=[YOUR_KEY]" --data @/path/to/some.gpx
		/// ```
		/// 
		/// A minimal working GPX file looks like
		/// ```gpx
		/// <gpx>
		/// <trk>
		/// <trkseg>
		/// <trkpt lat="51.343657" lon="12.360708"></trkpt>
		/// <trkpt lat="51.343796" lon="12.361337"></trkpt>
		/// <trkpt lat="51.342784" lon="12.361882"></trkpt>
		/// </trkseg>
		/// </trk>
		/// </gpx>
		/// ```
		/// 
		/// ### Introduction
		/// ![Map Matching screenshot](./img/map-matching-example.gif)
		/// 
		/// The Map Matching API is part of the GraphHopper Directions API and with this API you can snap measured GPS points typically as GPX files to a digital
		/// road network to e.g. clean data or attach certain data like elevation or turn instructions to it. Read more at Wikipedia.
		/// 
		/// In the example screenshot above and demo you see the Map Matching API in action where the black line is the GPS track and the green one is matched result.
		/// 
		/// Most of the times, you can simply POST a GPX file, but some of the request parameters of the [Routing API](#tag/Routing-API) apply here, too.
		/// 
		/// ### API Clients and Examples
		/// See the [clients](#section/API-Clients) section in the main documentation, and [live examples](https://graphhopper.com/api/1/examples/#map-matching).
		/// 
		/// ### Limits and Counts
		/// The cost for one request depends on the number of GPS location and is documented [here](https://graphhopper.com/api/1/docs/FAQ/).
		/// 
		/// One request should not exceed the Map Matching API location limit depending on the package, see the pricing in our dashboard.
		/// 
		/// PostGPX match
		/// </summary>
		/// <param name="gps_accuracy">Specify the precision of a point, in meter</param>
		/// <param name="vehicle">Specify the vehicle profile like car</param>
		/// <returns>Routing Result</returns>
		public async Task<RouteResponse> PostGPXAsync(int gps_accuracy, string vehicle, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "match?gps_accuracy="+gps_accuracy+"&vehicle=" + (vehicle==null? "" : System.Uri.EscapeDataString(vehicle));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<RouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// GET Matrix Endpoint
		/// With this Matrix Endpoint you submit the points and parameters via URL parameters and is the most convenient
		/// as it works out-of-the-box in the browser. If possible you should
		/// prefer using the [POST Matrix Endpoint](#operation/postMatrix) that avoids problems with many locations
		/// and can also gzip the **request**. (Note, that all endpoints return gzipped responses).
		/// 
		/// GetMatrix matrix
		/// </summary>
		/// <param name="point">Specify multiple points in `latitude,longitude` for which the weight-, route-, time- or distance-matrix should be calculated. In this case the starts are identical to the destinations. If there are N points, then NxN entries will be calculated. The order of the point parameter is important. Specify at least three points. Cannot be used together with from_point or to_point.</param>
		/// <param name="from_point">The starting points for the routes in `latitude,longitude`. E.g. if you want to calculate the three routes A-&gt;1, A-&gt;2, A-&gt;3 then you have one from_point parameter and three to_point parameters.</param>
		/// <param name="to_point">The destination points for the routes in `latitude,longitude`.</param>
		/// <param name="point_hint">Optional parameter. Specifies a hint for each `point` parameter to prefer a certain street for the closest location lookup. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.</param>
		/// <param name="from_point_hint">For the from_point parameter. See point_hint</param>
		/// <param name="to_point_hint">For the to_point parameter. See point_hint</param>
		/// <param name="snap_prevention">Optional parameter to avoid snapping to a certain road class or road environment. Current supported values `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`. Multiple values are specified like `snap_prevention=ferry&snap_prevention=motorway`
		///</param>
		/// <param name="curbside">Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap.</param>
		/// <param name="from_curbside">Curbside setting for the from_point parameter. See curbside.</param>
		/// <param name="to_curbside">Curbside setting for the to_point parameter. See curbside.</param>
		/// <param name="out_array">Specifies which arrays should be included in the response. Specify one or more of the following options 'weights', 'times', 'distances'. To specify more than one array use e.g. out_array=times&out_array=distances. The units of the entries of distances are meters, of times are seconds and of weights is arbitrary and it can differ for different vehicles or versions of this API.</param>
		/// <param name="vehicle">The vehicle profile for which the matrix should be calculated.</param>
		/// <param name="fail_fast">Specifies whether or not the matrix calculation should return with an error as soon as possible in case some points cannot be found or some points are not connected. If set to `false` the time/weight/distance matrix will be calculated for all valid points and contain the `null` value for all entries that could not be calculated. The `hint` field of the response will also contain additional information about what went wrong (see its documentation).</param>
		/// <param name="turn_costs">Specifies if turn restrictions should be considered. Enabling this option increases the matrix computation time. Only supported for motor vehicles and OpenStreetMap.</param>
		/// <returns>Matrix API response</returns>
		public async Task<MatrixResponse> GetMatrixAsync(string[] point, string[] from_point, string[] to_point, string[] point_hint, string[] from_point_hint, string[] to_point_hint, string[] snap_prevention, string[] curbside, string[] from_curbside, string[] to_curbside, string[] out_array, VehicleProfileId vehicle, bool fail_fast, bool turn_costs, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "matrix?"+string.Join("&", point.Select(z => $"point={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", from_point.Select(z => $"from_point={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", to_point.Select(z => $"to_point={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", point_hint.Select(z => $"point_hint={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", from_point_hint.Select(z => $"from_point_hint={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", to_point_hint.Select(z => $"to_point_hint={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", snap_prevention.Select(z => $"snap_prevention={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", curbside.Select(z => $"curbside={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", from_curbside.Select(z => $"from_curbside={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", to_curbside.Select(z => $"to_curbside={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", out_array.Select(z => $"out_array={System.Uri.EscapeDataString(z.ToString())}"))+"&vehicle=" + vehicle+"&fail_fast="+fail_fast+"&turn_costs="+turn_costs;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MatrixResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// POST Matrix Endpoint
		/// 
		/// The [GET endpoint](#operation/getMatrix) has an URL length limitation, which hurts for many locations per request.
		/// In those cases use this POST endpoint with a JSON as input. The only parameter in the URL will be the key.
		/// Both request scenarios are identical except that all singular parameter names are named as their plural for a POST request.
		/// The effected parameters are: `points`, `from_points`, `to_points`, and `out_arrays`. For the remaining parameters
		/// please refer to the [guide of the GET endpoint](#operation/getMatrix).
		/// 
		/// **Please note that in contrast to GET endpoint the points have to be specified as `[longitude, latitude]` array (in that order, similar to [GeoJson](http://geojson.org/geojson-spec.html#examples))**.
		/// 
		/// For example the query `point=10,11&point=20,22&vehicle=car` will be converted to the following JSON:
		/// ```json
		/// { "points": [[11,10], [22,20]], "vehicle": "car" }
		/// ```
		/// 
		/// A complete curl Example:
		/// ```bash
		/// curl -X POST -H "Content-Type: application/json" "https://graphhopper.com/api/1/matrix?key=[YOUR_KEY]" -d '{"elevation":false,"out_arrays":["weights", "times"],"from_points":[[-0.087891,51.534377],[-0.090637,51.467697],[-0.171833,51.521241],[-0.211487,51.473685]],"to_points":[[-0.087891,51.534377],[-0.090637,51.467697],[-0.171833,51.521241],[-0.211487,51.473685]],"vehicle":"car"}'
		/// ```
		/// 
		/// PostMatrix matrix
		/// </summary>
		/// <returns>Matrix API response</returns>
		public async Task<MatrixResponse> PostMatrixAsync(MatrixRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "matrix";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MatrixResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Batch Matrix Endpoint
		/// Prefer the [synchronous endpoint](#operation/postMatrix) and use this Batch endpoint for long running problems only.
		/// 
		/// The Batch Matrix endpoint allows using matrices with more locations and works asynchronously - similar to the [Batch Route Optimization endpoint](#operation/asyncVRP):
		/// * Create a HTTP POST request against `/matrix/calculate` and add the key in the URL: `/matrix/calculate?key=[YOUR_KEY]`. This will give you the `job_id` from the response json like `{ "job_id": "7ac65787-fb99-4e02-a832-2c3010c70097" }`
		/// * Poll via HTTP GET requests every 500ms against `/matrix/solution/[job_id]`
		/// 
		/// Here are some full examples via curl:
		/// ```bash
		/// $ curl -X POST -H "Content-Type: application/json" "https://graphhopper.com/api/1/matrix/calculate?key=[YOUR_KEY]" -d '{"points":[[13.29895,52.48696],[13.370876,52.489575],[13.439026,52.511206]]}'
		/// {"job_id":"7ac65787-fb99-4e02-a832-2c3010c70097"}
		/// ```
		/// 
		/// Pick the returned `job_id` and use it in the next GET requests:
		/// ```bash
		/// $ curl -X GET "https://graphhopper.com/api/1/matrix/solution/7ac65787-fb99-4e02-a832-2c3010c70097?key=[YOUR_KEY]"
		/// {"status":"waiting"}
		/// ```
		/// 
		/// When the calculation is finished (`status:finished`) the JSON response will contain the full matrix JSON under `solution`:
		/// ```bash
		/// $ curl -X GET "https://graphhopper.com/api/1/matrix/solution/7ac65787-fb99-4e02-a832-2c3010c70097?key=[YOUR_KEY]"
		/// {"solution":{"weights":[[0.0,470.453,945.414],[503.793,0.0,580.871],[970.49,569.511,0.0]],"info":{"copyrights":["GraphHopper","OpenStreetMap contributors"]}},"status":"finished"}
		/// ```
		/// 
		/// Please note that if an error occured while calculation the JSON will not have a status but contain directly the error message e.g.:
		/// ```json
		/// {"message":"Cannot find from_points: 1"}
		/// ```
		/// And the optional `hints` array.
		/// 
		/// CalculateMatrix matrix/calculate
		/// </summary>
		/// <returns>A jobId you can use to retrieve your solution from the server.</returns>
		public async Task<JobId> CalculateMatrixAsync(MatrixRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "matrix/calculate";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<JobId>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// GET Batch Matrix Endpoint
		/// This endpoint returns the solution of a JSON submitted to the Batch Matrix endpoint. You can fetch it with the job_id, you have been sent.
		/// 
		/// GetMatrixSolution matrix/solution/{jobId}
		/// </summary>
		/// <param name="jobId">Request solution with jobId</param>
		/// <returns>A response containing the matrix</returns>
		public async Task<MatrixResponse> GetMatrixSolutionAsync(string jobId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "matrix/solution/"+ (jobId==null? "" : System.Uri.EscapeDataString(jobId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<MatrixResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// GET Route Endpoint
		/// The GET request is the most simple one: just specify the parameter in the URL and you are done.
		/// Can be tried directly in every browser.
		/// 
		/// GetRoute route
		/// </summary>
		/// <param name="point">The points for which the route should be calculated. Format: `[latitude,longitude]`. Specify at least an origin and a destination. Via points are possible.
		///The maximum number depends on your plan.
		///</param>
		/// <param name="point_hint">The `point_hint` is typically a road name to which the associated `point` parameter should be snapped to. Specify no `point_hint` parameter or the same number as you have `point` parameters.
		///</param>
		/// <param name="snap_prevention">Optional parameter to avoid snapping to a certain road class or road environment. Currently supported values are `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`. Multiple values are specified like `snap_prevention=ferry&snap_prevention=motorway`.
		///</param>
		/// <param name="vehicle">The vehicle profile for which the route should be calculated.
		///</param>
		/// <param name="curbside">Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap.
		///</param>
		/// <param name="turn_costs">Specifies if turn restrictions should be considered. Enabling this option increases the route computation time. Only supported for motor vehicles and OpenStreetMap.
		///</param>
		/// <param name="locale">The locale of the resulting turn instructions. E.g. `pt_PT` for Portuguese or `de` for German.
		///</param>
		/// <param name="elevation">If `true`, a third coordinate, the altitude, is included with all positions in the response.
		///This changes the format of the `points` and `snapped_waypoints` fields of the response, in both their
		///encodings. Unless you switch off the `points_encoded` parameter, you need special code on the
		///client side that can handle three-dimensional coordinates.
		///A request can fail if the vehicle profile does not support elevation. See the features object for every vehicle profile.
		///</param>
		/// <param name="details">Optional parameter to retrieve path details. You can request additional details for the route: `street_name`, 
		///`time`, `distance`, `max_speed`, `toll`, `road_class`, `road_class_link`, `road_access`, `road_environment`, `lanes`, and `surface`. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539).
		///</param>
		/// <param name="optimize">Normally, the calculated route will visit the points in the order you specified them.
		///If you have more than two points, you can set this parameter to `"true"` and the points may be re-ordered to minimize the total travel time.
		///Keep in mind that the limits on the number of locations of the Route Optimization API applies, and the request costs more credits.
		///</param>
		/// <param name="instructions">If instructions should be calculated and returned
		///</param>
		/// <param name="calc_points">If the points for the route should be calculated at all.
		///</param>
		/// <param name="debug">If `true`, the output will be formatted.
		///</param>
		/// <param name="points_encoded">Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact
		///but requires special client code to unpack. (We provide it in our JavaScript client library!)
		///Set this parameter to `false` to switch the encoding to simple coordinate pairs like `[lon,lat]`, or `[lon,lat,elevation]`.
		///See the description of the response format for more information.
		///</param>
		/// <param name="ch_disable">Use this parameter in combination with one or more parameters from below.
		///</param>
		/// <param name="weighting">Determines the way the "best" route is calculated. Besides `fastest` you can use `short_fastest` which finds a reasonable balance between the distance influence (`shortest`) and the time (`fastest`). You could also use `shortest` but is deprecated and not recommended for motor vehicles. All except `fastest` require `ch.disable=true`.
		///</param>
		/// <param name="heading">Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points.
		///In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree.
		///This parameter also influences the tour generated with `algorithm=round_trip` and forces the initial direction.  Requires `ch.disable=true`.
		///</param>
		/// <param name="heading_penalty">Time penalty in seconds for not obeying a specified heading. Requires `ch.disable=true`.
		///</param>
		/// <param name="pass_through">If `true`, u-turns are avoided at via-points with regard to the `heading_penalty`. Requires `ch.disable=true`.
		///</param>
		/// <param name="block_area">Block road access by specifying a point close to the road segment to be blocked, with the format `lat,lon`.
		///You can also block all road segments crossing a geometric shape. Specify a circle using the format `lat,lon,radius`, or a polygon using the format `lat1,lon1,lat2,lon2,...,latN,lonN`.
		///You can specify several shapes, separating them with `;`. Requires `ch.disable=true`.
		///</param>
		/// <param name="avoid">Specify which road classes and environments you would like to avoid. 
		///Possible values are `motorway`, `steps`, `track`, `toll`, `ferry`, `tunnel` and `bridge`.
		///Separate several values with `;`. Obviously not all the values make sense for all vehicle profiles e.g. `bike` is already forbidden on a `motorway`. Requires `ch.disable=true`.
		///</param>
		/// <param name="algorithm">Rather than looking for the shortest or fastest path, this parameter lets you solve two different problems related to routing:
		///With `alternative_route`, we give you not one but several routes that are close to optimal, but
		///not too similar to each other. 
		///With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
		///a bike trip), so we will add some randomness. The `round_trip` option requires `ch.disable=true`.
		///You can control both of these features with additional parameters, see below. 
		///</param>
		/// <param name="round_trip_distance">If `algorithm=round_trip`, this parameter configures approximative length of the resulting round trip. Requires `ch.disable=true`.
		///</param>
		/// <param name="round_trip_seed">If `algorithm=round_trip`, this sets the random seed. Change this to get a different tour for each value.
		///</param>
		/// <param name="alternative_route_max_paths">If `algorithm=alternative_route`, this parameter sets the number of maximum paths which should be calculated. Increasing can lead to worse alternatives.
		///</param>
		/// <param name="alternative_route_max_weight_factor">If `algorithm=alternative_route`, this parameter sets the factor by which the alternatives routes can be longer than the optimal route. Increasing can lead to worse alternatives.
		///</param>
		/// <param name="alternative_route_max_share_factor">If `algorithm=alternative_route`, this parameter specifies how similar an alternative route can be to the optimal route. Increasing can lead to worse alternatives.
		///</param>
		/// <returns>Routing Result</returns>
		public async Task<RouteResponse> GetRouteAsync(
					string[] point, 
					string[] point_hint, 
					string[] snap_prevention, 
					VehicleProfileId vehicle, 
					string[] curbside, 
					bool turn_costs, 
					string locale, 
					bool elevation, 
					string[] details, 
					string optimize, 
					bool instructions, 
					bool calc_points, 
					bool debug, 
					bool points_encoded, 
					bool ch_disable, 
					string weighting, 
					int[] heading, 
					int heading_penalty, 
					bool pass_through, 
					string block_area, 
					string avoid, 
					RouteRequestAlgorithm algorithm, 
					int round_trip_distance, 
					long round_trip_seed, 
					int alternative_route_max_paths, 
					double alternative_route_max_weight_factor, 
					double alternative_route_max_share_factor, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "route?"+string.Join("&", point.Select(z => $"point={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", point_hint.Select(z => $"point_hint={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", snap_prevention.Select(z => $"snap_prevention={System.Uri.EscapeDataString(z.ToString())}"))+"&vehicle=" + vehicle+"&"+string.Join("&", curbside.Select(z => $"curbside={System.Uri.EscapeDataString(z.ToString())}"))+"&turn_costs="+turn_costs+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&elevation="+elevation+"&"+string.Join("&", details.Select(z => $"details={System.Uri.EscapeDataString(z.ToString())}"))+"&optimize=" + (optimize==null? "" : System.Uri.EscapeDataString(optimize))+"&instructions="+instructions+"&calc_points="+calc_points+"&debug="+debug+"&points_encoded="+points_encoded+"&ch.disable="+ch_disable+"&weighting=" + (weighting==null? "" : System.Uri.EscapeDataString(weighting))+"&"+string.Join("&", heading.Select(z => $"heading={z}"))+"&heading_penalty="+heading_penalty+"&pass_through="+pass_through+"&block_area=" + (block_area==null? "" : System.Uri.EscapeDataString(block_area))+"&avoid=" + (avoid==null? "" : System.Uri.EscapeDataString(avoid))+"&algorithm=" + algorithm+"&round_trip.distance="+round_trip_distance+"&round_trip.seed="+round_trip_seed+"&alternative_route.max_paths="+alternative_route_max_paths+"&alternative_route.max_weight_factor="+alternative_route_max_weight_factor+"&alternative_route.max_share_factor="+alternative_route_max_share_factor;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<RouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// POST Route Endpoint
		/// Please see the [GET endpoint](#operation/getRoute) for a simpler method on how to get started.
		/// If you are familiar with POST requests and JSON then do not hesitate to continue here.
		/// 
		/// Especially when you use many locations you should get familiar with this POST endpoint as the GET endpoint
		/// has an URL length limitation. Additionally the request of this POST endpoint can be compressed and can slightly
		/// speed up the request.
		/// 
		/// To do a request you send JSON data. Both request scenarios GET and POST are identical except that all singular parameter names are named as their plural for a POST request.
		/// The effected parameters are: `points`, `point_hints` and `snap_preventions`.
		/// 
		/// **Please note that in opposite to the GET endpoint, points are specified in the order of `longitude, latitude`**.
		/// 
		/// For example `point=10,11&point=20,22` will be converted to the `points` array (plural):
		/// ```json
		/// { "points": [[11,10], [22,20]] }
		/// ```
		/// Note again that also the order changes from `[latitude,longitude]` to `[longitude,latitude]`
		/// similar to [GeoJson](http://geojson.org/geojson-spec.html#examples).
		/// 
		/// Example:
		/// ```bash
		/// curl -X POST -H "Content-Type: application/json" "https://graphhopper.com/api/1/route?key=[YOUR_KEY]" -d '{"elevation":false,"points":[[-0.087891,51.534377],[-0.090637,51.467697]],"vehicle":"car"}'
		/// ```
		/// 
		/// PostRoute route
		/// </summary>
		/// <returns>Routing Result</returns>
		public async Task<RouteResponse> PostRouteAsync(RouteRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "route";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<RouteResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Coverage information
		/// Use this to find out details about the supported vehicle profiles and features, or if you just need to ping the server.
		/// 
		/// Routing_APIGet route/info
		/// </summary>
		/// <returns>Coverage Information</returns>
		public async Task<InfoResponse> Routing_APIGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "route/info";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<InfoResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// POST route optimization problem
		/// 
		/// To get started with the Route Optimization API, please read the [introduction](#tag/Route-Optimization-API).
		/// 
		/// To solve a new vehicle routing problem, make a HTTP POST to this URL
		/// 
		/// ```
		/// https://graphhopper.com/api/1/vrp?key=<your_key>
		/// ```
		/// 
		/// It returns the solution to this problem in the JSON response.
		/// 
		/// Please note that this URL is very well suited to solve minor problems.
		/// Larger vehicle routing problems, which take longer than 10 seconds to solve, cannot be solved.
		/// To solve them, please use the [batch mode URL](#operation/asyncVRP) instead.
		/// 
		/// SolveVRP vrp
		/// </summary>
		/// <param name="requestBody">The request that contains the vehicle routing problem to be solved.</param>
		/// <returns>A response containing the solution</returns>
		public async Task<Response> SolveVRPAsync(Request requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vrp";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Response>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// POST route optimization problem (batch mode)
		/// 
		/// To solve a vehicle routing problem, perform the following steps:
		/// 
		/// 1.) Make a HTTP POST to this URL
		/// 
		/// ```
		/// https://graphhopper.com/api/1/vrp/optimize?key=<your_key>
		/// ```
		/// 
		/// It returns a job id (job_id).
		/// 
		/// 2.) Take the job id and fetch the solution for the vehicle routing problem from this URL:
		/// 
		/// ```
		/// https://graphhopper.com/api/1/vrp/solution/<job_id>?key=<your_key>
		/// ```
		/// 
		/// We recommend to query the solution every 500ms until it returns 'status=finished'.
		/// 
		/// **Note**: Since the workflow is a bit more cumbersome and since you lose some time in fetching the solution, you should always prefer
		/// the [synchronous endpoint](#operation/solveVRP). You should use the batch mode only for long running problems.
		/// 
		/// AsyncVRP vrp/optimize
		/// </summary>
		/// <param name="requestBody">The request that contains the problem to be solved.</param>
		/// <returns>A jobId you can use to retrieve your solution from the server - see solution endpoint.</returns>
		public async Task<JobId> AsyncVRPAsync(Request requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vrp/optimize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<JobId>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// GET the solution (batch mode)
		/// 
		/// Take the job id and fetch the solution for the vehicle routing problem from this URL:
		/// 
		/// ```
		/// https://graphhopper.com/api/1/vrp/solution/<job_id>?key=<your_key>
		/// ```
		/// 
		/// You get the job id by sending a vehicle routing problem to the [batch mode URL](#operation/asyncVRP).
		/// 
		/// GetSolution vrp/solution/{jobId}
		/// </summary>
		/// <param name="jobId">Request solution with jobId</param>
		/// <returns>A response containing the solution</returns>
		public async Task<Response> GetSolutionAsync(string jobId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "vrp/solution/"+ (jobId==null? "" : System.Uri.EscapeDataString(jobId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Response>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public enum GetIsochroneWeighting
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fastest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shortest = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
